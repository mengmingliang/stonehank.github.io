{
  "content": "## Reselect\n\n当我们使用redux的`connect(mapStateToProps)`的时候\n\n有时候store的数据直接传进组件并不好，于是我们希望在将数据传进组件前，进行调整\n\n例如 store如下\n```\nconst mockStore={\n  descriptions:[\n    {name:\"a\",age:25},\n    {name:\"b\",age:38},\n    {name:\"c\",age:26}\n  ]\n}\n```\n我们希望传进组件的数据如下：\n```\n{\n  descriptions:{\n    name:[\"a\",\"b\",\"c\"],\n    age:[25,38,26]\n  }\n}\n```\n通常的办法：\n```js\nconst mapStateToProps=(state)=>{\n  const newDescriptions={}\n  state.descriptions.forEach((obj)=>{\n    for(let key in obj){\n      if(obj.hasOwnProperty(key)){\n        if(!newDescriptions[key]){\n          newDescriptions[key]=[]\n        }\n        newDescriptions[key].push(obj[key])\n      }\n    }\n  })\n  return {descriptions:newDescriptions}\n}\nconsole.log(mapStateToProps(mockStore)===mapStateToProps(mockStore))\n// false\n```\n缺陷：很明显这里每次执行都会返回一个全新的对象，因此redux的浅对比就会失效，造成多次重复渲染\n\n使用reselect\n```js\nimport {createSelector} from 'reselect'\n\nconst selectState=createSelector(\n  state=>state.descriptions,\n  descriptions=>{\n    const newDescriptions={}\n    descriptions.forEach((obj)=>{\n      for(let key in obj){\n        if(obj.hasOwnProperty(key)){\n          if(!newDescriptions[key]){\n            newDescriptions[key]=[]\n           }\n           newDescriptions[key].push(obj[key])\n        }\n      }\n    })\n    return {descriptions:newDescriptions}\n  }\n)\nconsole.log(selectState(mockStore)===selectState(mockStore))\n// true\n```\n通过测试，会发现，每次的返回值都是引用相等的(===)，原因是因为reselect内部使用了缓存，\n当参数(mockStore)相同，直接返回缓存的结果\n\n注意：比较参数是建立在我们编写*纯函数*的基础上，如果内部不是纯函数，但参数相同，也会返回缓存值，就很可能会造成意外的bug\n\n[详细代码](https://gist.github.com/stonehank/c5de2a4318ee9954503770047c998c7b)\n\n[更多关于reselect的学习](https://github.com/stonehank/sourcecode-analysis/blob/master/source-code.reselect/README.md)\n"
}
