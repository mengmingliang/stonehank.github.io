{
  "content": "\n####Diff算法3个策略\n\n1. 跨层级不进行不比较\n2. 不同类不进行比较\n3. 同类同级通过key比较\n\n主要对第三种进行解释\n\n## 例子\n\n更新前组件：`A-B-C-D` => 更新后组件：`C-B-E-A`\n\n满足`child._mountIndex < lastIndex`才会进行组件移动\n\n* `child._mountIndex`其实是当前的index，但此时正在比较，还未变动，也就是更新前的index\n\n* `lastIndex`是一个不断更新的值，每一个组件比较后，lastIndex为`Math.max(prevChild.mountIndex,lastIndex)`\n\n遍历新集合：\n\n比较C：`child._mountIndex`为2，`lastIndex`为0,不满足，不执行变动，更新`lastIndex`为2；\n\n比较B：`child._mountIndex`为1，`lastIndex`为2，满足，执行移动，更新`lastIndex`为2；\n\n比较E：旧集合未找到，执行添加，`lastIndex`为2；\n\n比较A：`child._mountIndex`为0，`lastIndex`为2，满足，执行移动，更新`lastIndex`为2；\n\n遍历旧集合，发现D，执行删除\n\n## 缺点\n\n从上面例子可以发现，diff算法主要通过不断更新`lastIndex`进行判断，因此，\n如果`lastIndex`一开始就更新成最后一个index，那么后面的所有组件都要进行变动。\n\n例如：\n\n更新前组件：`A-B-C-D` => 更新后组件：`D-A-B-C`\n\n一开始比较D：`child._mountIndex`为3，`lastIndex`为0,不满足，不执行变动，更新`lastIndex`为3；\n\n此时`lastIndex`已经为最大值，后面所有比较都会满足`child._mountIndex < lastIndex`\n\n更新变动为：\n\nD组件不变\n\nA,B,C组件都要移动\n\n"
}
