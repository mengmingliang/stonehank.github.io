{
	"content": "### 一\n```js\nconst pingEpic = action$ =>\n  action$.filter(action => action.type === 'PING')\n    .mapTo({ type: 'PONG' });\n```\n>pingEpic 会监听类型为 PING 的 actions，然后投射为新的 action，PONG。这个例子功能上相当于做了这件事情:\n\n```js\ndispatch({ type: 'PING' });\ndispatch({ type: 'PONG' });\n```\n>牢记: Epics 运行在正常分发渠道旁, 在 reducers 完全接受到它们之后。当你将一个 action 投射成另一个 action，\n>你不会 阻止原始的 action 到达 reducers; 该 action 已经通过了它!\n\n理解：\n\n通过查看redux源码：\n```js\n\nfunction dispatch(action) {\n    //...一些判断\n\n    // dispatch实际操作（顺序：先更新state，再执行监听）\n    try {\n      isDispatching = true\n      // 更新currentState\n      currentState = currentReducer(currentState, action)\n    } finally {\n      isDispatching = false\n    }\n    // 遍历执行每一个监听\n    const listeners = (currentListeners = nextListeners)\n    for (let i = 0; i < listeners.length; i++) {\n      const listener = listeners[i]\n      listener()\n    }\n\n    return action\n  }\n```\n\n可以看出是先更新state，说明一开始的action已经执行了，然后才去执行listener(即这里的Epics)\n\n### 二\n这里到底发生了什么\n```js\nconst fetchUser = username => ({ type: FETCH_USER, payload: username });\nconst fetchUserFulfilled = payload => ({ type: FETCH_USER_FULFILLED, payload });\n\n\nconst fetchUserEpic = action$ =>\n  action$.ofType(FETCH_USER)\n    .mergeMap(action =>\n      ajax.getJSON(`https://api.github.com/users/${action.payload}`)\n        .map(response => fetchUserFulfilled(response))\n    );\n```\n\n我们用redux的时候写reducer是`action`入，`state`出，编写完成后通过`combineReducers`合并，再通过`createStore`添加\n\n这是一个reducer:\n```js\nconst users = (state = {}, action) => {\n  switch (action.type) {\n    case FETCH_USER_FULFILLED:\n      return {\n        ...state,\n        // `login` is the username\n        [action.payload.login]: action.payload\n      };\n\n    default:\n      return state;\n  }\n};\n```\n\n而这里则是编写epic，`action$`入，`action$`出，这两个action$流不能是同一个，编写完成后，通过`combineEpics`合并，\n再通过`createEpicMiddleware`创建，最后通过`applyMiddleware`加入到`createStore`中\n\n这是一个epic:\n```js\nconst fetchUserEpic = action$ =>\n  action$.ofType(FETCH_USER)\n    .mergeMap(action =>\n      ajax.getJSON(`https://api.github.com/users/${action.payload}`)\n        .map(response => fetchUserFulfilled(response))\n    );\n```\n\n因此，解释上面那一段：\n\n```\n// 定义2个cation\nconst fetchUser = username => ({ type: FETCH_USER, payload: username });\nconst fetchUserFulfilled = payload => ({ type: FETCH_USER_FULFILLED, payload });\n\n// 定义一个epic，入口action$为每一个action组成的流\nconst fetchUserEpic = action$ =>\n  // 搜索出type为FETCH_USER的action\n  action$.ofType(FETCH_USER)\n    // mergeMap方法，简单来说就是将内部源的输出合并到外部源中，然后一起输出\n    // 再简单说，就是这个epic的出口就是fetchUserFulfilled(response)这个action组成的流\n    .mergeMap(action =>\n      ajax.getJSON(`https://api.github.com/users/${action.payload}`)\n        .map(response => fetchUserFulfilled(response))\n    );\n```\n\n然后通过redux-observable源码中`result$.subscribe(store.dispatch)`，因为store.dispatch是一个接受action的函数（看一），\n而result$这里就是action组成的流，因此这个订阅实际结果就是`store.dispatch(action$流中的每一个action)`，真的很精妙！\n\n不知道是否说清楚了，感觉还挺绕的，不过通过文档和源码结合也能慢慢缕清思路。"
}
