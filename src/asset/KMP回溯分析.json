{
  "content": "KMP算法中，当对应的字符不匹配时，需要对前一个索引进行回溯\n\n一般写法是：\n```js\nfunction calcNext(str,pat){\n  /*...*/\n  if(str[k]!==str[j]){\n    // 有些会写成k=next[k]，原理是一样的\n    // 这里k表示，所对应当前正在进行对比的索引\n    // k=next[k-1]表示找到k的前一位的公共匹配前后缀的数量，作为新的对比索引\n    k=next[k-1]\n  }\n}\n```\n![](./img/KPM图解.png)\n\n图中，当K和J不能匹配时，A和B是已经匹配的公共前后缀\n\n因此A和B是完全相等\n\nA内部的A1,A2是已经匹配的公共前后缀\n\nB内部的B1,B2是已经匹配的公共前后缀\n\n因此A1===A2===B1===B2\n\n要想找到可能和J匹配的最大公共前后缀，只能找A的前缀(因为A的后缀连着k，而k不相等，所以k不能用了，只能找它前面的)，与J进行比较\n\n也就是从`next[k-1]`开始匹配\n\n代码：\n```js\nfunction calcNext(str){\n  let i=1,k=0\n  let next=[]\n  next[0]=0\n  while(i < str.length){\n    // 不相等时\n    if(str[i]!==str[k]){\n      // 如果k已经是0了(最小就是0)，直接设置成0\n      if(k===0)next[i++]=k\n        // 否则就回溯到前一个公共前缀的位置\n      else {\n        k=next[k-1]\n      }\n    }else{\n      // 相等，就直接在k的索引上+1，表示匹配的length\n      next[i]=k+1\n      i++;\n      k++;\n    }\n  }\n  return next\n}\n\nfunction kpm(str,pat){\n  if(pat.length===0) return 0\n  let next=calcNext(pat)\n  let i=0,j=0\n  while(i<str.length ){\n    if(str[i]===pat[j]){\n      i++;j++\n      // j===pat.length说明已经匹配成功\n      if(j===pat.length) return i-j\n    }else{\n      if(j===0){\n        i++\n      }else{\n        j=next[j-1]\n      }\n    }\n  }\n  return -1\n}\n```"
}
