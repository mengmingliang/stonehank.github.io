{
  "content": "* useCallback\n\n* useMemo\n\n`useCallback(fn, inputs) is equivalent to useMemo(() => fn, inputs)`\n\n根据inputs的内容判断是否执行缓存。\n\n待更新：\n\n与`shouldComponentUpdate`搭配\n\n* useRef\n\n1. 可以当成class中的ref属性使用，与`React.createRef()`类似，引用值放在`.current`属性下。\n\n    ```js\n    function TextInputWithFocusButton() {\n      const inputEl = useRef(null);\n      const onButtonClick = () => {\n        // `current` points to the mounted text input element\n        inputEl.current.focus();\n      };\n      return (\n        <>\n          <input ref={inputEl} type=\"text\" />\n          <button onClick={onButtonClick}>Focus the input</button>\n        </>\n      );\n    }\n    ```\n\n2. 可以当成`instance fields in class`使用，类似于`this.xxx`，保留任何变量。\n\n* useImperativeMethods\n\n自定义并且暴露一个`ref`实例的方法到父元素，一般搭配`forwardRef`使用。\n\n```js\nfunction FancyInput(props, ref) {\n  const inputRef = useRef();\n  useImperativeMethods(ref, () => ({\n    focus: () => {\n      inputRef.current.focus();\n    }\n  }));\n  return <input ref={inputRef} ... />;\n}\nFancyInput = forwardRef(FancyInput);\n```\n\n当父元素这么调用`<FancyInput ref={fancyInputRef} />`，`fancyInputRef.current`就存在`focus`方法。\n\n* useMutationEffect\n\n相当于`useEffect`在React执行DOM更新的时候同步调用。\n\n* useLayoutEffect\n\n相当于`useEffect`在React执行DOM更新结束的会后同步调用。\n\n有点像`componentDidUpdate`"
}
