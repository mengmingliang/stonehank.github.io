{
  "content": "本次解析将分为2篇文章，当前是第一篇，第二篇在[这里](./07-21-解析anime核心(2).md)\n\n另外，为了能更好的理解这个库，个人写了一个此库的压缩版，实现了核心的功能(主要也是为了更好理解核心功能)，内容更少方便阅读，\n地址在[这里](https://github.com/stonehank/simplify-anime)\n\n--------\n\n## 介绍\n[anime](http://animejs.com/)一个JS轻量动画库，摒弃了常规的`left,top`属性，全面采用`requestAnimateFrame+CSS3属性`能充分调用设备进行GPU渲染。\n\n它的亮点有以下(直接引用官网)：\n> * Keyframes(帧动画): Chain multiple animation properties.\n> * Timeline(同步动画): Synchronize multiple instances together.\n> * Playback controls(暂停回放功能): Play, pause, restart, seek animations or timelines.\n> * CSS transforms(CSS动画): Animate CSS transforms individually.\n> * Function based values(函数定义配置(注入了内部属性)): Multiple animated targets can have individual value.\n> * SVG Animations(SVG动画): Motion path, line drawing and morphing animations.\n> * Easing functions(自定义贝塞尔函数): Use the built in functions or create your own Cubic Bézier curve easing.\n\n这么多亮点，其实关键函数就3~4个。\n\n因为这里都是使用缓动函数算法，也就是通过 `初始位置`, `结束位置`, `持续时间`,`已消耗的时间` 计算出当前所在位置。\n\n`初始位置`、`结束位置`和`持续时间`是作为参数传入配置的，因此计算`已消耗时间`就是完成动画的核心。  \n\n下面就深入了解下它的核心。\n\n## 深入理解\n\n先了解几个时间的变量，动画都是`算法+时间=位置`这么算出来的：\n```js\n// 记录当前位置所对应的时间，根据lastTime计算\ninstance.cuurentTime\n// 记录当前位置所消耗的时间\nengineTime\n// 记录上一次计算完毕赋值后的位置对应时间\nlastTime\n// 上一次调用raf的时间\nstartTime\n// 当前位置所消耗时间(能匹配反转状态)，根据engineTime计算\ninsTime\n// 动画持续时间\ninsDuration\n// 延迟时间\ndelay\n// 从什么时间点开始动画\ninsOffset\n```\n\n接着看几个关键函数，这里先不放具体代码，只是先知道是做什么的(按一个正常动画顺序排放)：\n\n```js\n// anime的核心机制, 递归调用raf执行(关键)\nconst engine = (() => {\n  // ...requestAnimateFrame\n})();\n\n// anime主体\nfunction anime(params){\n  \n  // 定义instance 也是最终返回值\n  let instance = createNewInstance(params);\n  \n  // 外部API 从当前位置开始执行动画\n  instance.play = function() {}\n  \n  // 配置 startTime 和 engineTime(关键)\n   instance.tick = function(t) {}\n   \n  // 对当前engineTime进行判断，确定动画方案(关键)\n  function setInstanceProgress(engineTime) {}\n  \n  // 计算动画当前位置 并且赋值(关键)\n  function setAnimationsProgress(insTime){}\n\n  // 直接跳到参数time的时间所在的位置\n  instance.seek = function(time) {}\n  // 外部API 暂停\n  instance.pause = function() {}\n  // 外部API 反转\n  instance.reverse = function() {}\n  // 外部API reset\n  instance.reset = function() {}\n  // 外部API 重新开始\n  instance.restart = function() {}\n  /*...*/\n  return instance\n}\n```\n关键函数就4个，其他都是一些对关键函数的具体使用\n\n接着一个个解析：\n\n\n* createNewInstance\n\n其实就是对属性和方法合并成一个整体对象，这个对象是贯穿全局的，因此里面什么都有...\n```js\n function createNewInstance(params) {\n  \n    /* 对params进行处理 */\n    const instanceSettings = replaceObjectProps(defaultInstanceSettings, params);\n    const tweenSettings = replaceObjectProps(defaultTweenSettings, params);\n    const animatables = getAnimatables(params.targets);\n    const properties = getProperties(instanceSettings, tweenSettings, params);\n    const animations = getAnimations(animatables, properties);\n        \n    // mergeObjects(o1,o2)相当于 Object.assing({},o2,o1)\n    return mergeObjects(instanceSettings, {\n      children: [],\n      animatables: animatables,\n      animations: animations,\n      duration: getInstanceTimings('duration', animations, instanceSettings, tweenSettings),\n      delay: getInstanceTimings('delay', animations, instanceSettings, tweenSettings)\n    });\n  }\n```\n\n* instance.play\n\n此处先做了防护，只有paused状态下才会执行，`lastTime`这里是调取当前动画的位置对应的时间，因此才可以实现从任意位置开始动画。\n\n\n```js\n // 外部API 从当前位置开始执行动画\ninstance.play = function() {\n  if (!instance.paused) return;\n  instance.paused = false;\n  // 从0 开始\n  startTime = 0;\n  // 调取当前动画当前位置所对应的时间\n  lastTime = adjustTime(instance.currentTime);\n  // 给 activeInstances 添加当前实例，说明这是一个正在运行的动画\n  activeInstances.push(instance);\n  // raf未启动，调用engine\n  if (!raf) engine();\n}\n```\n\n* engine\n\nanime的核心机制，通过递归调用`requestAnimateFrame`，当检测到需要执行动画的集合`activeInstances`有值，调用instance.tick。\n\n```js\n  // IIFE 之后调用engine相当于执行内部的play\n  const engine = (() => {\n    // step收到一个参数，\n    function play() { raf = requestAnimationFrame(step); };\n    // 这里的参数t是 raf的参数中可以接受的一个时间戳，表示触发调用的时间\n    function step(t) {\n      // activeInstances指正在被执行的动画集合\n      const activeLength = activeInstances.length;\n      // 存在正在运行的动画\n      if (activeLength) {\n        let i = 0;\n        while (i < activeLength) {\n          // 调用tick执行\n          if (activeInstances[i]) activeInstances[i].tick(t);\n          i++;\n        }\n        play();\n      } else {\n        // 不存在正在运行的动画 cancel\n        cancelAnimationFrame(raf);\n        raf = 0;\n      }\n    }\n    return play;\n  })();\n```\n\n\n* instance.tick\n\ntick的作用通过参数`t`，`raf`的一个时间戳概念，计算出距离上一次调用实际消耗的时间`engineTime`。\n\n例如：上一次调用时间戳是`1000`，也就是1秒，中途突然执行一个巨大的任务，等任务结束，时间戳是`20000`，\n那么这次的`engineTime`就是`lastTime+20000-1000`，也就是计算这次动画从上次位置再加上19秒的位置...\n那么anime对于这种情况是怎么处理呢?继续看下一个`setInstanceProgress`。\n\n```js\n// 配置 startTime 和 engineTime\ninstance.tick = function(t) {\n  now = t;\n  // startTime 如果首次执行 就是now，否则就是上一次tick的时间\n  if (!startTime) startTime = now;\n  // lastTime 是上一次执行结束后动画对应位置的时间戳\n  // engineTime 是到动画目前为止消耗的总时间，一般理论上讲是lastTime+16.6667\n  const engineTime = (lastTime + now - startTime) * anime.speed;\n  setInstanceProgress(engineTime);\n}\n```\n\n* setInstanceProgress\n\n这个函数接受一个消耗的时间值，在内部对其进行适配和定义了各种情况的动画起始点，传递给`setAnimationsProgress`。\n\n例如，上面那个例子，如果消耗了19秒，就如进入这个判断:从结束点开始动画(考虑reverse的情况)。\n```js\n// 消耗的时间超出了持续时间 并且当前位置不在终点  或者 未设定持续时间\nif ((insTime >= insDuration && insCurrentTime !== insDuration) || !insDuration){\n  if ((insTime >= insDuration && insCurrentTime !== insDuration) || !insDuration) {\n    // 从结束点开始\n    setAnimationsProgress(insDuration);\n    if (!insReversed) countIteration();\n  }\n}\n```\n\nsetInstanceProgress(省略了一些配置的定义)\n\n```js\n// 对当前engineTime进行判断，确定动画方案\nfunction setInstanceProgress(engineTime) {\n  // 动画持续时间\n  const insDuration = instance.duration;\n  // 从什么时间点开始动画\n  const insOffset = instance.offset;\n  // 加上延迟后的开始时间\n  const insStart = insOffset + instance.delay;\n  // 记录当前位置所对应的时间\n  const insCurrentTime = instance.currentTime;\n  // 是否是反转状态\n  const insReversed = instance.reversed;\n  // 当前位置所消耗时间(能匹配反转状态)\n  // 这里adjustTime就是如果是反转状态，则返回 insDuration-engineTime\n  const insTime = adjustTime(engineTime);\n  /* ... */\n  // 消耗的时间大于应该开始的时间 并且 消耗的时间在持续时间范围内\n  if (insTime > insOffset && insTime < insDuration) {\n    setAnimationsProgress(insTime);\n  } else {\n    // 消耗的时间小于应该开始的时间 并且 当前位置不在起点\n    if (insTime <= insOffset && insCurrentTime !== 0) {\n      // 从头开始\n      setAnimationsProgress(0);\n      if (insReversed) countIteration();\n    }\n    // 消耗的时间超出了持续时间 并且当前位置不在终点  或者 未设定持续时间\n    if ((insTime >= insDuration && insCurrentTime !== insDuration) || !insDuration) {\n      // 从结束点开始\n      setAnimationsProgress(insDuration);\n      if (!insReversed) countIteration();\n    }\n  }\n  setCallback('update');\n  // 消耗时间大于持续时间 并且在终点(不在终点的上面已经判断了)\n  if (engineTime >= insDuration) {\n    if (instance.remaining) {\n      startTime = now;\n      if (instance.direction === 'alternate') toggleInstanceDirection();\n      // remaining为false，remaining>0说明还需要继续动画\n    } else {\n      // 完成动画的执行\n      instance.pause();\n      if (!instance.completed) {\n        instance.completed = true;\n        setCallback('complete');\n        if ('Promise' in window) {\n          resolve();\n          promise = makePromise();\n        }\n      }\n    }\n    lastTime = 0;\n  }\n}\n```\n\n关键函数`setAnimationsProgress`和后续的操作函数都放在下一篇继续解析。\n\n\n"
}
