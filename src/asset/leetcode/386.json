{
  "code": [
    "<pre class=\"hljs\"><code><span class=\"hljs-comment\">/**\n * @param {number} n\n * @return {number[]}\n */</span>\n<span class=\"hljs-keyword\">var</span> lexicalOrder = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">n</span>) </span>{\n  <span class=\"hljs-keyword\">let</span> result=[]\n  <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i=<span class=\"hljs-number\">1</span>;i&lt;<span class=\"hljs-number\">10</span>;i++){\n    dfs(result,i)\n  }\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">dfs</span>(<span class=\"hljs-params\">result,cur</span>)</span>{\n    <span class=\"hljs-keyword\">if</span>(cur&gt;n)<span class=\"hljs-keyword\">return</span> \n    result.push(cur)\n    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i=<span class=\"hljs-number\">0</span>;i&lt;<span class=\"hljs-number\">10</span>;i++){\n      <span class=\"hljs-keyword\">if</span>((<span class=\"hljs-number\">10</span>*cur+i)&gt;n)<span class=\"hljs-keyword\">return</span>\n      dfs(result,<span class=\"hljs-number\">10</span>*cur+i)\n    }        \n  }\n  <span class=\"hljs-keyword\">return</span> result\n};\n</code></pre>\n"
  ],
  "titleSlug": "lexicographical-numbers",
  "hasThinking": true,
  "thinking": "<hr>\n<p>思路：</p>\n<p>最直观就是排序。</p>\n<p>时间复杂度<code>O(N)</code>的解决方案，对于以<code>1</code>开头的，存在<code>10,11,12...19</code>，对于<code>10</code>开头的，存在<code>100,101,102...109</code>；</p>\n<p>因此对于从<code>1</code>到<code>9</code>每一个数，递归以它们开头的每一个数字，添加到结果。</p>\n",
  "content": "<p>给定一个整数&nbsp;<em>n</em>, 返回从&nbsp;<em>1&nbsp;</em>到&nbsp;<em>n&nbsp;</em>的字典顺序。</p>\n\n<p>例如，</p>\n\n<p>给定 <em>n</em> =1 3，返回 [1,10,11,12,13,2,3,4,5,6,7,8,9] 。</p>\n\n<p>请尽可能的优化算法的时间复杂度和空间复杂度。 输入的数据&nbsp;<em>n&nbsp;</em>小于等于&nbsp;5,000,000。</p>\n"
}
