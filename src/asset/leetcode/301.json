{
  "code": [
    "/**\n * @param {string} s\n * @return {string[]}\n */\nvar removeInvalidParentheses = function(s) {\n//   let counter=0,problemLeft=[],problemRight=[]\n//   // 分割左右\n//   for(let i=0;i<s.length;i++){\n//     if(s[i]===\"(\") { problemLeft.push(i); counter++}\n//     if(s[i]===\")\"){ problemLeft.pop(); counter--}\n//     if(counter<0){ problemRight.push(i); counter=0}\n//   }\n  \n//   let marked={},resultL=[],resultR=[]\n//   let pRLen=problemRight.length,pLLen=problemLeft.length\n//   // 获取剩余值\n//   let res=\"\"\n//   if(pLLen===0) res=s.substring(problemRight[pRLen-1]+1)\n//   if(pRLen===0) res=s.substring(0,problemLeft[0])\n//   if(pRLen>0 && pRLen>0) res=s.substring(problemRight[pRLen-1]+1,problemLeft[0])\n  \n//   // 重设左的字符串，并且backtrack\n//   if(pLLen>0){\n//     let problemLS=s.substring(problemLeft[0])\n//     let newProblemLeft=problemLeft.map(n=>n-problemLeft[0])\n//     backtrack(problemLS,resultL,[],newProblemLeft,0,0,false)\n//   }\n//   // backtrack右侧\n//   if(pRLen>0){\n//     let problemRS=s.substring(0,problemRight[pRLen-1]+1)\n//     backtrack(problemRS,resultR,[],problemRight,0,0,true)\n//   }\n\n//   function backtrack(allStr,result,temp,problemIdx,start,loopStart,isRight){\n//     if(start===problemIdx.length){\n//       let str='',idx=0\n//       for(let i=0;i<allStr.length;i++){\n//         if(i===temp[idx]){idx++;continue}\n//         str+=allStr[i]\n//       }\n//       if(!marked[str]){\n//         marked[str]=true\n//         result.push(str)\n//         return\n//       }\n//     }\n//     for(let i=loopStart;i<allStr.length;i++){\n//       if(isRight && i<=problemIdx[start] && allStr[i]===\")\"){\n//         temp.push(i)\n//         backtrack(allStr,result,temp,problemIdx,start+1,i+1,isRight)\n//         temp.pop()\n//       }\n//       if(!isRight && i>=problemIdx[start] && allStr[i]===\"(\"){\n//         temp.push(i)\n//         backtrack(allStr,result,temp,problemIdx,start+1,i+1,isRight)\n//         temp.pop()\n//       }\n//     }\n//   }\n\n\n//   function isEmpty(arr){\n//     if(arr.length===0 || (arr.length===1 && arr[0]===\"\"))return true\n//     return false\n//   }\n//   // 左右为空，直接返回剩余值\n//   if(isEmpty(resultR) && isEmpty(resultL))return [res]\n//   // 左或右为空，返回结果+剩余值\n//   if(isEmpty(resultR))return resultL.map(n=>res+n)\n//   if(isEmpty(resultL))return resultR.map(n=>n+res)\n  \n//   let finalRes=[]\n//   // 左右均不空，组合\n//   for(let i=0;i<resultR.length;i++){\n//     for(let j=0;j<resultL.length;j++){\n//       let str=resultR[i]+res+resultL[j]\n//       finalRes.push(str)\n//     }\n//   }\n//   return finalRes\n  \n  \n  \n  let ans = [];\n  remove(s, ans, 0, 0, ['(', ')']);\n  return ans;\n\n  function remove( s,  ans, last_i,  last_j,  par) {\n    for (let stack = 0, i = last_i; i < s.length; ++i) {\n        if (s.charAt(i) == par[0]) stack++;\n        if (s.charAt(i) == par[1]) stack--;\n        if (stack >= 0) continue;\n        for (let j = last_j; j <= i; ++j)\n            if (s[j] == par[1] && (j == last_j || s[j-1] != par[1]))\n                remove(s.substring(0, j) + s.substring(j + 1, s.length), ans, i, j, par);\n        return;\n    }\n    let reversed = s.split('').reverse().join('');\n    if (par[0] == '(') // finished left to right\n        remove(reversed, ans, 0, 0, [')', '(']);\n    else // finished right to left\n        ans.push(reversed);\n  }\n};"
  ],
  "titleSlug": "remove-invalid-parentheses",
  "content": "<p>Remove the minimum number of invalid parentheses in order to make the input string valid. Return all possible results.</p>\r\n\r\n<p><strong>Note:</strong>&nbsp;The input string may contain letters other than the parentheses <code>(</code> and <code>)</code>.</p>\r\n\r\n<p><b>Example 1:</b></p>\r\n\r\n<pre>\r\n<b>Input:</b> &quot;()())()&quot;\r\n<b>Output:</b> [&quot;()()()&quot;, &quot;(())()&quot;]\r\n</pre>\r\n\r\n<p><b>Example 2:</b></p>\r\n\r\n<pre>\r\n<b>Input:</b> &quot;(a)())()&quot;\r\n<b>Output:</b> [&quot;(a)()()&quot;, &quot;(a())()&quot;]\r\n</pre>\r\n\r\n<p><b>Example 3:</b></p>\r\n\r\n<pre>\r\n<b>Input:</b> &quot;)(&quot;\r\n<b>Output: </b>[&quot;&quot;]\r\n</pre>",
  "translatedContent": "<p>删除最小数量的无效括号，使得输入的字符串有效，返回所有可能的结果。</p>\n\n<p><strong>说明:</strong> 输入可能包含了除&nbsp;<code>(</code>&nbsp;和&nbsp;<code>)</code>&nbsp;以外的字符。</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre><strong>输入:</strong> &quot;()())()&quot;\n<strong>输出:</strong> [&quot;()()()&quot;, &quot;(())()&quot;]\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre><strong>输入:</strong> &quot;(a)())()&quot;\n<strong>输出:</strong> [&quot;(a)()()&quot;, &quot;(a())()&quot;]\n</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre><strong>输入:</strong> &quot;)(&quot;\n<strong>输出: </strong>[&quot;&quot;]</pre>\n"
}
