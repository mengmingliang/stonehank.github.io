{
  "code": [
    "<pre class=\"hljs\"><code><span class=\"hljs-comment\">/**\n * @param {number[][]} A\n * @param {number[][]} B\n * @return {number}\n */</span>\n<span class=\"hljs-keyword\">var</span> largestOverlap = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">A, B</span>) </span>{\n  <span class=\"hljs-keyword\">let</span> m=A.length,n=A[<span class=\"hljs-number\">0</span>].length\n  <span class=\"hljs-keyword\">let</span> res=<span class=\"hljs-number\">0</span>\n  <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> l=<span class=\"hljs-number\">0</span>;l&lt;n;l++){\n    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> u=<span class=\"hljs-number\">0</span>;u&lt;m;u++){\n      <span class=\"hljs-keyword\">let</span> same=<span class=\"hljs-number\">0</span>\n      <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i=<span class=\"hljs-number\">0</span>;i&lt;m;i++){\n        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> j=<span class=\"hljs-number\">0</span>;j&lt;n;j++){\n          <span class=\"hljs-keyword\">let</span> ai=i+u,aj=j+l\n          <span class=\"hljs-keyword\">if</span>(ai&gt;=m || aj&gt;=n)<span class=\"hljs-keyword\">continue</span>\n          <span class=\"hljs-keyword\">if</span>(A[ai][aj]===B[i][j] &amp;&amp; B[i][j]===<span class=\"hljs-number\">1</span>)same++\n        }\n      }\n      res=<span class=\"hljs-built_in\">Math</span>.max(res,same)\n    }\n  }\n  <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> r=<span class=\"hljs-number\">0</span>;r&lt;n;r++){\n    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> d=<span class=\"hljs-number\">0</span>;d&lt;m;d++){\n      <span class=\"hljs-keyword\">let</span> same=<span class=\"hljs-number\">0</span>\n      <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i=<span class=\"hljs-number\">0</span>;i&lt;m;i++){\n        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> j=<span class=\"hljs-number\">0</span>;j&lt;n;j++){\n          <span class=\"hljs-keyword\">let</span> bi=i+r,bj=j+d\n          <span class=\"hljs-keyword\">if</span>(bi&gt;=m || bj&gt;=n)<span class=\"hljs-keyword\">continue</span>\n          <span class=\"hljs-keyword\">if</span>(A[i][j]===B[bi][bj] &amp;&amp; A[i][j]===<span class=\"hljs-number\">1</span>)same++\n        }\n      }\n      res=<span class=\"hljs-built_in\">Math</span>.max(res,same)\n    }\n  }\n  <span class=\"hljs-keyword\">return</span> res\n};\n</code></pre>\n"
  ],
  "titleSlug": "image-overlap",
  "hasThinking": true,
  "thinking": "<hr>\n<p>思路：</p>\n<p>因为转换不能是旋转，因此我们可以选中<code>A</code>进行分析，要么是<code>A</code>上移<code>x</code>步，左移<code>y</code>步；要么是<code>A</code>下移<code>x</code>步，然后右移<code>y</code>步，\n反正上移和下移(左移和右移)不可能同时出现。</p>\n<p>那么我们就可以分别计算<code>上移左移</code>和<code>下移右移</code>的情况，其中上(下)移动存在<code>N</code>步，左(右)移动存在<code>N</code>步。</p>\n<h2>每次移动后，再去对比当前相同<code>1</code>的次数，最后返回最多的一次，最终时间复杂度是<code>O(N^4)</code>。</h2>\n",
  "content": "<p>给出两个图像 <code>A</code> 和 <code>B</code>&nbsp;，<code>A</code> 和 <code>B</code>&nbsp;为大小相同的二维正方形矩阵。（并且为二进制矩阵，只包含0和1）。</p>\n\n<p>我们转换其中一个图像，向左，右，上，或下滑动任何数量的单位，并把它放在另一个图像的上面。之后，该转换的重叠是指两个图像都具有 1 的位置的数目。</p>\n\n<p>（请注意，转换不包括向任何方向旋转。）</p>\n\n<p>最大可能的重叠是什么？</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre><strong>输入：</strong>A = [[1,1,0],\n          [0,1,0],\n&nbsp;         [0,1,0]]\n&nbsp;    B = [[0,0,0],\n&nbsp;         [0,1,1],\n&nbsp;         [0,0,1]]\n<strong>输出：</strong>3\n<strong>解释:</strong> 将 A 向右移动一个单位，然后向下移动一个单位。</pre>\n\n<p><strong>注意:</strong>&nbsp;</p>\n\n<ol>\n\t<li><code>1 &lt;= A.length = A[0].length = B.length = B[0].length &lt;= 30</code></li>\n\t<li><code>0 &lt;=&nbsp;A[i][j], B[i][j] &lt;= 1</code></li>\n</ol>\n"
}
