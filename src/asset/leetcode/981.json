{
  "code": [
    "<pre class=\"hljs\"><code><span class=\"hljs-comment\">/**\n * Initialize your data structure here.\n */</span>\n<span class=\"hljs-keyword\">var</span> TimeMap = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">this</span>.hash={}\n};\n\n<span class=\"hljs-comment\">/** \n * @param {string} key \n * @param {string} value \n * @param {number} timestamp\n * @return {void}\n */</span>\nTimeMap.prototype.set = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">key, value, timestamp</span>) </span>{\n  <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-keyword\">this</span>.hash[key]==<span class=\"hljs-literal\">null</span>)<span class=\"hljs-keyword\">this</span>.hash[key]=[]\n  <span class=\"hljs-keyword\">this</span>.hash[key].push([value,timestamp])\n};\n\n<span class=\"hljs-comment\">/** \n * @param {string} key \n * @param {number} timestamp\n * @return {string}\n */</span>\nTimeMap.prototype.get = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">key, timestamp</span>) </span>{\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">bsFront</span>(<span class=\"hljs-params\">arr,n</span>)</span>{\n    <span class=\"hljs-keyword\">let</span> lo=<span class=\"hljs-number\">0</span>,hi=arr.length<span class=\"hljs-number\">-1</span>\n    <span class=\"hljs-keyword\">while</span>(lo&lt;hi){\n      <span class=\"hljs-keyword\">let</span> mid=<span class=\"hljs-built_in\">Math</span>.ceil((lo+hi)/<span class=\"hljs-number\">2</span>)\n      <span class=\"hljs-keyword\">if</span>(arr[mid][<span class=\"hljs-number\">1</span>]&gt;n)hi=mid<span class=\"hljs-number\">-1</span>\n      <span class=\"hljs-keyword\">else</span> lo=mid\n    }\n    <span class=\"hljs-keyword\">return</span> lo\n  }\n  <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-keyword\">this</span>.hash[key]==<span class=\"hljs-literal\">null</span>)<span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">''</span>\n  <span class=\"hljs-keyword\">let</span> cand=<span class=\"hljs-keyword\">this</span>.hash[key]\n  <span class=\"hljs-keyword\">if</span>(timestamp&lt;cand[<span class=\"hljs-number\">0</span>][<span class=\"hljs-number\">1</span>])<span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">''</span>\n  <span class=\"hljs-keyword\">let</span> idx=bsFront(cand,timestamp)\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.hash[key][idx][<span class=\"hljs-number\">0</span>]\n};\n\n<span class=\"hljs-comment\">/** \n * Your TimeMap object will be instantiated and called as such:\n * var obj = Object.create(TimeMap).createNew()\n * obj.set(key,value,timestamp)\n * var param_2 = obj.get(key,timestamp)\n */</span>\n</code></pre>\n"
  ],
  "titleSlug": "time-based-key-value-store",
  "hasThinking": false,
  "content": "<p>创建一个基于时间的键值存储类&nbsp;<code>TimeMap</code>，它支持下面两个操作：</p>\n\n<p>1. <code>set(string key, string value, int timestamp)</code></p>\n\n<ul>\n\t<li>存储键&nbsp;<code>key</code>、值&nbsp;<code>value</code>，以及给定的时间戳&nbsp;<code>timestamp</code>。</li>\n</ul>\n\n<p>2. <code>get(string key, int timestamp)</code></p>\n\n<ul>\n\t<li>返回先前调用&nbsp;<code>set(key, value, timestamp_prev)</code>&nbsp;所存储的值，其中&nbsp;<code>timestamp_prev &lt;= timestamp</code>。</li>\n\t<li>如果有多个这样的值，则返回对应最大的&nbsp;&nbsp;<code>timestamp_prev</code>&nbsp;的那个值。</li>\n\t<li>如果没有值，则返回空字符串（<code>&quot;&quot;</code>）。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>inputs = [&quot;TimeMap&quot;,&quot;set&quot;,&quot;get&quot;,&quot;get&quot;,&quot;set&quot;,&quot;get&quot;,&quot;get&quot;], inputs = [[],[&quot;foo&quot;,&quot;bar&quot;,1],[&quot;foo&quot;,1],[&quot;foo&quot;,3],[&quot;foo&quot;,&quot;bar2&quot;,4],[&quot;foo&quot;,4],[&quot;foo&quot;,5]]\n<strong>输出：</strong>[null,null,&quot;bar&quot;,&quot;bar&quot;,null,&quot;bar2&quot;,&quot;bar2&quot;]\n<strong>解释：</strong>&nbsp; \nTimeMap kv; &nbsp; \nkv.set(&quot;foo&quot;, &quot;bar&quot;, 1); // 存储键 &quot;foo&quot; 和值 &quot;bar&quot; 以及时间戳 timestamp = 1 &nbsp; \nkv.get(&quot;foo&quot;, 1);  // 输出 &quot;bar&quot; &nbsp; \nkv.get(&quot;foo&quot;, 3); // 输出 &quot;bar&quot; 因为在时间戳 3 和时间戳 2 处没有对应 &quot;foo&quot; 的值，所以唯一的值位于时间戳 1 处（即 &quot;bar&quot;） &nbsp; \nkv.set(&quot;foo&quot;, &quot;bar2&quot;, 4); &nbsp; \nkv.get(&quot;foo&quot;, 4); // 输出 &quot;bar2&quot; &nbsp; \nkv.get(&quot;foo&quot;, 5); // 输出 &quot;bar2&quot; &nbsp; \n\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>inputs = [&quot;TimeMap&quot;,&quot;set&quot;,&quot;set&quot;,&quot;get&quot;,&quot;get&quot;,&quot;get&quot;,&quot;get&quot;,&quot;get&quot;], inputs = [[],[&quot;love&quot;,&quot;high&quot;,10],[&quot;love&quot;,&quot;low&quot;,20],[&quot;love&quot;,5],[&quot;love&quot;,10],[&quot;love&quot;,15],[&quot;love&quot;,20],[&quot;love&quot;,25]]\n<strong>输出：</strong>[null,null,null,&quot;&quot;,&quot;high&quot;,&quot;high&quot;,&quot;low&quot;,&quot;low&quot;]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ol>\n\t<li>所有的键/值字符串都是小写的。</li>\n\t<li>所有的键/值字符串长度都在&nbsp;<code>[1, 100]</code>&nbsp;范围内。</li>\n\t<li>所有&nbsp;<code>TimeMap.set</code>&nbsp;操作中的时间戳&nbsp;<code>timestamps</code> 都是严格递增的。</li>\n\t<li><code>1 &lt;= timestamp &lt;= 10^7</code></li>\n\t<li><code>TimeMap.set</code> 和&nbsp;<code>TimeMap.get</code>&nbsp;函数在每个测试用例中将（组合）调用总计&nbsp;<code>120000</code> 次。</li>\n</ol>\n"
}
