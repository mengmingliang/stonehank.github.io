{
  "code": [
    "/**\n * @param {number} num\n * @return {number}\n */\nvar findComplement = function(num) {\n    if(num===0){return 1}\n    let n=num;\n    let res=0;\n    let powN=0;\n    while(n>=1){\n        let x=n % 2? 0 : 1\n        n=parseInt(n/2,10)\n        res+=x*Math.pow(2,powN)\n        powN++;\n    }\n    return res\n};"
  ],
  "titleSlug": "number-complement",
  "content": "<p>Given a positive integer, output its complement number. The complement strategy is to flip the bits of its binary representation.</p>\r\n\r\n<p><b>Note:</b><br>\r\n<ol>\r\n<li>The given integer is guaranteed to fit within the range of a 32-bit signed integer.</li>\r\n<li>You could assume no leading zero bit in the integer’s binary representation.</li>\r\n</ol>\r\n</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> 5\r\n<b>Output:</b> 2\r\n<b>Explanation:</b> The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output 2.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 2:</b><br />\r\n<pre>\r\n<b>Input:</b> 1\r\n<b>Output:</b> 0\r\n<b>Explanation:</b> The binary representation of 1 is 1 (no leading zero bits), and its complement is 0. So you need to output 0.\r\n</pre>\r\n</p>",
  "translatedContent": "<p>给定一个正整数，输出它的补数。补数是对该数的二进制表示取反。</p>\n\n<p><strong>注意:</strong></p>\n\n<ol>\n\t<li>给定的整数保证在32位带符号整数的范围内。</li>\n\t<li>你可以假定二进制数不包含前导零位。</li>\n</ol>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> 5\n<strong>输出:</strong> 2\n<strong>解释:</strong> 5的二进制表示为101（没有前导零位），其补数为010。所以你需要输出2。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> 1\n<strong>输出:</strong> 0\n<strong>解释:</strong> 1的二进制表示为1（没有前导零位），其补数为0。所以你需要输出0。\n</pre>\n"
}
