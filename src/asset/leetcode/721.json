{
  "code": [
    "<pre class=\"hljs\"><code><span class=\"hljs-comment\">/**\n * @param {string[][]} accounts\n * @return {string[][]}\n */</span>\n<span class=\"hljs-keyword\">var</span> accountsMerge = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">accounts</span>) </span>{\n  <span class=\"hljs-keyword\">let</span> uf=<span class=\"hljs-built_in\">Array</span>(accounts.length).fill().map(<span class=\"hljs-function\">(<span class=\"hljs-params\">n,i</span>)=&gt;</span>i)\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">find</span>(<span class=\"hljs-params\">i</span>)</span>{\n    <span class=\"hljs-keyword\">if</span>(i!==uf[i]){\n      uf[i]=find(uf[i])\n    }\n    <span class=\"hljs-keyword\">return</span> uf[i]\n  }\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">union</span>(<span class=\"hljs-params\">a,b</span>)</span>{\n    <span class=\"hljs-keyword\">let</span> i=find(a),\n        j=find(b)\n    <span class=\"hljs-keyword\">if</span>(i===j)<span class=\"hljs-keyword\">return</span>\n    uf[i]=j\n  }\n\n  <span class=\"hljs-keyword\">let</span> email2Id={}\n  <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i=<span class=\"hljs-number\">0</span>;i&lt;accounts.length;i++){\n    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> j=<span class=\"hljs-number\">1</span>;j&lt;accounts[i].length;j++){\n      <span class=\"hljs-keyword\">let</span> email=accounts[i][j]\n      <span class=\"hljs-keyword\">if</span>(email2Id[email]!=<span class=\"hljs-literal\">null</span>){\n        union(i,email2Id[email])\n      }<span class=\"hljs-keyword\">else</span>{\n        email2Id[email]=i\n      }\n    }\n  }\n  <span class=\"hljs-keyword\">let</span> hash={}\n  <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i=<span class=\"hljs-number\">0</span>;i&lt;accounts.length;i++){\n    <span class=\"hljs-keyword\">let</span> rootId=find(i)\n    <span class=\"hljs-keyword\">if</span>(hash[rootId]==<span class=\"hljs-literal\">null</span>)hash[rootId]={}\n    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> j=<span class=\"hljs-number\">1</span>;j&lt;accounts[i].length;j++){\n      <span class=\"hljs-keyword\">let</span> email=accounts[i][j]\n      hash[rootId][email]=<span class=\"hljs-literal\">true</span>\n    }\n  }\n  <span class=\"hljs-keyword\">let</span> res=[]\n  <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> id <span class=\"hljs-keyword\">in</span> hash){\n    <span class=\"hljs-keyword\">let</span> name=accounts[id][<span class=\"hljs-number\">0</span>]\n    <span class=\"hljs-keyword\">let</span> sub=[]    \n    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> email <span class=\"hljs-keyword\">in</span> hash[id]){\n      sub.push(email)\n    }\n    sub.sort()\n    sub.unshift(name)\n    res.push(sub)\n  }\n  <span class=\"hljs-keyword\">return</span> res\n};\n</code></pre>\n"
  ],
  "titleSlug": "accounts-merge",
  "hasThinking": true,
  "thinking": "<hr>\n<p>思路：</p>\n<p>对<code>accounts</code>的索引构建<code>union find</code>，通过<code>hash</code>将相同的<code>email</code>的<code>id</code>在<code>uf</code>连接起来，最后对<code>uf</code>分析。</p>\n<p>例如：<code>['a','e1','e3'],['a','e2','e4']</code> 这时 两个<code>a</code>之间没有连接，<code>uf</code>是<code>[0,1]</code></p>\n<h2>如果还有一个<code>['a','e1','e4']</code>，因为<code>hash[e1]=0, hash[e4]=1</code>，因此需要连接<code>0</code>和<code>1</code>，<code>uf</code>是<code>[0,0,0]</code>。</h2>\n",
  "content": "<p>给定一个列表 <code>accounts</code>，每个元素 <code>accounts[i]</code>&nbsp;是一个字符串列表，其中第一个元素 <code>accounts[i][0]</code>&nbsp;是&nbsp;<em>名称 (name)</em>，其余元素是 <em>emails </em>表示该帐户的邮箱地址。</p>\n\n<p>现在，我们想合并这些帐户。如果两个帐户都有一些共同的邮件地址，则两个帐户必定属于同一个人。请注意，即使两个帐户具有相同的名称，它们也可能属于不同的人，因为人们可能具有相同的名称。一个人最初可以拥有任意数量的帐户，但其所有帐户都具有相同的名称。</p>\n\n<p>合并帐户后，按以下格式返回帐户：每个帐户的第一个元素是名称，其余元素是按顺序排列的邮箱地址。accounts 本身可以以任意顺序返回。</p>\n\n<p><strong>例子 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \naccounts = [[&quot;John&quot;, &quot;johnsmith@mail.com&quot;, &quot;john00@mail.com&quot;], [&quot;John&quot;, &quot;johnnybravo@mail.com&quot;], [&quot;John&quot;, &quot;johnsmith@mail.com&quot;, &quot;john_newyork@mail.com&quot;], [&quot;Mary&quot;, &quot;mary@mail.com&quot;]]\n<strong>Output:</strong> [[&quot;John&quot;, &#39;john00@mail.com&#39;, &#39;john_newyork@mail.com&#39;, &#39;johnsmith@mail.com&#39;],  [&quot;John&quot;, &quot;johnnybravo@mail.com&quot;], [&quot;Mary&quot;, &quot;mary@mail.com&quot;]]\n<strong>Explanation:</strong> \n  第一个和第三个 John 是同一个人，因为他们有共同的电子邮件 &quot;johnsmith@mail.com&quot;。 \n  第二个 John 和 Mary 是不同的人，因为他们的电子邮件地址没有被其他帐户使用。\n  我们可以以任何顺序返回这些列表，例如答案[[&#39;Mary&#39;，&#39;mary@mail.com&#39;]，[&#39;John&#39;，&#39;johnnybravo@mail.com&#39;]，\n  [&#39;John&#39;，&#39;john00@mail.com&#39;，&#39;john_newyork@mail.com&#39;，&#39;johnsmith@mail.com&#39;]]仍然会被接受。\n\n</pre>\n\n<p><strong>注意：</strong></p>\n\n<ul>\n\t<li><code>accounts</code>的长度将在<code>[1，1000]</code>的范围内。</li>\n\t<li><code>accounts[i]</code>的长度将在<code>[1，10]</code>的范围内。</li>\n\t<li><code>accounts[i][j]</code>的长度将在<code>[1，30]</code>的范围内。</li>\n</ul>\n"
}
