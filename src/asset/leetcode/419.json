{
  "code": [
    "/**\n * @param {character[][]} board\n * @return {number}\n */\nvar countBattleships = function(board) {\n        \n    // function check(arr){\n    //     // console.log(arr)\n    //     // let eachLine=arr.join('').split('.')\n    //     let eachLine=arr.join(\"\").match(/(X)\\1*/g) || []\n    //     let curSum=0\n    //     let curAdj=0;\n    //     eachLine.forEach(e=>{\n    //         if(e!==\"\"){curSum++}\n    //         if(e.length>1){curAdj+=e.length-1}\n    //     })\n    //     return {\n    //         curSum,\n    //         curAdj\n    //     }\n    // }\n   \n    // let hSum=0,vSum=0,hAdj=0,vAdj=0;\n    let count=0;\n    for(let i=0;i<board.length;i++){\n         // let ver=[];\n        for(let j=0;j<board[0].length;j++){\n            if(board[i][j]===\"X\"){\n                if(i>0 && board[i-1][j]===\"X\")continue;\n                if(j>0 && board[i][j-1]===\"X\")continue;\n                 count++;\n            }\n          \n            \n           \n            // ver.push(board[j][i])\n            // if(i===0){\n            //     let resH=check(board[j])\n            //     hSum+=resH.curSum\n            //     hAdj+=resH.curAdj\n            // }\n        }\n        // let resV=check(ver)\n        // vSum+=resV.curSum\n        // vAdj+=resV.curAdj\n    }\n\n    // return Math.min((hSum-vAdj),(vSum-hAdj))\n    return count;\n};"
  ],
  "titleSlug": "battleships-in-a-board",
  "content": "Given an 2D board, count how many battleships are in it. The battleships are represented with <code>'X'</code>s, empty slots are represented with <code>'.'</code>s. You may assume the following rules:\r\n\r\n<ul>\r\n<li>You receive a valid board, made of only battleships or empty slots.</li>\r\n<li>Battleships can only be placed horizontally or vertically. In other words, they can only be made of the shape <code>1xN</code> (1 row, N columns) or <code>Nx1</code> (N rows, 1 column), where N can be of any size.</li>\r\n<li>At least one horizontal or vertical cell separates between two battleships - there are no adjacent battleships.</li>\r\n</ul>\r\n\r\n<p><b>Example:</b><br />\r\n<pre>X..X\r\n...X\r\n...X\r\n</pre>\r\nIn the above board there are 2 battleships.\r\n\r\n<p><b>Invalid Example:</b><br />\r\n<pre>...X\r\nXXXX\r\n...X\r\n</pre>\r\nThis is an invalid board that you will not receive - as battleships will always have a cell separating between them.\r\n<p></p>\r\n<p><b>Follow up:</b><br>Could you do it in <b>one-pass</b>, using only <b>O(1) extra memory</b> and <b>without modifying</b> the value of the board?</p>",
  "translatedContent": "<p>给定一个二维的甲板， 请计算其中有多少艘战舰。&nbsp;战舰用&nbsp;<code>&#39;X&#39;</code>表示，空位用&nbsp;<code>&#39;.&#39;</code>表示。&nbsp;你需要遵守以下规则：</p>\n\n<ul>\n\t<li>给你一个有效的甲板，仅由战舰或者空位组成。</li>\n\t<li>战舰只能水平或者垂直放置。换句话说,战舰只能由&nbsp;<code>1xN</code> (1 行, N 列)组成，或者&nbsp;<code>Nx1</code> (N 行, 1 列)组成，其中N可以是任意大小。</li>\n\t<li>两艘战舰之间至少有一个水平或垂直的空位分隔&nbsp;- 即没有相邻的战舰。</li>\n</ul>\n\n<p><strong>示例 :</strong></p>\n\n<pre>\nX..X\n...X\n...X\n</pre>\n\n<p>在上面的甲板中有2艘战舰。</p>\n\n<p><strong>无效样例 :</strong></p>\n\n<pre>\n...X\nXXXX\n...X\n</pre>\n\n<p>你不会收到这样的无效甲板&nbsp;- 因为战舰之间至少会有一个空位将它们分开。</p>\n\n<p><strong>进阶:</strong></p>\n\n<p>你可以用<strong>一次扫描算法</strong>，只使用<strong>O(1)额外空间，</strong>并且<strong>不修改</strong>甲板的值来解决这个问题吗？</p>\n"
}
