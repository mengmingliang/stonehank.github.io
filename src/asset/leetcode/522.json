{
  "code": [
    "<pre class=\"hljs\"><code><span class=\"hljs-comment\">/**\n * @param {string[]} strs\n * @return {number}\n */</span>\n<span class=\"hljs-keyword\">var</span> findLUSlength = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">strs</span>) </span>{\n  strs.sort(<span class=\"hljs-function\">(<span class=\"hljs-params\">a,b</span>)=&gt;</span>b.length-a.length)\n  <span class=\"hljs-keyword\">let</span> filter=[]\n\n  <span class=\"hljs-comment\">// 从最长的字符串开始检查，如果发现存在相同的子序列，说明一定是完全一模一样的字符串</span>\n  <span class=\"hljs-comment\">// 直接将这条字符串添加到filter，过滤掉不再检查</span>\n  <span class=\"hljs-comment\">// 如果发现不存在相同子序列，直接返回答案</span>\n  <span class=\"hljs-comment\">// 当排序后，这道题就变成了，内部的完整字符串长度要么是结果，要么不是结果</span>\n\n  <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i=<span class=\"hljs-number\">0</span>;i&lt;strs.length;i++){\n    <span class=\"hljs-keyword\">if</span>(filter[i]) <span class=\"hljs-keyword\">continue</span>\n    <span class=\"hljs-keyword\">let</span> r=checkHasSub(strs[i],i)\n    <span class=\"hljs-keyword\">if</span>(r!==<span class=\"hljs-literal\">false</span>){\n      filter[i]=<span class=\"hljs-literal\">true</span>\n      filter[r]=<span class=\"hljs-literal\">true</span>\n      <span class=\"hljs-keyword\">continue</span>\n    }\n    <span class=\"hljs-keyword\">return</span> strs[i].length\n  }\n\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">checkHasSub</span>(<span class=\"hljs-params\">pattern,curIdx</span>)</span>{\n    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> k=<span class=\"hljs-number\">0</span>;k&lt;strs.length;k++){\n      <span class=\"hljs-keyword\">let</span> pre=<span class=\"hljs-number\">0</span>\n      <span class=\"hljs-keyword\">if</span>(k===curIdx)<span class=\"hljs-keyword\">continue</span>\n      <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i=<span class=\"hljs-number\">0</span>;i&lt;strs[k].length;i++){\n        <span class=\"hljs-keyword\">if</span>(strs[k][i]===pattern[pre])pre++\n      }\n      <span class=\"hljs-keyword\">if</span>(pre===pattern.length)<span class=\"hljs-keyword\">return</span> k\n    }\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>\n  }\n\n};\n</code></pre>\n"
  ],
  "titleSlug": "longest-uncommon-subsequence-ii",
  "content": "<p>给定字符串列表，你需要从它们中找出最长的特殊序列。最长特殊序列定义如下：该序列为某字符串独有的最长子序列（即不能是其他字符串的子序列）。</p>\n\n<p><strong>子序列</strong>可以通过删去字符串中的某些字符实现，但不能改变剩余字符的相对顺序。空序列为所有字符串的子序列，任何字符串为其自身的子序列。</p>\n\n<p>输入将是一个字符串列表，输出是最长特殊序列的长度。如果最长特殊序列不存在，返回 -1 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre><strong>输入:</strong> &quot;aba&quot;, &quot;cdc&quot;, &quot;eae&quot;\n<strong>输出:</strong> 3\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ol>\n\t<li>所有给定的字符串长度不会超过 10 。</li>\n\t<li>给定字符串列表的长度将在 [2, 50 ] 之间。</li>\n</ol>\n\n<p>&nbsp;</p>\n"
}
