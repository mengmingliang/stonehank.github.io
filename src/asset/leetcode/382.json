{
  "code": [
    "<pre class=\"hljs\"><code><span class=\"hljs-comment\">/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */</span>\n<span class=\"hljs-comment\">/**\n * @param head The linked list's head.\n        Note that the head is guaranteed to be not null, so it contains at least one node.\n * @param {ListNode} head\n */</span>\n<span class=\"hljs-keyword\">var</span> Solution = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">head</span>) </span>{\n  <span class=\"hljs-keyword\">this</span>.head=head\n};\n\n<span class=\"hljs-comment\">/**\n * Returns a random node's value.\n * @return {number}\n */</span>\nSolution.prototype.getRandom = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">let</span> r=<span class=\"hljs-keyword\">this</span>.head\n  <span class=\"hljs-keyword\">let</span> res=<span class=\"hljs-literal\">null</span>,count=<span class=\"hljs-number\">0</span>\n  <span class=\"hljs-keyword\">while</span>(r){\n    <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-built_in\">Math</span>.floor(<span class=\"hljs-built_in\">Math</span>.random()*(count+<span class=\"hljs-number\">1</span>))===count)res=r.val\n    r=r.next\n    count++\n  }\n  <span class=\"hljs-keyword\">return</span> res\n};\n\n<span class=\"hljs-comment\">/** \n * Your Solution object will be instantiated and called as such:\n * var obj = Object.create(Solution).createNew(head)\n * var param_1 = obj.getRandom()\n */</span>\n</code></pre>\n"
  ],
  "titleSlug": "linked-list-random-node",
  "hasThinking": true,
  "thinking": "<hr>\n<p>思路：</p>\n<p>空间<code>O(n)</code>算法很简单，维护一个数组保存链表上每一个值，每次获取随机值，只需要在数组上获取随机索引。</p>\n<p>空间<code>O(1)</code>算法使用了<code>蓄水池算法</code>，一种对数据流的随机抽样算法，原理如下：</p>\n<p>如果有一个数组<code>[1,2,3]</code>，需要随机抽取，我们则正向遍历，对于每一个数字，如果能够满足<code>Math.floor(Math.random()*(i+1))===i</code>，则将<code>res</code>设置为当前数字。</p>\n<p>也就是说，当<code>i</code>指向<code>0</code>时，<code>res</code>一定会被设置为<code>1</code>，这时<code>1</code>被获取的概率是<code>1</code>；</p>\n<p>当<code>i</code>指向<code>1</code>时，<code>res</code>被设置成<code>2</code>的概率为<code>1/2</code>，<strong>同时</strong>，<code>res</code>保持为<code>1</code>不变的概率为<code>1 * 1/2 = 1/2</code>；</p>\n<p>当<code>i</code>指向<code>2</code>时，<code>res</code>被设置成<code>3</code>的概率为<code>1/3</code>，<strong>同时</strong>，<code>res</code>保持为<code>1</code>的概率为<code>1 * 1/2 * 2/3 = 1/3</code>，<code>res</code>被保持为<code>2</code>的概率为<code>1/2 * 2/3 == 1/3</code>。</p>\n<h2>因此每一个数字都能获得相同的概率被获取。</h2>\n",
  "content": "<p>给定一个单链表，随机选择链表的一个节点，并返回相应的节点值。保证每个节点<strong>被选的概率一样</strong>。</p>\n\n<p><strong>进阶:</strong><br />\n如果链表十分大且长度未知，如何解决这个问题？你能否使用常数级空间复杂度实现？</p>\n\n<p><strong>示例:</strong></p>\n\n<pre>\n// 初始化一个单链表 [1,2,3].\nListNode head = new ListNode(1);\nhead.next = new ListNode(2);\nhead.next.next = new ListNode(3);\nSolution solution = new Solution(head);\n\n// getRandom()方法应随机返回1,2,3中的一个，保证每个元素被返回的概率相等。\nsolution.getRandom();\n</pre>\n"
}
