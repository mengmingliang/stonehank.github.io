{
  "code": [
    "<pre class=\"hljs\"><code><span class=\"hljs-comment\">/**\n * @param {number[]} heights\n * @return {number}\n */</span>\n<span class=\"hljs-keyword\">var</span> largestRectangleArea = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">heights</span>) </span>{\n  <span class=\"hljs-keyword\">let</span> stack=[<span class=\"hljs-number\">-1</span>],maxArea=<span class=\"hljs-number\">0</span>\n  <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i=<span class=\"hljs-number\">0</span>;i&lt;=heights.length;i++){\n    <span class=\"hljs-keyword\">while</span>(stack.length&gt;<span class=\"hljs-number\">1</span> &amp;&amp; (i===heights.length || heights[i]&lt;heights[stack[stack.length<span class=\"hljs-number\">-1</span>]])){\n      <span class=\"hljs-keyword\">let</span> lastId=stack.pop(),\n          lastH=heights[lastId],\n          width=i-stack[stack.length<span class=\"hljs-number\">-1</span>]<span class=\"hljs-number\">-1</span>\n      maxArea=<span class=\"hljs-built_in\">Math</span>.max(maxArea,width*lastH)\n    }\n    stack.push(i)\n  }\n  <span class=\"hljs-keyword\">return</span> maxArea\n};\n</code></pre>\n"
  ],
  "titleSlug": "largest-rectangle-in-histogram",
  "hasThinking": true,
  "thinking": "<hr>\n<p>思路：</p>\n<p>利用栈构建一个递增序列，如果存在一个递增序列，例如<code>[1,3,5]</code>，那么<code>3</code>这个高度对应的宽度就很好计算了。</p>\n<p>举个例子：<code>[2,4,5,3,1]</code></p>\n<p>假设现在<code>stack</code>为<code>[2,4,5]</code>，当前是遍历的值是<code>3</code>；</p>\n<p>现在不满足递增序列了，因此<code>pop</code>，删除<code>5</code>，那么就要计算删掉的<code>5</code>它对应的宽度<code>width</code>。</p>\n<p><code>5</code>的宽度就是在<code>4</code>和<code>3</code>之间的所有索引，也就是<code>idx(3)-idx(4)-1</code>，相当于<code>i-stack[stack.lenght-1]-1</code>；</p>\n<p>同理，接下来删除<code>4</code>，<code>4</code>的宽度就是<code>idx(3)-idx(1)-1</code>；</p>\n<p>栈变为<code>[2,3]</code>，遇到下一个值<code>1</code>，继续上面的步骤，当前不能满足递增序列，删<code>3</code>，删<code>2</code>；</p>\n<p>注意，这里删除<code>2</code>的时候，由于<code>2</code>已经是当前栈的最后一个值，因此<code>2</code>的宽度其实就是<code>idx(1)</code>，我将初始<code>stack</code>设置为<code>-1</code>，也是为了可以继续套用<code>i-stack[stack.lenght-1]-1</code>。</p>\n",
  "content": "<p>给定 <em>n</em> 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p>\n\n<p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p>\n\n<p>&nbsp;</p>\n\n<p><img src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/histogram.png\"></p>\n\n<p><small>以上是柱状图的示例，其中每个柱子的宽度为 1，给定的高度为&nbsp;<code>[2,1,5,6,2,3]</code>。</small></p>\n\n<p>&nbsp;</p>\n\n<p><img src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/histogram_area.png\"></p>\n\n<p><small>图中阴影部分为所能勾勒出的最大矩形面积，其面积为&nbsp;<code>10</code>&nbsp;个单位。</small></p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例:</strong></p>\n\n<pre><strong>输入:</strong> [2,1,5,6,2,3]\n<strong>输出:</strong> 10</pre>\n"
}
