{
  "code": [
    "<pre class=\"hljs\"><code><span class=\"hljs-comment\">/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number}\n */</span>\n<span class=\"hljs-keyword\">var</span> threeSumClosest = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">nums, target</span>) </span>{\n  nums.sort(<span class=\"hljs-function\">(<span class=\"hljs-params\">a,b</span>)=&gt;</span>a-b)\n  <span class=\"hljs-keyword\">let</span> result=<span class=\"hljs-literal\">null</span>\n  <span class=\"hljs-keyword\">let</span> min=<span class=\"hljs-literal\">Infinity</span>\n  <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> fix=<span class=\"hljs-number\">0</span>;fix&lt;nums.length<span class=\"hljs-number\">-2</span>;fix++){\n    <span class=\"hljs-keyword\">let</span> left=fix+<span class=\"hljs-number\">1</span>,right=nums.length<span class=\"hljs-number\">-1</span>\n    <span class=\"hljs-keyword\">let</span> sum\n    <span class=\"hljs-keyword\">while</span>(left&lt;right){\n      sum=nums[fix]+nums[left]+nums[right]\n      <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-built_in\">Math</span>.abs(sum-target)&lt;min){\n        min=<span class=\"hljs-built_in\">Math</span>.abs(sum-target)\n        <span class=\"hljs-keyword\">if</span>(min===<span class=\"hljs-number\">0</span>)<span class=\"hljs-keyword\">return</span> target\n        result=sum\n      }\n      <span class=\"hljs-keyword\">if</span>(sum&gt;target)right--\n      <span class=\"hljs-keyword\">else</span> left++\n    }\n  }\n  <span class=\"hljs-keyword\">return</span> result\n};\n</code></pre>\n"
  ],
  "titleSlug": "3sum-closest",
  "hasThinking": true,
  "thinking": "<hr>\n<p>思路：</p>\n<p>和<code>NO.15</code>基本一样的方式，相差在于：</p>\n<ol>\n<li>不需要去重。</li>\n<li>不需要完全相等，而是比较当前<code>sum</code>和<code>target</code>的绝对值的差。</li>\n</ol>\n",
  "content": "<p>给定一个包括&nbsp;<em>n</em> 个整数的数组&nbsp;<code>nums</code><em>&nbsp;</em>和 一个目标值&nbsp;<code>target</code>。找出&nbsp;<code>nums</code><em>&nbsp;</em>中的三个整数，使得它们的和与&nbsp;<code>target</code>&nbsp;最接近。返回这三个数的和。假定每组输入只存在唯一答案。</p>\n\n<pre>例如，给定数组 nums = [-1，2，1，-4], 和 target = 1.\n\n与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2).\n</pre>\n"
}
