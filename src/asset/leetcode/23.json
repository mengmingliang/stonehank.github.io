{
  "code": [
    "<pre class=\"hljs\"><code><span class=\"hljs-comment\">/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */</span>\n<span class=\"hljs-comment\">/**\n * @param {ListNode[]} lists\n * @return {ListNode}\n */</span>\n<span class=\"hljs-keyword\">var</span> mergeKLists = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">lists</span>) </span>{\n  <span class=\"hljs-keyword\">return</span> divid(lists,<span class=\"hljs-number\">0</span>,lists.length<span class=\"hljs-number\">-1</span>)\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">merge2Lists</span>(<span class=\"hljs-params\">list1,list2</span>)</span>{\n    <span class=\"hljs-keyword\">if</span>(list1==<span class=\"hljs-literal\">null</span>)<span class=\"hljs-keyword\">return</span> list2\n    <span class=\"hljs-keyword\">if</span>(list2==<span class=\"hljs-literal\">null</span>)<span class=\"hljs-keyword\">return</span> list1\n    <span class=\"hljs-keyword\">if</span>(list1.val&lt;list2.val){\n      list1.next=merge2Lists(list1.next,list2);\n      <span class=\"hljs-keyword\">return</span> list1;\n    }<span class=\"hljs-keyword\">else</span>{\n      list2.next=merge2Lists(list1,list2.next);\n      <span class=\"hljs-keyword\">return</span> list2;\n    }\n  }\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">divid</span>(<span class=\"hljs-params\">lists,left,right</span>)</span>{\n    <span class=\"hljs-keyword\">if</span>(left===right) <span class=\"hljs-keyword\">return</span> lists[left];\n    <span class=\"hljs-keyword\">if</span>(left&gt;right) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">null</span>\n    <span class=\"hljs-keyword\">let</span> mid=<span class=\"hljs-built_in\">Math</span>.floor((left+right)/<span class=\"hljs-number\">2</span>)\n    <span class=\"hljs-keyword\">let</span> list1=divid(lists,left,mid)\n    <span class=\"hljs-keyword\">let</span> list2=divid(lists,mid+<span class=\"hljs-number\">1</span>,right)\n    <span class=\"hljs-keyword\">return</span> merge2Lists(list1,list2)        \n  }    \n};\n</code></pre>\n"
  ],
  "titleSlug": "merge-k-sorted-lists",
  "hasThinking": true,
  "thinking": "<hr>\n<p>思路：</p>\n<p>好几种方法能解决，</p>\n<ol>\n<li>\n<p>直接排序，将每一个<code>node.val</code>添加到数组，然后排序后重新生成链表。</p>\n</li>\n<li>\n<p>优先队列，将每一个<code>node</code>加入<code>Priority Queue</code>，然后再从小到大导出即可。</p>\n</li>\n<li>\n<p>归并排序(见代码)。</p>\n</li>\n<li>\n<p>多指针(比较慢)，每一次都找出当前每一个<code>list[i]</code>中的最小值，找到的那个节点执行<code>list[i]=list[i].next</code>。</p>\n</li>\n</ol>\n",
  "content": "<p>合并&nbsp;<em>k&nbsp;</em>个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。</p>\n\n<p><strong>示例:</strong></p>\n\n<pre><strong>输入:</strong>\n[\n&nbsp; 1-&gt;4-&gt;5,\n&nbsp; 1-&gt;3-&gt;4,\n&nbsp; 2-&gt;6\n]\n<strong>输出:</strong> 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</pre>\n"
}
