{
  "code": [
    "<pre class=\"hljs\"><code><span class=\"hljs-comment\">/**\n * @param {number} n\n * @param {string[]} logs\n * @return {number[]}\n */</span>\n<span class=\"hljs-keyword\">var</span> exclusiveTime = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">n, logs</span>) </span>{\n  <span class=\"hljs-keyword\">let</span> first=logs[<span class=\"hljs-number\">0</span>].split(<span class=\"hljs-string\">\":\"</span>)\n  <span class=\"hljs-keyword\">let</span> cache=<span class=\"hljs-built_in\">Array</span>(n).fill(<span class=\"hljs-number\">0</span>),stack=[first[<span class=\"hljs-number\">0</span>]],lastTime=first[<span class=\"hljs-number\">2</span>],lastStatus=first[<span class=\"hljs-number\">1</span>]\n  <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i=<span class=\"hljs-number\">1</span>;i&lt;logs.length;i++){\n    <span class=\"hljs-keyword\">let</span> cur=logs[i].split(<span class=\"hljs-string\">\":\"</span>)\n    <span class=\"hljs-keyword\">let</span> id=cur[<span class=\"hljs-number\">0</span>],\n      status=cur[<span class=\"hljs-number\">1</span>],\n      time=cur[<span class=\"hljs-number\">2</span>]\n    <span class=\"hljs-comment\">// if(lastStatus){</span>\n      <span class=\"hljs-keyword\">let</span> lastId=stack[stack.length<span class=\"hljs-number\">-1</span>]\n      <span class=\"hljs-keyword\">if</span>(status===<span class=\"hljs-string\">\"start\"</span>){\n        cache[lastId]+=time-lastTime-(lastStatus===<span class=\"hljs-string\">\"start\"</span>?<span class=\"hljs-number\">0</span>:<span class=\"hljs-number\">1</span>)\n        stack.push(id)\n      }\n      <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(status===<span class=\"hljs-string\">\"end\"</span>){\n        cache[id]+=time-lastTime+(lastStatus===<span class=\"hljs-string\">\"start\"</span>?<span class=\"hljs-number\">1</span>:<span class=\"hljs-number\">0</span>)\n        stack.pop()\n      }\n    <span class=\"hljs-comment\">// }else stack.push(id)</span>\n    lastTime=time\n    lastStatus=status\n  }\n  <span class=\"hljs-keyword\">return</span> cache\n};\n</code></pre>\n"
  ],
  "titleSlug": "exclusive-time-of-functions",
  "translatedContent": "<p>给出一个非抢占单线程CPU的 <strong>n </strong>个函数运行日志，找到函数的独占时间。</p>\n\n<p>每个函数都有一个唯一的 Id，从 <strong>0</strong> 到<strong> n-1</strong>，函数可能会递归调用或者被其他函数调用。</p>\n\n<p>日志是具有以下格式的字符串：<code>function_id：start_or_end：timestamp</code>。例如：<code>&quot;0:start:0&quot;</code>&nbsp;表示函数 0 从 0 时刻开始运行。<code>&quot;0:end:0&quot;</code>&nbsp;表示函数 0 在 0 时刻结束。</p>\n\n<p>函数的独占时间定义是在该方法中花费的时间，调用其他函数花费的时间不算该函数的独占时间。你需要根据函数的 Id 有序地返回每个函数的独占时间。</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre><strong>输入:</strong>\nn = 2\nlogs = \n[&quot;0:start:0&quot;,\n &quot;1:start:2&quot;,\n &quot;1:end:5&quot;,\n &quot;0:end:6&quot;]\n<strong>输出:</strong>[3, 4]\n<strong>说明：</strong>\n函数 0 在时刻 0 开始，在执行了  2个时间单位结束于时刻 1。\n现在函数 0 调用函数 1，函数 1 在时刻 2 开始，执行 4 个时间单位后结束于时刻 5。\n函数 0 再次在时刻 6 开始执行，并在时刻 6 结束运行，从而执行了 1 个时间单位。\n所以函数 0 总共的执行了 2 +1 =3 个时间单位，函数 1 总共执行了 4 个时间单位。\n</pre>\n\n<p><strong>说明：</strong></p>\n\n<ol>\n\t<li>输入的日志会根据时间戳排序，而不是根据日志Id排序。</li>\n\t<li>你的输出会根据函数Id排序，也就意味着你的输出数组中序号为 0 的元素相当于函数 0 的执行时间。</li>\n\t<li>两个函数不会在同时开始或结束。</li>\n\t<li>函数允许被递归调用，直到运行结束。</li>\n\t<li>1 &lt;= n &lt;= 100</li>\n</ol>\n"
}
