{
  "code": [
    "function maxSumOfThreeSubarrays(nums,k){\n  let len=nums.length-k+1\n  let left=[],right=[],maxIndex=0,sums=[],sum=0\n  for(let i=0;i<nums.length;i++){\n    sum+=nums[i]\n    if(i>k-1)sum-=nums[i-k]\n    if(i>=k-1)sums[i-k+1]=sum  \n  }\n  for(let i=0;i<len;i++){\n    if(sums[i]>sums[maxIndex])maxIndex=i\n    left[i]=maxIndex\n  }\n  maxIndex=len-1\n  for(let i=len-1;i>=0;i--){\n   if(sums[i]>sums[maxIndex])maxIndex=i\n    right[i]=maxIndex\n  }\n  let res=[0,k,2*k]\n  for(let i=k;i<len;i++){\n    let l=left[i-k],m=i,r=right[i+k]\n    if(sums[l]+sums[m]+sums[r]>sums[res[0]]+sums[res[1]]+sums[res[2]]){\n      res[0]=l\n      res[1]=m\n      res[2]=r\n    }\n  }\n  return res\n}"
  ],
  "titleSlug": "maximum-sum-of-3-non-overlapping-subarrays",
  "content": "<p>\r\nIn a given array <code>nums</code> of positive integers, find three non-overlapping subarrays with maximum sum.\r\n</p>\r\n<p>\r\nEach subarray will be of size <code>k</code>, and we want to maximize the sum of all <code>3*k</code> entries.\r\n</p>\r\n<p>\r\nReturn the result as a list of indices representing the starting position of each interval (0-indexed).  If there are multiple answers, return the lexicographically smallest one.\r\n</p>\r\n<p><b>Example:</b><br />\r\n<pre>\r\n<b>Input:</b> [1,2,1,2,6,7,5,1], 2\r\n<b>Output:</b> [0, 3, 5]\r\n<b>Explanation:</b> Subarrays [1, 2], [2, 6], [7, 5] correspond to the starting indices [0, 3, 5].\r\nWe could have also taken [2, 1], but an answer of [1, 3, 5] would be lexicographically larger.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b><br />\r\n<li><code>nums.length</code> will be between 1 and 20000.</li>\r\n<li><code>nums[i]</code> will be between 1 and 65535.</li>\r\n<li><code>k</code> will be between 1 and floor(nums.length / 3).</li>\r\n</p>",
  "translatedContent": "<p>给定数组&nbsp;<code>nums</code>&nbsp;由正整数组成，找到三个互不重叠的子数组的最大和。</p>\n\n<p>每个子数组的长度为<code>k</code>，我们要使这<code>3*k</code>个项的和最大化。</p>\n\n<p>返回每个区间起始索引的列表（索引从 0 开始）。如果有多个结果，返回字典序最小的一个。</p>\n\n<p><strong>示例:</strong></p>\n\n<pre>\n<strong>输入:</strong> [1,2,1,2,6,7,5,1], 2\n<strong>输出:</strong> [0, 3, 5]\n<strong>解释:</strong> 子数组 [1, 2], [2, 6], [7, 5] 对应的起始索引为 [0, 3, 5]。\n我们也可以取 [2, 1], 但是结果 [1, 3, 5] 在字典序上更大。\n</pre>\n\n<p><strong>注意:</strong></p>\n\n<ul>\n\t<li><code>nums.length</code>的范围在<code>[1, 20000]</code>之间。</li>\n\t<li><code>nums[i]</code>的范围在<code>[1, 65535]</code>之间。</li>\n\t<li><code>k</code>的范围在<code>[1, floor(nums.length / 3)]</code>之间。</li>\n</ul>\n"
}
