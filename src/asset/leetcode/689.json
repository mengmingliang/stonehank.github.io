{
  "code": [
    "<pre class=\"hljs\"><code><span class=\"hljs-comment\">/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number[]}\n */</span>\n<span class=\"hljs-keyword\">var</span> maxSumOfThreeSubarrays = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">nums, k</span>) </span>{\n  <span class=\"hljs-keyword\">let</span> dp=[],result=[]\n  <span class=\"hljs-keyword\">let</span> row=<span class=\"hljs-number\">3</span>,col=nums.length\n  <span class=\"hljs-keyword\">let</span> sum=<span class=\"hljs-number\">0</span>\n  <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i=<span class=\"hljs-number\">0</span>;i&lt;row;i++){\n    dp[i]=[]\n    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> j=<span class=\"hljs-number\">0</span>;j&lt;col;j++){\n      dp[i][j]=<span class=\"hljs-number\">0</span>\n      \n      <span class=\"hljs-comment\">// 以下两段相同的意思</span>\n      <span class=\"hljs-comment\">// 88ms</span>\n      <span class=\"hljs-keyword\">if</span>(i===<span class=\"hljs-number\">0</span>){\n        sum+=nums[j]\n        <span class=\"hljs-keyword\">if</span>(j&gt;k<span class=\"hljs-number\">-1</span>)sum-=nums[j-k]\n        <span class=\"hljs-keyword\">if</span>(j&gt;=k<span class=\"hljs-number\">-1</span>)dp[i][j-k+<span class=\"hljs-number\">1</span>]=sum  \n      }\n      <span class=\"hljs-comment\">// 692ms</span>\n      <span class=\"hljs-comment\">// if(i===0 &amp;&amp; j&lt;col-k+1){</span>\n      <span class=\"hljs-comment\">//   for(let m=j;m&lt;j+k;m++){</span>\n      <span class=\"hljs-comment\">//     dp[i][j]+=nums[m]</span>\n      <span class=\"hljs-comment\">//   }</span>\n      <span class=\"hljs-comment\">// }</span>\n    }\n  }\n    \n  <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i=<span class=\"hljs-number\">1</span>;i&lt;<span class=\"hljs-number\">3</span>;i++){\n    <span class=\"hljs-keyword\">let</span> max=-<span class=\"hljs-literal\">Infinity</span>\n    <span class=\"hljs-keyword\">let</span> startId=dp[i].length-(k*i+<span class=\"hljs-number\">1</span>)<span class=\"hljs-number\">-1</span>\n    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> j=startId;j&gt;=<span class=\"hljs-number\">0</span>;j--){\n      max=<span class=\"hljs-built_in\">Math</span>.max(dp[i<span class=\"hljs-number\">-1</span>][j+k],max)\n      dp[i][j]=<span class=\"hljs-built_in\">Math</span>.max(dp[<span class=\"hljs-number\">0</span>][j]+max)\n    }\n  }\n  <span class=\"hljs-keyword\">let</span> retrace=row<span class=\"hljs-number\">-1</span>,start=<span class=\"hljs-number\">0</span>\n  <span class=\"hljs-keyword\">while</span>(retrace&gt;=<span class=\"hljs-number\">0</span>){\n    <span class=\"hljs-keyword\">let</span> max=-<span class=\"hljs-literal\">Infinity</span>,maxIdx=<span class=\"hljs-number\">0</span>\n    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i=start;i&lt;col;i++){\n      <span class=\"hljs-keyword\">if</span>(dp[retrace][i]&gt;max){\n        max=dp[retrace][i]\n        maxIdx=i\n      }\n    }\n    result.push(maxIdx)\n    start=maxIdx+k\n    retrace--\n  }\n\n  <span class=\"hljs-keyword\">return</span> result\n};\n</code></pre>\n"
  ],
  "titleSlug": "maximum-sum-of-3-non-overlapping-subarrays",
  "hasThinking": true,
  "thinking": "<hr>\n<p>思路：由于题目有<code>k</code>的限制，我们首先要将所有<code>k</code>项的子数组和计算出来。</p>\n<p>例如：<code>nums=[1,4,2,3,5,7,8],k=2</code></p>\n<p>计算的结果为<code>gapSums=[5,6,5,5,12,15]</code></p>\n<p>而且题目规定了由<code>3组子数组</code>组成的最大和，因此我们需要在上面计算结果中找出相差<code>k</code>项并且和为最大的3组。</p>\n<p><code>dp[i][j]</code>表示了到达<code>gapSums</code>中索引<code>j</code>的位置时，由<code>i</code>组(1&lt;=i&lt;=3)组成的最大和。</p>\n<p>递推公式为：</p>\n<p><code>dp[i][j]=Math.max(dp[i][j-1],dp[i-1][j-k]+gapSums[j])</code></p>\n<p>最后，再通过反查找出每一组中最大值的最前面的位置，从而获取最大和的索引。</p>\n",
  "content": "<p>给定数组&nbsp;<code>nums</code>&nbsp;由正整数组成，找到三个互不重叠的子数组的最大和。</p>\n\n<p>每个子数组的长度为<code>k</code>，我们要使这<code>3*k</code>个项的和最大化。</p>\n\n<p>返回每个区间起始索引的列表（索引从 0 开始）。如果有多个结果，返回字典序最小的一个。</p>\n\n<p><strong>示例:</strong></p>\n\n<pre>\n<strong>输入:</strong> [1,2,1,2,6,7,5,1], 2\n<strong>输出:</strong> [0, 3, 5]\n<strong>解释:</strong> 子数组 [1, 2], [2, 6], [7, 5] 对应的起始索引为 [0, 3, 5]。\n我们也可以取 [2, 1], 但是结果 [1, 3, 5] 在字典序上更大。\n</pre>\n\n<p><strong>注意:</strong></p>\n\n<ul>\n\t<li><code>nums.length</code>的范围在<code>[1, 20000]</code>之间。</li>\n\t<li><code>nums[i]</code>的范围在<code>[1, 65535]</code>之间。</li>\n\t<li><code>k</code>的范围在<code>[1, floor(nums.length / 3)]</code>之间。</li>\n</ul>\n"
}
