{
  "code": [
    "<pre class=\"hljs\"><code><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">DoubleLink</span>(<span class=\"hljs-params\">val,freq</span>)</span>{\n  <span class=\"hljs-keyword\">this</span>.val=val\n  <span class=\"hljs-keyword\">this</span>.next=<span class=\"hljs-literal\">null</span>\n  <span class=\"hljs-keyword\">this</span>.prev=<span class=\"hljs-literal\">null</span>\n  <span class=\"hljs-keyword\">this</span>.freqCount=freq\n}\nDoubleLink.prototype.append=<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">node</span>)</span>{\n  <span class=\"hljs-keyword\">let</span> nxt=<span class=\"hljs-keyword\">this</span>.next\n  <span class=\"hljs-keyword\">this</span>.next=node\n  node.prev=<span class=\"hljs-keyword\">this</span>\n  node.next=nxt\n  nxt.prev=node\n}\nDoubleLink.prototype.remove=<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>{\n  <span class=\"hljs-keyword\">let</span> nxt=<span class=\"hljs-keyword\">this</span>.next,\n      pre=<span class=\"hljs-keyword\">this</span>.prev\n  pre.next=nxt\n  nxt.prev=pre\n  <span class=\"hljs-keyword\">this</span>.next=<span class=\"hljs-literal\">null</span>\n  <span class=\"hljs-keyword\">this</span>.prev=<span class=\"hljs-literal\">null</span>\n}\n\n<span class=\"hljs-comment\">// 双向链表内部为Map，双向链表删除添加都是O(1)，内部的Map查找添加删除是O(1)</span>\n<span class=\"hljs-comment\">// 双向链表管理了key对应的freq的位置，内部的Map管理了key对应的value</span>\n\n\n<span class=\"hljs-comment\">/**\n * @param {number} capacity\n */</span>\n<span class=\"hljs-keyword\">var</span> LFUCache = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">capacity</span>) </span>{\n  <span class=\"hljs-keyword\">this</span>.key2Node=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Map</span>()\n  <span class=\"hljs-keyword\">this</span>.head=<span class=\"hljs-keyword\">new</span> DoubleLink(<span class=\"hljs-literal\">null</span>,<span class=\"hljs-number\">0</span>)\n  <span class=\"hljs-keyword\">this</span>.tail=<span class=\"hljs-keyword\">new</span> DoubleLink(<span class=\"hljs-literal\">null</span>,<span class=\"hljs-number\">0</span>)\n  <span class=\"hljs-keyword\">this</span>.head.next=<span class=\"hljs-keyword\">this</span>.tail\n  <span class=\"hljs-keyword\">this</span>.tail.prev=<span class=\"hljs-keyword\">this</span>.head\n  <span class=\"hljs-keyword\">this</span>.limitSize=capacity\n  <span class=\"hljs-keyword\">this</span>.curSize=<span class=\"hljs-number\">0</span>\n};\n\n<span class=\"hljs-comment\">/** \n * @param {number} key\n * @return {number}\n */</span>\nLFUCache.prototype.get = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">key</span>) </span>{\n  <span class=\"hljs-keyword\">if</span>(!<span class=\"hljs-keyword\">this</span>.key2Node.has(key)) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>\n  <span class=\"hljs-keyword\">let</span> curNode=<span class=\"hljs-keyword\">this</span>.key2Node.get(key)\n  <span class=\"hljs-keyword\">let</span> curMap=curNode.val\n  <span class=\"hljs-keyword\">let</span> value=curMap.get(key)\n  <span class=\"hljs-keyword\">if</span>(curNode.next.freqCount===curNode.freqCount+<span class=\"hljs-number\">1</span>){\n    <span class=\"hljs-keyword\">let</span> nxtMap=curNode.next.val\n    <span class=\"hljs-keyword\">let</span> nxtFreqKey=nxtMap.keys().next().value\n      nxtMap.set(key,value)\n      curMap.delete(key)\n      <span class=\"hljs-keyword\">this</span>.key2Node.set(key,curNode.next)\n  }<span class=\"hljs-keyword\">else</span>{\n    <span class=\"hljs-keyword\">let</span> newNode=<span class=\"hljs-keyword\">new</span> DoubleLink(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Map</span>(),curNode.freqCount+<span class=\"hljs-number\">1</span>)\n    curNode.append(newNode)\n    newNode.val.set(key,value)\n    curMap.delete(key)\n    <span class=\"hljs-keyword\">this</span>.key2Node.set(key,newNode)\n  }\n  <span class=\"hljs-keyword\">if</span>(curMap.size===<span class=\"hljs-number\">0</span>)curNode.remove()\n  <span class=\"hljs-keyword\">return</span> value\n};\n\n<span class=\"hljs-comment\">/** \n * @param {number} key \n * @param {number} value\n * @return {void}\n */</span>\nLFUCache.prototype.put = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">key, value</span>) </span>{\n  <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-keyword\">this</span>.key2Node.has(key)){\n    <span class=\"hljs-keyword\">this</span>.get(key)\n    <span class=\"hljs-keyword\">let</span> curMap=<span class=\"hljs-keyword\">this</span>.key2Node.get(key).val\n    curMap.delete(key)\n    curMap.set(key,value)\n    <span class=\"hljs-keyword\">return</span>\n  }\n  \n  <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-keyword\">this</span>.curSize===<span class=\"hljs-keyword\">this</span>.limitSize){\n    <span class=\"hljs-keyword\">let</span> delMapSet=<span class=\"hljs-keyword\">this</span>.head.next.val\n    <span class=\"hljs-keyword\">if</span>(!delMapSet)<span class=\"hljs-keyword\">return</span>\n    <span class=\"hljs-keyword\">let</span> delKey=delMapSet.keys().next().value\n    delMapSet.delete(delKey)\n    <span class=\"hljs-keyword\">this</span>.key2Node.delete(delKey)\n    <span class=\"hljs-keyword\">this</span>.curSize--\n    <span class=\"hljs-keyword\">if</span>(delMapSet.size===<span class=\"hljs-number\">0</span>){\n      <span class=\"hljs-keyword\">this</span>.head.next.remove()\n    }\n  }\n  <span class=\"hljs-keyword\">let</span> insertNode=<span class=\"hljs-literal\">null</span>\n  <span class=\"hljs-keyword\">let</span> headNode=<span class=\"hljs-keyword\">this</span>.head.next\n  <span class=\"hljs-keyword\">let</span> headMap=headNode.val\n  <span class=\"hljs-keyword\">if</span>(headNode.freqCount===<span class=\"hljs-number\">1</span>){\n    <span class=\"hljs-keyword\">let</span> headMap=headNode.val\n    headMap.set(key,value)\n    insertNode=headNode      \n  }<span class=\"hljs-keyword\">else</span>{\n    <span class=\"hljs-keyword\">let</span> newNode= <span class=\"hljs-keyword\">new</span> DoubleLink(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Map</span>(),<span class=\"hljs-number\">1</span>)\n    <span class=\"hljs-keyword\">this</span>.head.append(newNode)\n    newNode.val.set(key,value)\n    insertNode=newNode\n  }\n\n  <span class=\"hljs-keyword\">this</span>.curSize++\n  <span class=\"hljs-keyword\">this</span>.key2Node.set(key,insertNode)\n\n};\n\n<span class=\"hljs-comment\">/** \n * Your LFUCache object will be instantiated and called as such:\n * var obj = Object.create(LFUCache).createNew(capacity)\n * var param_1 = obj.get(key)\n * obj.put(key,value)\n */</span>\n</code></pre>\n"
  ],
  "titleSlug": "lfu-cache",
  "hasThinking": true,
  "thinking": "<hr>\n<p>思路：</p>\n<p>与<code>NO.432</code>比较像。</p>\n<p>要求使用<code>O(1)</code>，需要对当前频率的集合<code>增加</code>，<code>删除</code>，同时对集合内部的结构<code>查找</code>，<code>增加</code>，<code>删除</code>，这些操作都要是<code>O(1)</code>。</p>\n<p>其中频率的集合，可以使用<code>双向链表</code>，而双向链表内部，可以使用<code>Map</code>。</p>\n<p>数据结构如下：</p>\n<pre class=\"hljs\"><code>key2Node: { 'a':DoubleLink,'b':DoubleLink,... }\nDoubleLink&lt;Head&gt; &lt;===&gt; DoubleLink&lt;freq:1,val:Map&gt; &lt;===&gt; ... &lt;===&gt; DoubleLink&lt;count:5,val:Map&gt; &lt;===&gt; DoubleLink&lt;Tail&gt;\n</code></pre>\n<h2>此处的<code>DoubleLink</code>的<code>Head</code>和<code>Tail</code>是虚拟的一个头部和尾部，定义<code>双向链表</code>的<code>删除</code>和<code>增加</code>方法是不需要额外处理边界问题。</h2>\n",
  "content": "<p>设计并实现<a href=\"https://baike.baidu.com/item/%E7%BC%93%E5%AD%98%E7%AE%97%E6%B3%95\">最不经常使用（LFU）</a>缓存的数据结构。它应该支持以下操作：<code>get</code>&nbsp;和&nbsp;<code>put</code>。</p>\n\n<p><code>get(key)</code>&nbsp;- 如果键存在于缓存中，则获取键的值（总是正数），否则返回 -1。<br />\n<code>put(key, value)</code>&nbsp;- 如果键不存在，请设置或插入值。当缓存达到其容量时，它应该在插入新项目之前，使最不经常使用的项目无效。在此问题中，当存在平局（即两个或更多个键具有相同使用频率）时，<strong>最近</strong>最少使用的键将被去除。</p>\n\n<p><strong>进阶：</strong><br />\n你是否可以在&nbsp;<strong>O(1)&nbsp;</strong>时间复杂度内执行两项操作？</p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\nLFUCache cache = new LFUCache( 2 /* capacity (缓存容量) */ );\n\ncache.put(1, 1);\ncache.put(2, 2);\ncache.get(1);       // 返回 1\ncache.put(3, 3);    // 去除 key 2\ncache.get(2);       // 返回 -1 (未找到key 2)\ncache.get(3);       // 返回 3\ncache.put(4, 4);    // 去除 key 1\ncache.get(1);       // 返回 -1 (未找到 key 1)\ncache.get(3);       // 返回 3\ncache.get(4);       // 返回 4</pre>\n"
}
