{
  "code": [
    "<pre class=\"hljs\"><code><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">DoubleLink</span>(<span class=\"hljs-params\">val,freq</span>)</span>{\n  <span class=\"hljs-keyword\">this</span>.val=val\n  <span class=\"hljs-keyword\">this</span>.next=<span class=\"hljs-literal\">null</span>\n  <span class=\"hljs-keyword\">this</span>.prev=<span class=\"hljs-literal\">null</span>\n  <span class=\"hljs-keyword\">this</span>.freqCount=freq\n}\nDoubleLink.prototype.append=<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">node</span>)</span>{\n  <span class=\"hljs-keyword\">let</span> nxt=<span class=\"hljs-keyword\">this</span>.next\n  <span class=\"hljs-keyword\">this</span>.next=node\n  node.prev=<span class=\"hljs-keyword\">this</span>\n  node.next=nxt\n  nxt.prev=node\n}\nDoubleLink.prototype.remove=<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>{\n  <span class=\"hljs-keyword\">let</span> nxt=<span class=\"hljs-keyword\">this</span>.next,\n      pre=<span class=\"hljs-keyword\">this</span>.prev\n  pre.next=nxt\n  nxt.prev=pre\n  <span class=\"hljs-keyword\">this</span>.next=<span class=\"hljs-literal\">null</span>\n  <span class=\"hljs-keyword\">this</span>.prev=<span class=\"hljs-literal\">null</span>\n}\n\n<span class=\"hljs-comment\">// 双向链表内部为Map，双向链表删除添加都是O(1)，内部的Map查找添加删除是O(1)</span>\n<span class=\"hljs-comment\">// 双向链表管理了key对应的freq的位置，内部的Map管理了key对应的value</span>\n\n\n<span class=\"hljs-comment\">/**\n * @param {number} capacity\n */</span>\n<span class=\"hljs-keyword\">var</span> LFUCache = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">capacity</span>) </span>{\n  <span class=\"hljs-keyword\">this</span>.freNodeOfKey=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Map</span>()\n  <span class=\"hljs-keyword\">this</span>.freCounOfKey=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Map</span>()\n  <span class=\"hljs-keyword\">this</span>.head=<span class=\"hljs-keyword\">new</span> DoubleLink(<span class=\"hljs-literal\">null</span>,<span class=\"hljs-number\">0</span>)\n  <span class=\"hljs-keyword\">this</span>.tail=<span class=\"hljs-keyword\">new</span> DoubleLink(<span class=\"hljs-literal\">null</span>,<span class=\"hljs-number\">0</span>)\n  <span class=\"hljs-keyword\">this</span>.head.next=<span class=\"hljs-keyword\">this</span>.tail\n  <span class=\"hljs-keyword\">this</span>.tail.prev=<span class=\"hljs-keyword\">this</span>.head\n  <span class=\"hljs-keyword\">this</span>.limitSize=capacity\n  <span class=\"hljs-keyword\">this</span>.curSize=<span class=\"hljs-number\">0</span>\n};\n\n<span class=\"hljs-comment\">/** \n * @param {number} key\n * @return {number}\n */</span>\nLFUCache.prototype.get = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">key</span>) </span>{\n  <span class=\"hljs-keyword\">if</span>(!<span class=\"hljs-keyword\">this</span>.freNodeOfKey.has(key)) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>\n  \n  <span class=\"hljs-keyword\">let</span> curList=<span class=\"hljs-keyword\">this</span>.freNodeOfKey.get(key)\n  <span class=\"hljs-keyword\">let</span> curFreqCount=<span class=\"hljs-keyword\">this</span>.freCounOfKey.get(key)\n  <span class=\"hljs-keyword\">let</span> curMap=curList.val\n  <span class=\"hljs-keyword\">let</span> value=curMap.get(key)\n  <span class=\"hljs-keyword\">if</span>(curList.next.freqCount===curFreqCount+<span class=\"hljs-number\">1</span>){\n    <span class=\"hljs-keyword\">let</span> nxtMap=curList.next.val\n    <span class=\"hljs-keyword\">let</span> nxtFreqKey=nxtMap.keys().next().value\n    <span class=\"hljs-keyword\">let</span> nxtFreqCount=<span class=\"hljs-keyword\">this</span>.freCounOfKey.get(nxtFreqKey)\n      nxtMap.set(key,value)\n      curMap.delete(key)\n      <span class=\"hljs-keyword\">this</span>.freNodeOfKey.set(key,curList.next)\n  }<span class=\"hljs-keyword\">else</span>{\n    <span class=\"hljs-keyword\">let</span> newList=<span class=\"hljs-keyword\">new</span> DoubleLink(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Map</span>(),curFreqCount+<span class=\"hljs-number\">1</span>)\n    curList.append(newList)\n    newList.val.set(key,value)\n    curMap.delete(key)\n    <span class=\"hljs-keyword\">this</span>.freNodeOfKey.set(key,newList)\n  }\n  \n  <span class=\"hljs-keyword\">this</span>.freCounOfKey.set(key,curFreqCount+<span class=\"hljs-number\">1</span>)  \n  <span class=\"hljs-keyword\">if</span>(curMap.size===<span class=\"hljs-number\">0</span>)curList.remove()\n  <span class=\"hljs-keyword\">return</span> value\n};\n\n<span class=\"hljs-comment\">/** \n * @param {number} key \n * @param {number} value\n * @return {void}\n */</span>\nLFUCache.prototype.put = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">key, value</span>) </span>{\n  <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-keyword\">this</span>.freNodeOfKey.has(key)){\n    <span class=\"hljs-keyword\">this</span>.get(key)\n    <span class=\"hljs-keyword\">let</span> curMap=<span class=\"hljs-keyword\">this</span>.freNodeOfKey.get(key).val\n    curMap.delete(key)\n    curMap.set(key,value)\n    <span class=\"hljs-keyword\">return</span>\n  }\n  \n  <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-keyword\">this</span>.curSize===<span class=\"hljs-keyword\">this</span>.limitSize){\n    <span class=\"hljs-keyword\">let</span> delMapSet=<span class=\"hljs-keyword\">this</span>.head.next.val\n    <span class=\"hljs-keyword\">if</span>(!delMapSet)<span class=\"hljs-keyword\">return</span>\n    <span class=\"hljs-keyword\">let</span> delKey=delMapSet.keys().next().value\n    delMapSet.delete(delKey)\n    <span class=\"hljs-keyword\">this</span>.freNodeOfKey.delete(delKey)\n    <span class=\"hljs-keyword\">this</span>.freCounOfKey.delete(delKey)\n    <span class=\"hljs-keyword\">this</span>.curSize--\n    <span class=\"hljs-keyword\">if</span>(delMapSet.size===<span class=\"hljs-number\">0</span>){\n      <span class=\"hljs-keyword\">this</span>.head.next.remove()\n    }\n  }\n  <span class=\"hljs-keyword\">this</span>.freCounOfKey.set(key,<span class=\"hljs-number\">1</span>)\n  <span class=\"hljs-keyword\">let</span> insertNode=<span class=\"hljs-literal\">null</span>\n  <span class=\"hljs-keyword\">let</span> headList=<span class=\"hljs-keyword\">this</span>.head.next\n  <span class=\"hljs-keyword\">let</span> headMap=headList.val\n  <span class=\"hljs-keyword\">if</span>(headList.freqCount===<span class=\"hljs-number\">1</span>){\n    <span class=\"hljs-keyword\">let</span> headMap=headList.val\n    headMap.set(key,value)\n    insertNode=headList      \n  }<span class=\"hljs-keyword\">else</span>{\n    <span class=\"hljs-keyword\">let</span> newList= <span class=\"hljs-keyword\">new</span> DoubleLink(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Map</span>(),<span class=\"hljs-number\">1</span>)\n    <span class=\"hljs-keyword\">this</span>.head.append(newList)\n    newList.val.set(key,value)\n    insertNode=newList\n  }\n\n  <span class=\"hljs-keyword\">this</span>.curSize++\n  <span class=\"hljs-keyword\">this</span>.freNodeOfKey.set(key,insertNode)\n\n};\n\n<span class=\"hljs-comment\">/** \n * Your LFUCache object will be instantiated and called as such:\n * var obj = Object.create(LFUCache).createNew(capacity)\n * var param_1 = obj.get(key)\n * obj.put(key,value)\n */</span>\n</code></pre>\n"
  ],
  "titleSlug": "lfu-cache",
  "content": "<p>设计并实现<a href=\"https://baike.baidu.com/item/%E7%BC%93%E5%AD%98%E7%AE%97%E6%B3%95\">最不经常使用（LFU）</a>缓存的数据结构。它应该支持以下操作：<code>get</code>&nbsp;和&nbsp;<code>put</code>。</p>\n\n<p><code>get(key)</code>&nbsp;- 如果键存在于缓存中，则获取键的值（总是正数），否则返回 -1。<br />\n<code>put(key, value)</code>&nbsp;- 如果键不存在，请设置或插入值。当缓存达到其容量时，它应该在插入新项目之前，使最不经常使用的项目无效。在此问题中，当存在平局（即两个或更多个键具有相同使用频率）时，<strong>最近</strong>最少使用的键将被去除。</p>\n\n<p><strong>进阶：</strong><br />\n你是否可以在&nbsp;<strong>O(1)&nbsp;</strong>时间复杂度内执行两项操作？</p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\nLFUCache cache = new LFUCache( 2 /* capacity (缓存容量) */ );\n\ncache.put(1, 1);\ncache.put(2, 2);\ncache.get(1);       // 返回 1\ncache.put(3, 3);    // 去除 key 2\ncache.get(2);       // 返回 -1 (未找到key 2)\ncache.get(3);       // 返回 3\ncache.put(4, 4);    // 去除 key 1\ncache.get(1);       // 返回 -1 (未找到 key 1)\ncache.get(3);       // 返回 3\ncache.get(4);       // 返回 4</pre>\n"
}
