{
  "code": [
    "<pre class=\"hljs\"><code><span class=\"hljs-comment\">/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */</span>\n<span class=\"hljs-comment\">/**\n * @param {TreeNode} root\n * @param {TreeNode} target\n * @param {number} K\n * @return {number[]}\n */</span>\n<span class=\"hljs-keyword\">var</span> distanceK = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">root, target, K</span>) </span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">check</span>(<span class=\"hljs-params\">obj,n</span>)</span>{\n        <span class=\"hljs-keyword\">if</span>(!obj[n])obj[n]=[]\n    }\n    <span class=\"hljs-keyword\">let</span> cache={};\n    <span class=\"hljs-keyword\">let</span> res=[]\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">DFS</span>(<span class=\"hljs-params\">node</span>)</span>{\n        check(cache,node.val)\n        <span class=\"hljs-keyword\">if</span>(node.left){\n            check(cache,node.left.val)\n            cache[node.val].push(node.left.val)\n            cache[node.left.val].push(node.val)\n            DFS(node.left)\n        }\n        <span class=\"hljs-keyword\">if</span>(node.right){\n            check(cache,node.right.val)\n            cache[node.val].push(node.right.val)\n            cache[node.right.val].push(node.val)\n            DFS(node.right)\n        }\n    }\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">delDou</span>(<span class=\"hljs-params\">arr</span>)</span>{\n        arr.d\n    }\n    DFS(root)\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">recur</span>(<span class=\"hljs-params\">arr,n,k</span>)</span>{\n        <span class=\"hljs-keyword\">if</span>(k===<span class=\"hljs-number\">0</span>)<span class=\"hljs-keyword\">return</span> [n]\n        <span class=\"hljs-keyword\">if</span>(k===<span class=\"hljs-number\">1</span>){<span class=\"hljs-keyword\">return</span> arr}\n        <span class=\"hljs-keyword\">let</span> res=[]\n        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i=<span class=\"hljs-number\">0</span>;i&lt;arr.length;i++){\n            <span class=\"hljs-keyword\">let</span> cur=cache[arr[i]];\n            <span class=\"hljs-keyword\">let</span> curRes=[]\n            <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> j=<span class=\"hljs-number\">0</span>;j&lt;cur.length;j++){\n                <span class=\"hljs-keyword\">if</span>(cur[j]!==n){\n                    curRes.push(cur[j])\n                }\n            }\n            res=res.concat(recur(curRes,arr[i],k<span class=\"hljs-number\">-1</span>))\n            <span class=\"hljs-comment\">// console.log(res)</span>\n        }\n        <span class=\"hljs-keyword\">return</span> res\n    }\n    res=recur(cache[target.val],target.val,K)\n    <span class=\"hljs-keyword\">return</span> res\n   \n};\n</code></pre>\n"
  ],
  "titleSlug": "all-nodes-distance-k-in-binary-tree",
  "content": "<p>给定一个二叉树（具有根结点&nbsp;<code>root</code>），&nbsp;一个目标结点&nbsp;<code>target</code>&nbsp;，和一个整数值 <code>K</code> 。</p>\n\n<p>返回到目标结点 <code>target</code> 距离为 <code>K</code> 的所有结点的值的列表。 答案可以以任何顺序返回。</p>\n\n<p>&nbsp;</p>\n\n<ol>\n</ol>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>root = [3,5,1,6,2,0,8,null,null,7,4], target = 5, K = 2\n\n<strong>输出：</strong>[7,4,1]\n\n<strong>解释：</strong>\n所求结点为与目标结点（值为 5）距离为 2 的结点，\n值分别为 7，4，以及 1\n\n<img alt=\"\" src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/06/28/sketch0.png\" style=\"height: 240px; width: 280px;\">\n\n注意，输入的 &quot;root&quot; 和 &quot;target&quot; 实际上是树上的结点。\n上面的输入仅仅是对这些对象进行了序列化描述。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ol>\n\t<li>给定的树是非空的，且最多有&nbsp;<code>K</code>&nbsp;个结点。</li>\n\t<li>树上的每个结点都具有唯一的值&nbsp;<code>0 &lt;= node.val &lt;= 500</code>&nbsp;。</li>\n\t<li>目标结点&nbsp;<code>target</code>&nbsp;是树上的结点。</li>\n\t<li><code>0 &lt;= K &lt;= 1000</code>.</li>\n</ol>\n"
}
