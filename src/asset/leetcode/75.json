{
  "code": [
    "<pre class=\"hljs\"><code><span class=\"hljs-comment\">/**\n * @param {number[]} nums\n * @return {void} Do not return anything, modify nums in-place instead.\n */</span>\n<span class=\"hljs-keyword\">var</span> sortColors = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">nums</span>) </span>{\n    <span class=\"hljs-keyword\">let</span> l=<span class=\"hljs-number\">0</span>,r=nums.length<span class=\"hljs-number\">-1</span>\n    <span class=\"hljs-keyword\">let</span> pivot=<span class=\"hljs-number\">1</span>\n    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i=<span class=\"hljs-number\">0</span>;i&lt;=r;i++){\n      <span class=\"hljs-keyword\">if</span>(nums[i]&lt;pivot) swap(nums,i,l++)\n      <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(nums[i]&gt;pivot) swap(nums,i--,r--)\n    }\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">swap</span>(<span class=\"hljs-params\">arr,i,j</span>)</span>{\n      <span class=\"hljs-keyword\">let</span> t=arr[i]\n      arr[i]=arr[j]\n      arr[j]=t\n    }\n    <span class=\"hljs-keyword\">return</span> nums\n};\n</code></pre>\n"
  ],
  "titleSlug": "sort-colors",
  "content": "<p>给定一个包含红色、白色和蓝色，一共&nbsp;<em>n </em>个元素的数组，<strong><a href=\"https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95\" target=\"_blank\">原地</a></strong>对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p>\n\n<p>此题中，我们使用整数 0、&nbsp;1 和 2 分别表示红色、白色和蓝色。</p>\n\n<p><strong>注意:</strong><br>\n不能使用代码库中的排序函数来解决这道题。</p>\n\n<p><strong>示例:</strong></p>\n\n<pre><strong>输入:</strong> [2,0,2,1,1,0]\n<strong>输出:</strong> [0,0,1,1,2,2]</pre>\n\n<p><strong>进阶：</strong></p>\n\n<ul>\n\t<li>一个直观的解决方案是使用计数排序的两趟扫描算法。<br>\n\t首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。</li>\n\t<li>你能想出一个仅使用常数空间的一趟扫描算法吗？</li>\n</ul>\n"
}
