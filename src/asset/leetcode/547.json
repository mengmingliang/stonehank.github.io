{
  "code": [
    "<pre class=\"hljs\"><code><span class=\"hljs-comment\">/**\n * @param {number[][]} M\n * @return {number}\n */</span>\n<span class=\"hljs-keyword\">var</span> findCircleNum = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">M</span>) </span>{\n  <span class=\"hljs-keyword\">let</span> N=M.length\n  <span class=\"hljs-keyword\">let</span> uf=<span class=\"hljs-built_in\">Array</span>(N).fill().map(<span class=\"hljs-function\">(<span class=\"hljs-params\">n,i</span>)=&gt;</span>i)\n  <span class=\"hljs-keyword\">let</span> count=N\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">find</span>(<span class=\"hljs-params\">i</span>)</span>{\n    <span class=\"hljs-keyword\">if</span>(i!==uf[i]){\n      uf[i]=find(uf[i])\n    }\n    <span class=\"hljs-keyword\">return</span> uf[i]\n  }\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">union</span>(<span class=\"hljs-params\">a,b</span>)</span>{\n    <span class=\"hljs-keyword\">let</span> i=find(a),\n        j=find(b)\n    <span class=\"hljs-keyword\">if</span>(i===j)<span class=\"hljs-keyword\">return</span> \n    count--\n    uf[i]=j\n  }\n  <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i=<span class=\"hljs-number\">0</span>;i&lt;N;i++){\n    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> j=<span class=\"hljs-number\">0</span>;j&lt;N;j++){\n      <span class=\"hljs-keyword\">if</span>(i===j)<span class=\"hljs-keyword\">continue</span>\n      <span class=\"hljs-keyword\">if</span>(M[i][j]===<span class=\"hljs-number\">0</span>)<span class=\"hljs-keyword\">continue</span>\n      union(i,j)\n    }\n  }\n  \n  <span class=\"hljs-keyword\">return</span> count\n};\n</code></pre>\n"
  ],
  "titleSlug": "friend-circles",
  "hasThinking": true,
  "thinking": "<hr>\n<p>思路：</p>\n<p>一道典型的<code>union find</code>算法题。</p>\n<p>假设最初朋友圈<code>count</code>有<code>N</code>个，当<code>M[i][j]===1</code>的时候，<code>union(i,j)</code>，如果发现之前未曾连接，说明两个朋友圈变为1个，<code>count--</code>。</p>\n<p>最后返回<code>count</code>。</p>\n",
  "content": "<p>班上有&nbsp;<strong>N&nbsp;</strong>名学生。其中有些人是朋友，有些则不是。他们的友谊具有是传递性。如果已知 A 是 B&nbsp;的朋友，B 是 C&nbsp;的朋友，那么我们可以认为 A 也是 C&nbsp;的朋友。所谓的朋友圈，是指所有朋友的集合。</p>\n\n<p>给定一个&nbsp;<strong>N * N&nbsp;</strong>的矩阵&nbsp;<strong>M</strong>，表示班级中学生之间的朋友关系。如果M[i][j] = 1，表示已知第 i 个和 j 个学生<strong>互为</strong>朋友关系，否则为不知道。你必须输出所有学生中的已知的朋友圈总数。</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> \n[[1,1,0],\n [1,1,0],\n [0,0,1]]\n<strong>输出:</strong> 2 \n<strong>说明：</strong>已知学生0和学生1互为朋友，他们在一个朋友圈。\n第2个学生自己在一个朋友圈。所以返回2。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> \n[[1,1,0],\n [1,1,1],\n [0,1,1]]\n<strong>输出:</strong> 1\n<strong>说明：</strong>已知学生0和学生1互为朋友，学生1和学生2互为朋友，所以学生0和学生2也是朋友，所以他们三个在一个朋友圈，返回1。\n</pre>\n\n<p><strong>注意：</strong></p>\n\n<ol>\n\t<li>N 在[1,200]的范围内。</li>\n\t<li>对于所有学生，有M[i][i] = 1。</li>\n\t<li>如果有M[i][j] = 1，则有M[j][i] = 1。</li>\n</ol>\n"
}
