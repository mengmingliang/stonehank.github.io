{
  "code": [
    "/**\n * @param {number[]} A\n */\nvar RLEIterator = function(A) {\n\n    this.c=[],this.seq=[]\n    for(let i=0;i<A.length-1;i=i+2){\n        let value=A[i+1],count=A[i]\n        if(count===0)continue\n        this.seq.push(value)\n        this.c.push(count)\n        // if(this.c[key]==undefined)this.c[key]=value\n        // else this.c[key]+=value\n    }\n    // console.log(this.c)\n};\n\n/** \n * @param {number} n\n * @return {number}\n */\nRLEIterator.prototype.next = function(n) {\n\n    while(this.seq.length>0){\n        let curValue=this.seq[0]\n        let curCount=this.c[0]\n        if(n<=curCount){\n            this.c[0]-=n\n            return curValue \n        }else{\n            n=n-curCount\n            this.seq.shift()\n            this.c.shift()\n        }\n    }\n    return -1\n    \n};\n\n/** \n * Your RLEIterator object will be instantiated and called as such:\n * var obj = Object.create(RLEIterator).createNew(A)\n * var param_1 = obj.next(n)\n */"
  ],
  "titleSlug": "rle-iterator",
  "content": "<p>Write an iterator that iterates through a run-length encoded sequence.</p>\r\n\r\n<p>The iterator is initialized by <code>RLEIterator(int[] A)</code>, where <code>A</code> is a run-length encoding of some&nbsp;sequence.&nbsp; More specifically,&nbsp;for all even <code>i</code>,&nbsp;<code>A[i]</code> tells us the number of times that the non-negative integer value <code>A[i+1]</code> is repeated in the sequence.</p>\r\n\r\n<p>The iterator supports one function:&nbsp;<code>next(int n)</code>, which exhausts the next <code>n</code> elements&nbsp;(<code>n &gt;= 1</code>) and returns the last element exhausted in this way.&nbsp; If there is no element left to exhaust, <code>next</code>&nbsp;returns <code>-1</code> instead.</p>\r\n\r\n<p>For example, we start with <code>A = [3,8,0,9,2,5]</code>, which is a run-length encoding of the sequence <code>[8,8,8,5,5]</code>.&nbsp; This is because the sequence can be read as&nbsp;&quot;three eights, zero nines, two fives&quot;.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-1-1\">[&quot;RLEIterator&quot;,&quot;next&quot;,&quot;next&quot;,&quot;next&quot;,&quot;next&quot;]</span>, <span id=\"example-input-1-2\">[[[3,8,0,9,2,5]],[2],[1],[1],[2]]</span>\r\n<strong>Output: </strong><span id=\"example-output-1\">[null,8,8,5,-1]</span>\r\n<strong>Explanation: </strong>\r\nRLEIterator is initialized with RLEIterator([3,8,0,9,2,5]).\r\nThis maps to the sequence [8,8,8,5,5].\r\nRLEIterator.next is then called 4 times:\r\n\r\n.next(2) exhausts 2 terms of the sequence, returning 8.  The remaining sequence is now [8, 5, 5].\r\n\r\n.next(1) exhausts 1 term of the sequence, returning 8.  The remaining sequence is now [5, 5].\r\n\r\n.next(1) exhausts 1 term of the sequence, returning 5.  The remaining sequence is now [5].\r\n\r\n.next(2) exhausts 2 terms, returning -1.  This is because the first term exhausted was 5,\r\nbut the second term did not exist.  Since the last term exhausted does not exist, we return -1.\r\n\r\n</pre>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ol>\r\n\t<li><code>0 &lt;= A.length &lt;= 1000</code></li>\r\n\t<li><code>A.length</code>&nbsp;is an even integer.</li>\r\n\t<li><code>0 &lt;= A[i] &lt;= 10^9</code></li>\r\n\t<li>There are at most <code>1000</code> calls to <code>RLEIterator.next(int n)</code> per test case.</li>\r\n\t<li>Each call to&nbsp;<code>RLEIterator.next(int n)</code>&nbsp;will have <code>1 &lt;= n &lt;= 10^9</code>.</li>\r\n</ol>\r\n",
  "translatedContent": "<p>编写一个遍历游程编码序列的迭代器。</p>\n\n<p>迭代器由 <code>RLEIterator(int[] A)</code> 初始化，其中&nbsp;<code>A</code>&nbsp;是某个序列的游程编码。更具体地，对于所有偶数 <code>i</code>，<code>A[i]</code> 告诉我们在序列中重复非负整数值 <code>A[i + 1]</code> 的次数。</p>\n\n<p>迭代器支持一个函数：<code>next(int n)</code>，它耗尽接下来的&nbsp; <code>n</code> 个元素（<code>n &gt;= 1</code>）并返回以这种方式耗去的最后一个元素。如果没有剩余的元素可供耗尽，则&nbsp; <code>next</code>&nbsp;返回&nbsp;<code>-1</code> 。</p>\n\n<p>例如，我们以&nbsp;<code>A = [3,8,0,9,2,5]</code>&nbsp;开始，这是序列&nbsp;<code>[8,8,8,5,5]</code>&nbsp;的游程编码。这是因为该序列可以读作 &ldquo;三个八，零个九，两个五&rdquo;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre><strong>输入：</strong>[&quot;RLEIterator&quot;,&quot;next&quot;,&quot;next&quot;,&quot;next&quot;,&quot;next&quot;], [[[3,8,0,9,2,5]],[2],[1],[1],[2]]\n<strong>输出：</strong>[null,8,8,5,-1]\n<strong>解释：</strong>\nRLEIterator 由 RLEIterator([3,8,0,9,2,5]) 初始化。\n这映射到序列 [8,8,8,5,5]。\n然后调用 RLEIterator.next 4次。\n\n.next(2) 耗去序列的 2 个项，返回 8。现在剩下的序列是 [8, 5, 5]。\n\n.next(1) 耗去序列的 1 个项，返回 8。现在剩下的序列是 [5, 5]。\n\n.next(1) 耗去序列的 1 个项，返回 5。现在剩下的序列是 [5]。\n\n.next(2) 耗去序列的 2 个项，返回 -1。 这是由于第一个被耗去的项是 5，\n但第二个项并不存在。由于最后一个要耗去的项不存在，我们返回 -1。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ol>\n\t<li><code>0 &lt;= A.length &lt;= 1000</code></li>\n\t<li><code>A.length</code>&nbsp;是偶数。</li>\n\t<li><code>0 &lt;= A[i] &lt;= 10^9</code></li>\n\t<li>每个测试用例最多调用&nbsp;<code>1000</code>&nbsp;次&nbsp;<code>RLEIterator.next(int n)</code>。</li>\n\t<li>每次调用&nbsp;<code>RLEIterator.next(int n)</code>&nbsp;都有&nbsp;<code>1 &lt;= n &lt;= 10^9</code>&nbsp;。</li>\n</ol>\n"
}
