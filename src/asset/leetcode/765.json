{
  "code": [
    "<pre class=\"hljs\"><code><span class=\"hljs-comment\">/**\n * @param {number[]} row\n * @return {number}\n */</span>\n<span class=\"hljs-keyword\">var</span> minSwapsCouples = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">row</span>) </span>{\n  <span class=\"hljs-comment\">// union Find</span>\n  <span class=\"hljs-comment\">// 思路：将需要swap的组union并且计数，下次再遇到这两组则不再计数</span>\n  <span class=\"hljs-keyword\">let</span> connect=<span class=\"hljs-built_in\">Array</span>.from({<span class=\"hljs-attr\">length</span>:row.length/<span class=\"hljs-number\">2</span>},(n,i)=&gt;i)\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">find</span>(<span class=\"hljs-params\">i</span>)</span>{\n    <span class=\"hljs-keyword\">while</span>(i!==connect[i])i=connect[i]\n    <span class=\"hljs-keyword\">return</span> i\n  }\n  <span class=\"hljs-keyword\">let</span> swap=<span class=\"hljs-number\">0</span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">union</span>(<span class=\"hljs-params\">a,b</span>)</span>{\n    <span class=\"hljs-keyword\">let</span> i=find(a),j=find(b)\n    <span class=\"hljs-keyword\">if</span>(i!==j){\n      swap++\n      connect[i]=j\n    }\n  }\n  <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i=<span class=\"hljs-number\">0</span>;i&lt;row.length;i=i+<span class=\"hljs-number\">2</span>){\n    <span class=\"hljs-keyword\">let</span> g1=<span class=\"hljs-built_in\">Math</span>.floor(row[i]/<span class=\"hljs-number\">2</span>),\n        g2=<span class=\"hljs-built_in\">Math</span>.floor(row[i+<span class=\"hljs-number\">1</span>]/<span class=\"hljs-number\">2</span>)\n    <span class=\"hljs-keyword\">if</span>(g1!==g2)union(g1,g2)\n  }\n  <span class=\"hljs-keyword\">return</span> swap\n};\n</code></pre>\n"
  ],
  "titleSlug": "couples-holding-hands",
  "hasThinking": true,
  "thinking": "<hr>\n<p>思路：</p>\n<p>2种思路，一种是<code>贪心+暴力解+记忆</code>，即每次对于索引<code>2i</code>，只去交换<code>2i+1</code>的数字，使得<code>2i+1</code>的数字能匹配<code>2i</code>。</p>\n<pre class=\"hljs\"><code><span class=\"hljs-comment\">/**\n * @param {number[]} row\n * @return {number}\n */</span>\n<span class=\"hljs-keyword\">var</span> minSwapsCouples = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">row</span>) </span>{\n  <span class=\"hljs-comment\">// 暴力+mem</span>\n  <span class=\"hljs-keyword\">let</span> memo={}\n  <span class=\"hljs-keyword\">return</span> dfs(row,<span class=\"hljs-number\">0</span>)\n  \n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">dfs</span>(<span class=\"hljs-params\">row,idx</span>)</span>{\n    <span class=\"hljs-keyword\">if</span>(idx===row.length)<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>\n    <span class=\"hljs-keyword\">if</span>(memo[idx]!=<span class=\"hljs-literal\">null</span>)<span class=\"hljs-keyword\">return</span> memo[idx]\n    <span class=\"hljs-keyword\">let</span> left=row[idx],left_p=<span class=\"hljs-literal\">null</span>\n    <span class=\"hljs-keyword\">if</span>(left/<span class=\"hljs-number\">2</span>===<span class=\"hljs-built_in\">Math</span>.floor(left/<span class=\"hljs-number\">2</span>)){\n      left_p=left+<span class=\"hljs-number\">1</span>\n    }<span class=\"hljs-keyword\">else</span>{\n      left_p=left<span class=\"hljs-number\">-1</span>\n    }\n    <span class=\"hljs-keyword\">let</span> swapTimes=<span class=\"hljs-literal\">Infinity</span>,\n        swap_idx=row.indexOf(left_p)\n    <span class=\"hljs-keyword\">if</span>(swap_idx===idx+<span class=\"hljs-number\">1</span>){\n      swapTimes=dfs(row,idx+<span class=\"hljs-number\">2</span>)\n    }<span class=\"hljs-keyword\">else</span>{\n      swap(row,swap_idx,idx+<span class=\"hljs-number\">1</span>)\n      swapTimes=<span class=\"hljs-number\">1</span>+dfs(row,idx+<span class=\"hljs-number\">2</span>)\n    }\n    memo[idx]=swapTimes\n    <span class=\"hljs-keyword\">return</span> swapTimes\n  }\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">swap</span>(<span class=\"hljs-params\">arr,i,j</span>)</span>{\n    <span class=\"hljs-keyword\">let</span> t=arr[i]\n    arr[i]=arr[j]\n    arr[j]=t\n  }\n};\n</code></pre>\n<h2>另一种方式是<code>union find</code>，对于<code>N</code>对情侣，最多只需要交换<code>N-1</code>次，因此遍历<code>rows</code>，对于当前<code>2i</code>和<code>2i+1</code>不匹配的，将它们<code>union</code>，\n并且交换次数<code>+1</code>，后续如果还能遇到这两组，由于之前已经<code>union</code>了，因此不会重复计算交换次数。</h2>\n",
  "content": "<p>N 对情侣坐在连续排列的 2N 个座位上，想要牵到对方的手。 计算最少交换座位的次数，以便每对情侣可以并肩坐在一起。 <em>一</em>次交换可选择任意两人，让他们站起来交换座位。</p>\n\n<p>人和座位用&nbsp;<code>0</code>&nbsp;到&nbsp;<code>2N-1</code>&nbsp;的整数表示，情侣们按顺序编号，第一对是&nbsp;<code>(0, 1)</code>，第二对是&nbsp;<code>(2, 3)</code>，以此类推，最后一对是&nbsp;<code>(2N-2, 2N-1)</code>。</p>\n\n<p>这些情侣的初始座位&nbsp;&nbsp;<code>row[i]</code>&nbsp;是由最初始坐在第 i 个座位上的人决定的。</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> row = [0, 2, 1, 3]\n<strong>输出:</strong> 1\n<strong>解释:</strong> 我们只需要交换row[1]和row[2]的位置即可。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> row = [3, 2, 0, 1]\n<strong>输出:</strong> 0\n<strong>解释:</strong> 无需交换座位，所有的情侣都已经可以手牵手了。\n</pre>\n\n<p><strong>说明:</strong></p>\n\n<ol>\n\t<li><code>len(row)</code> 是偶数且数值在&nbsp;<code>[4, 60]</code>范围内。</li>\n\t<li>可以保证<code>row</code> 是序列&nbsp;<code>0...len(row)-1</code>&nbsp;的一个全排列。</li>\n</ol>\n"
}
