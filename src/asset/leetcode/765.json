{
  "code": [
    "<pre class=\"hljs\"><code><span class=\"hljs-comment\">/**\n * @param {number[]} row\n * @return {number}\n */</span>\n<span class=\"hljs-keyword\">var</span> minSwapsCouples = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">row</span>) </span>{\n<span class=\"hljs-comment\">//   // 暴力+mem</span>\n<span class=\"hljs-comment\">//   let res=Infinity</span>\n<span class=\"hljs-comment\">//   let mem=new Map()</span>\n<span class=\"hljs-comment\">//   return backtrack(row,0)</span>\n\n<span class=\"hljs-comment\">//   function backtrack(row,idx){</span>\n<span class=\"hljs-comment\">//     if(idx===row.length)return 0</span>\n<span class=\"hljs-comment\">//     if(mem.has(idx))return mem.get(idx)</span>\n<span class=\"hljs-comment\">//     let firstRes=1,secRes=1,thirdRes=0</span>\n<span class=\"hljs-comment\">//     let curG=Math.floor(row[idx]/2),</span>\n<span class=\"hljs-comment\">//         nxtG=Math.floor(row[idx+1]/2)</span>\n<span class=\"hljs-comment\">//     if(curG!==nxtG){</span>\n<span class=\"hljs-comment\">//       let nextCurGID=row.findIndex((n,id)=&gt;Math.floor(n/2)===curG &amp;&amp; id!==idx)</span>\n<span class=\"hljs-comment\">//       if(nextCurGID!==-1){</span>\n<span class=\"hljs-comment\">//         swap(row,idx+1,nextCurGID)</span>\n<span class=\"hljs-comment\">//         firstRes+=backtrack(row,idx+2)</span>\n<span class=\"hljs-comment\">//         swap(row,idx+1,nextCurGID)          </span>\n<span class=\"hljs-comment\">//       }</span>\n<span class=\"hljs-comment\">//       let nextNxtGID=row.findIndex((n,id)=&gt;Math.floor(n/2)===nxtG &amp;&amp; id!==idx+1)</span>\n<span class=\"hljs-comment\">//       if(nextNxtGID!==-1){</span>\n<span class=\"hljs-comment\">//         swap(row,idx,nextNxtGID)</span>\n<span class=\"hljs-comment\">//         secRes+=backtrack(row,idx+2)</span>\n<span class=\"hljs-comment\">//         swap(row,idx,nextNxtGID)         </span>\n<span class=\"hljs-comment\">//       }</span>\n<span class=\"hljs-comment\">//     }else{</span>\n<span class=\"hljs-comment\">//       thirdRes+=backtrack(row,idx+2)</span>\n<span class=\"hljs-comment\">//       mem.set(idx,thirdRes)</span>\n<span class=\"hljs-comment\">//       return thirdRes</span>\n<span class=\"hljs-comment\">//     }</span>\n<span class=\"hljs-comment\">//     let r= Math.min(firstRes,secRes)</span>\n<span class=\"hljs-comment\">//     mem.set(idx,r)</span>\n<span class=\"hljs-comment\">//     return r</span>\n<span class=\"hljs-comment\">//   }</span>\n<span class=\"hljs-comment\">//   function swap(arr,i,j){</span>\n<span class=\"hljs-comment\">//     let t=arr[i]</span>\n<span class=\"hljs-comment\">//     arr[i]=arr[j]</span>\n<span class=\"hljs-comment\">//     arr[j]=t</span>\n<span class=\"hljs-comment\">//   }</span>\n  \n  <span class=\"hljs-comment\">// union Find</span>\n  <span class=\"hljs-comment\">// 思路：将需要swap的组union并且计数，下次再遇到这两组则不再计数</span>\n  <span class=\"hljs-keyword\">let</span> connect=<span class=\"hljs-built_in\">Array</span>.from({<span class=\"hljs-attr\">length</span>:row.length/<span class=\"hljs-number\">2</span>},(n,i)=&gt;i)\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">find</span>(<span class=\"hljs-params\">i</span>)</span>{\n    <span class=\"hljs-keyword\">while</span>(i!==connect[i])i=connect[i]\n    <span class=\"hljs-keyword\">return</span> i\n  }\n  <span class=\"hljs-keyword\">let</span> swap=<span class=\"hljs-number\">0</span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">union</span>(<span class=\"hljs-params\">a,b</span>)</span>{\n    <span class=\"hljs-keyword\">let</span> i=find(a),j=find(b)\n    <span class=\"hljs-keyword\">if</span>(i!==j){\n      swap++\n      connect[i]=j\n    }\n  }\n  <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i=<span class=\"hljs-number\">0</span>;i&lt;row.length;i=i+<span class=\"hljs-number\">2</span>){\n    <span class=\"hljs-keyword\">let</span> g1=<span class=\"hljs-built_in\">Math</span>.floor(row[i]/<span class=\"hljs-number\">2</span>),\n        g2=<span class=\"hljs-built_in\">Math</span>.floor(row[i+<span class=\"hljs-number\">1</span>]/<span class=\"hljs-number\">2</span>)\n    <span class=\"hljs-keyword\">if</span>(g1!==g2)union(g1,g2)\n  }\n  <span class=\"hljs-keyword\">return</span> swap\n};\n</code></pre>\n"
  ],
  "titleSlug": "couples-holding-hands",
  "content": "<p>N 对情侣坐在连续排列的 2N 个座位上，想要牵到对方的手。 计算最少交换座位的次数，以便每对情侣可以并肩坐在一起。 <em>一</em>次交换可选择任意两人，让他们站起来交换座位。</p>\n\n<p>人和座位用&nbsp;<code>0</code>&nbsp;到&nbsp;<code>2N-1</code>&nbsp;的整数表示，情侣们按顺序编号，第一对是&nbsp;<code>(0, 1)</code>，第二对是&nbsp;<code>(2, 3)</code>，以此类推，最后一对是&nbsp;<code>(2N-2, 2N-1)</code>。</p>\n\n<p>这些情侣的初始座位&nbsp;&nbsp;<code>row[i]</code>&nbsp;是由最初始坐在第 i 个座位上的人决定的。</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> row = [0, 2, 1, 3]\n<strong>输出:</strong> 1\n<strong>解释:</strong> 我们只需要交换row[1]和row[2]的位置即可。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> row = [3, 2, 0, 1]\n<strong>输出:</strong> 0\n<strong>解释:</strong> 无需交换座位，所有的情侣都已经可以手牵手了。\n</pre>\n\n<p><strong>说明:</strong></p>\n\n<ol>\n\t<li><code>len(row)</code> 是偶数且数值在&nbsp;<code>[4, 60]</code>范围内。</li>\n\t<li>可以保证<code>row</code> 是序列&nbsp;<code>0...len(row)-1</code>&nbsp;的一个全排列。</li>\n</ol>\n"
}
