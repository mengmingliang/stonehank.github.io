{
  "code": [
    "<pre class=\"hljs\"><code><span class=\"hljs-comment\">/**\n * @param {number[][]} matrix\n * @return {number[]}\n */</span>\n<span class=\"hljs-keyword\">var</span> spiralOrder = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">matrix</span>) </span>{\n  <span class=\"hljs-keyword\">if</span>(matrix.length===<span class=\"hljs-number\">0</span>)<span class=\"hljs-keyword\">return</span> []\n  <span class=\"hljs-keyword\">let</span> m=matrix.length,n=matrix[<span class=\"hljs-number\">0</span>].length\n  <span class=\"hljs-keyword\">let</span> l=<span class=\"hljs-number\">0</span>,r=n<span class=\"hljs-number\">-1</span>,t=<span class=\"hljs-number\">0</span>,d=m<span class=\"hljs-number\">-1</span>\n  <span class=\"hljs-keyword\">let</span> res=[]\n  <span class=\"hljs-keyword\">while</span>(r-l&gt;=<span class=\"hljs-number\">0</span> &amp;&amp; d-t&gt;=<span class=\"hljs-number\">0</span>){\n    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i=l;i&lt;=r;i++)res.push(matrix[t][i])\n    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i=t+<span class=\"hljs-number\">1</span>;i&lt;=d;i++)res.push(matrix[i][r])\n    <span class=\"hljs-keyword\">if</span>(d&gt;t){\n      <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i=r<span class=\"hljs-number\">-1</span>;i&gt;=l+<span class=\"hljs-number\">1</span>;i--)res.push(matrix[d][i])   \n    }\n    <span class=\"hljs-keyword\">if</span>(r&gt;l){\n      <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i=d;i&gt;=t+<span class=\"hljs-number\">1</span>;i--)res.push(matrix[i][l])   \n    }\n\n    l++;r--;t++;d--\n  }\n  <span class=\"hljs-keyword\">return</span> res\n};\n</code></pre>\n"
  ],
  "titleSlug": "spiral-matrix",
  "hasThinking": true,
  "thinking": "<hr>\n<p>思路：</p>\n<ul>\n<li>模拟+<code>DFS</code></li>\n</ul>\n<p>最直观的思路就是模拟这个旋转的过程，定义<code>4</code>个方向，就是顺时针方向，这里我使用<code>dfs</code>，对于当前方向，计算能走的步数<code>limit</code>，走到底，然后换下一个方向，\n直到当前方向能走的步数<code>limit</code>为0。</p>\n<pre class=\"hljs\"><code><span class=\"hljs-comment\">/**\n * @param {number[][]} matrix\n * @return {number[]}\n */</span>\n<span class=\"hljs-keyword\">var</span> spiralOrder = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">matrix</span>) </span>{\n  <span class=\"hljs-keyword\">if</span>(matrix.length===<span class=\"hljs-number\">0</span>)<span class=\"hljs-keyword\">return</span> []\n  <span class=\"hljs-keyword\">let</span> rl=matrix[<span class=\"hljs-number\">0</span>].length,cl=matrix.length<span class=\"hljs-number\">-1</span>\n  <span class=\"hljs-keyword\">let</span> res=[]\n  <span class=\"hljs-keyword\">let</span> moves=[[<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">1</span>],[<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">0</span>],[<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">-1</span>],[<span class=\"hljs-number\">-1</span>,<span class=\"hljs-number\">0</span>]]\n  <span class=\"hljs-keyword\">let</span> mID=<span class=\"hljs-number\">0</span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">dfs</span>(<span class=\"hljs-params\">[x,y]</span>)</span>{\n    <span class=\"hljs-keyword\">let</span> limit\n    <span class=\"hljs-keyword\">if</span>(mID===<span class=\"hljs-number\">0</span> || mID===<span class=\"hljs-number\">2</span>) limit=rl--\n    <span class=\"hljs-keyword\">else</span> limit=cl--\n    <span class=\"hljs-keyword\">if</span>(limit&lt;=<span class=\"hljs-number\">0</span>)<span class=\"hljs-keyword\">return</span>\n    <span class=\"hljs-keyword\">let</span> [dx,dy]=moves[mID]\n    <span class=\"hljs-keyword\">if</span>(++mID===<span class=\"hljs-number\">4</span>)mID=<span class=\"hljs-number\">0</span>\n    <span class=\"hljs-keyword\">let</span> nx=x+dx,ny=y+dy\n    <span class=\"hljs-keyword\">while</span>(limit--&gt;<span class=\"hljs-number\">0</span>){\n      res.push(matrix[nx][ny])\n      nx+=dx\n      ny+=dy\n    }\n    dfs([nx-dx,ny-dy])\n  }\n  dfs([<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">-1</span>])\n  <span class=\"hljs-keyword\">return</span> res\n};\n</code></pre>\n<ul>\n<li>层叠</li>\n</ul>\n<p>官方解答的做法，思路很清晰。</p>\n<p>就像剥洋葱一样，将当前矩阵一层一层剥掉，例如：</p>\n<pre class=\"hljs\"><code>[[1, 1, 1, 1, 1, 1, 1],\n [4, 5, 5, 5, 5, 5, 2],\n [4, 8, 9, 9, 9, 6, 2],\n [4, 8, 7, 7, 7, 6, 2],\n [4, 3, 3, 3, 3, 3, 2]]\n</code></pre>\n<p>数字代表遍历的顺序，也就是加入结果的顺序，很明了而且很有规律，定义4个变量<code>t,d,l,r</code>，分别表示当前<code>上下左右</code>边界，\n每剥掉一层对应的<code>t--;d++;l++;r--</code>，直到<code>d&lt;t || r&lt;l</code>。</p>\n",
  "content": "<p>给定一个包含&nbsp;<em>m</em> x <em>n</em>&nbsp;个元素的矩阵（<em>m</em> 行, <em>n</em> 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。</p>\n\n<p><strong>示例&nbsp;1:</strong></p>\n\n<pre><strong>输入:</strong>\n[\n [ 1, 2, 3 ],\n [ 4, 5, 6 ],\n [ 7, 8, 9 ]\n]\n<strong>输出:</strong> [1,2,3,6,9,8,7,4,5]\n</pre>\n\n<p><strong>示例&nbsp;2:</strong></p>\n\n<pre><strong>输入:</strong>\n[\n  [1, 2, 3, 4],\n  [5, 6, 7, 8],\n  [9,10,11,12]\n]\n<strong>输出:</strong> [1,2,3,4,8,12,11,10,9,5,6,7]\n</pre>\n"
}
