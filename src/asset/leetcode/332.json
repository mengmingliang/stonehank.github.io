{
  "code": [
    "<pre class=\"hljs\"><code><span class=\"hljs-comment\">/**\n * @param {string[][]} tickets\n * @return {string[]}\n */</span>\n<span class=\"hljs-keyword\">var</span> findItinerary = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">tickets</span>) </span>{\n  <span class=\"hljs-comment\">// 拓扑排序(逆后续遍历)</span>\n  <span class=\"hljs-keyword\">let</span> graph=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Map</span>()\n  <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i=<span class=\"hljs-number\">0</span>;i&lt;tickets.length;i++){\n    <span class=\"hljs-keyword\">let</span> [<span class=\"hljs-keyword\">from</span>,to]=tickets[i]\n    <span class=\"hljs-keyword\">if</span>(!graph.has(<span class=\"hljs-keyword\">from</span>)) graph.set(<span class=\"hljs-keyword\">from</span>,[to])\n    <span class=\"hljs-keyword\">else</span> graph.get(<span class=\"hljs-keyword\">from</span>).push(to)\n  }\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> edges <span class=\"hljs-keyword\">of</span> graph.values()) edges.sort();\n  <span class=\"hljs-keyword\">let</span> result=[]\n  dfs(graph,<span class=\"hljs-string\">'JFK'</span>)\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">dfs</span>(<span class=\"hljs-params\">graph,v</span>)</span>{\n    <span class=\"hljs-keyword\">if</span>(graph.has(v)){\n      <span class=\"hljs-keyword\">let</span> des=graph.get(v)\n      <span class=\"hljs-keyword\">while</span>(des.length&gt;<span class=\"hljs-number\">0</span>){\n        dfs(graph,des.shift())\n      }\n    }\n    result.push(v)  \n  }\n  <span class=\"hljs-keyword\">return</span> result.reverse()\n};\n</code></pre>\n"
  ],
  "titleSlug": "reconstruct-itinerary",
  "hasThinking": true,
  "thinking": "<hr>\n<p>思路：</p>\n<p>可以将这个问题先转换成图的格式<code>graph</code>，对其内部每一个<code>graph[i]</code>排序，然后再认为这是一个可以用<code>拓扑排序</code>解决的问题，\n因为每一次的<code>to</code>都必须先经过前面的<code>from</code>。</p>\n",
  "content": "<p>给定一个机票的字符串二维数组 <code>[from, to]</code>，子数组中的两个成员分别表示飞机出发和降落的机场地点，对该行程进行重新规划排序。所有这些机票都属于一个从JFK（肯尼迪国际机场）出发的先生，所以该行程必须从 JFK 出发。</p>\n\n<p><strong>说明:</strong></p>\n\n<ol>\n\t<li>如果存在多种有效的行程，你可以按字符自然排序返回最小的行程组合。例如，行程 [&quot;JFK&quot;, &quot;LGA&quot;] 与 [&quot;JFK&quot;, &quot;LGB&quot;] 相比就更小，排序更靠前</li>\n\t<li>所有的机场都用三个大写字母表示（机场代码）。</li>\n\t<li>假定所有机票至少存在一种合理的行程。</li>\n</ol>\n\n<p><strong>示例 1:</strong></p>\n\n<pre><code><strong>输入: </strong></code><code>[[&quot;MUC&quot;, &quot;LHR&quot;], [&quot;JFK&quot;, &quot;MUC&quot;], [&quot;SFO&quot;, &quot;SJC&quot;], [&quot;LHR&quot;, &quot;SFO&quot;]]</code>\n<strong>输出: </strong><code>[&quot;JFK&quot;, &quot;MUC&quot;, &quot;LHR&quot;, &quot;SFO&quot;, &quot;SJC&quot;]</code>\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre><code><strong>输入: </strong></code><code>[[&quot;JFK&quot;,&quot;SFO&quot;],[&quot;JFK&quot;,&quot;ATL&quot;],[&quot;SFO&quot;,&quot;ATL&quot;],[&quot;ATL&quot;,&quot;JFK&quot;],[&quot;ATL&quot;,&quot;SFO&quot;]]</code>\n<strong>输出: </strong><code>[&quot;JFK&quot;,&quot;ATL&quot;,&quot;JFK&quot;,&quot;SFO&quot;,&quot;ATL&quot;,&quot;SFO&quot;]</code>\n<strong>解释: </strong>另一种有效的行程是&nbsp;<code>[&quot;JFK&quot;,&quot;SFO&quot;,&quot;ATL&quot;,&quot;JFK&quot;,&quot;ATL&quot;,&quot;SFO&quot;]</code>。但是它自然排序更大更靠后。</pre>\n"
}
