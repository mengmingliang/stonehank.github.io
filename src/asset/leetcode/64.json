{
  "code": [
    "/**\n * @param {number[][]} grid\n * @return {number}\n */\nvar minPathSum = function(grid) {\n  if(grid.length===0)return 0  \n  let mem=[]\n  let r=grid.length-1,c=grid[0].length-1\n  for(let i=0;i<=r;i++)mem[i]=[]\n  function dp(grid,r,c){\n    let sum=0\n    if(mem[r][c])return mem[r][c]\n    // if(r===0 && c===0)return grid[0][0]\n    if(r===0){ for(let i=0;i<=c;i++)sum+=grid[0][i]; return sum }\n    if(c===0){ for(let i=0;i<=r;i++)sum+=grid[i][0]; return sum }\n    let newR=r>0?r-1:0,newC=c>0?c-1:0\n    sum=Math.min(dp(grid,newR,c),dp(grid,r,newC))+grid[r][c]\n    mem[r][c]=sum\n    return sum\n  }\n  return dp(grid,r,c)\n};"
  ],
  "titleSlug": "minimum-path-sum",
  "content": "<p>Given a <em>m</em> x <em>n</em> grid filled with non-negative numbers, find a path from top left to bottom right which <em>minimizes</em> the sum of all numbers along its path.</p>\r\n\r\n<p><strong>Note:</strong> You can only move either down or right at any point in time.</p>\r\n\r\n<p><strong>Example:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong>\r\n[\r\n&nbsp; [1,3,1],\r\n  [1,5,1],\r\n  [4,2,1]\r\n]\r\n<strong>Output:</strong> 7\r\n<strong>Explanation:</strong> Because the path 1&rarr;3&rarr;1&rarr;1&rarr;1 minimizes the sum.\r\n</pre>\r\n",
  "translatedContent": "<p>给定一个包含非负整数的 <em>m</em>&nbsp;x&nbsp;<em>n</em>&nbsp;网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p>\n\n<p><strong>说明：</strong>每次只能向下或者向右移动一步。</p>\n\n<p><strong>示例:</strong></p>\n\n<pre><strong>输入:</strong>\n[\n&nbsp; [1,3,1],\n  [1,5,1],\n  [4,2,1]\n]\n<strong>输出:</strong> 7\n<strong>解释:</strong> 因为路径 1&rarr;3&rarr;1&rarr;1&rarr;1 的总和最小。\n</pre>\n"
}
