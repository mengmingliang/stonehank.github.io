{
  "code": [
    "<pre class=\"hljs\"><code><span class=\"hljs-comment\">/**\n * @param {number} n\n * @param {number[][]} edges\n * @return {number[]}\n */</span>\n<span class=\"hljs-keyword\">var</span> findMinHeightTrees = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">n, edges</span>) </span>{\n  <span class=\"hljs-keyword\">if</span>(n===<span class=\"hljs-number\">1</span>)<span class=\"hljs-keyword\">return</span> [<span class=\"hljs-number\">0</span>]\n  <span class=\"hljs-keyword\">let</span> graph=<span class=\"hljs-built_in\">Array</span>(n).fill().map(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span>=&gt;</span>[])\n  <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> [v,w] <span class=\"hljs-keyword\">of</span> edges){\n    graph[v].push(w)\n    graph[w].push(v)\n  }\n  <span class=\"hljs-keyword\">let</span> leaf=[]\n  <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i=<span class=\"hljs-number\">0</span>;i&lt;graph.length;i++){\n    <span class=\"hljs-keyword\">if</span>(graph[i].length===<span class=\"hljs-number\">1</span>){\n      leaf.push(i)\n    }\n  }\n  <span class=\"hljs-keyword\">while</span>(n&gt;<span class=\"hljs-number\">2</span>){\n    <span class=\"hljs-keyword\">let</span> len=leaf.length\n    n-=len\n    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i=<span class=\"hljs-number\">0</span>;i&lt;len;i++){\n      <span class=\"hljs-keyword\">let</span> v=leaf.shift()\n      <span class=\"hljs-keyword\">let</span> nxtV=graph[v].pop()\n      <span class=\"hljs-keyword\">let</span> adj=graph[nxtV]\n      <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> j=<span class=\"hljs-number\">0</span>;j&lt;adj.length;j++){\n        <span class=\"hljs-keyword\">if</span>(adj[j]===v)adj.splice(j,<span class=\"hljs-number\">1</span>)\n      }\n      <span class=\"hljs-keyword\">if</span>(adj.length===<span class=\"hljs-number\">1</span>)leaf.push(nxtV)\n    }\n  }\n  <span class=\"hljs-keyword\">return</span> leaf\n};\n</code></pre>\n"
  ],
  "titleSlug": "minimum-height-trees",
  "hasThinking": true,
  "thinking": "<hr>\n<p>思路：</p>\n<p>我们要找出一棵树的最小高度的根节点，其实就是要找到最中心的<code>1</code>个或者<code>2</code>个点。</p>\n<p>可以先假设，一条直线的路径，我们应该如何找中心点，一个很简单的方法，直线两端两个指针，各自往中间靠近，当2个指针相遇，\n说明找到了中心点。</p>\n<h2><code>树</code>同样如此，我们首先找到<strong>只有1个邻接点</strong>的节点，然后通过不断删除，找出它们的下一个只有1个邻接点的节点，直到最后的一个或者两个节点。</h2>\n",
  "content": "<p>对于一个具有树特征的无向图，我们可选择任何一个节点作为根。图因此可以成为树，在所有可能的树中，具有最小高度的树被称为最小高度树。给出这样的一个图，写出一个函数找到所有的最小高度树并返回他们的根节点。</p>\n\n<p><strong>格式</strong></p>\n\n<p>该图包含&nbsp;<code>n</code>&nbsp;个节点，标记为&nbsp;<code>0</code>&nbsp;到&nbsp;<code>n - 1</code>。给定数字&nbsp;<code>n</code>&nbsp;和一个无向边&nbsp;<code>edges</code>&nbsp;列表（每一个边都是一对标签）。</p>\n\n<p>你可以假设没有重复的边会出现在&nbsp;<code>edges</code>&nbsp;中。由于所有的边都是无向边， <code>[0, 1]</code>和&nbsp;<code>[1, 0]</code>&nbsp;是相同的，因此不会同时出现在&nbsp;<code>edges</code>&nbsp;里。</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre><strong>输入:</strong> <code>n = 4</code>, <code>edges = [[1, 0], [1, 2], [1, 3]]</code>\n\n        0\n        |\n        1\n       / \\\n      2   3 \n\n<strong>输出:</strong> <code>[1]</code>\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre><strong>输入:</strong> <code>n = 6</code>, <code>edges = [[0, 3], [1, 3], [2, 3], [4, 3], [5, 4]]</code>\n\n     0  1  2\n      \\ | /\n        3\n        |\n        4\n        |\n        5 \n\n<strong>输出:</strong> <code>[3, 4]</code></pre>\n\n<p><strong>说明</strong>:</p>\n\n<ul>\n\t<li>&nbsp;根据<a href=\"https://baike.baidu.com/item/%E6%A0%91/2699484?fromtitle=%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84+%E6%A0%91&amp;fromid=12062173&amp;fr=aladdin\" target=\"_blank\">树的定义</a>，树是一个无向图，其中任何两个顶点只通过一条路径连接。 换句话说，一个任何没有简单环路的连通图都是一棵树。</li>\n\t<li>树的高度是指根节点和叶子节点之间最长向下路径上边的数量。</li>\n</ul>\n"
}
