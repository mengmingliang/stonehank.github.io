{
  "code": [
    "<pre class=\"hljs\"><code><span class=\"hljs-comment\">/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */</span>\n<span class=\"hljs-comment\">/**\n * @param {number[]} pre\n * @param {number[]} post\n * @return {TreeNode}\n */</span>\n<span class=\"hljs-keyword\">var</span> constructFromPrePost = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">pre, post</span>) </span>{\n    <span class=\"hljs-keyword\">let</span> root=<span class=\"hljs-keyword\">new</span> TreeNode(pre[<span class=\"hljs-number\">0</span>])\n    <span class=\"hljs-keyword\">let</span> stack=[root]\n    <span class=\"hljs-keyword\">let</span> j=<span class=\"hljs-number\">0</span>\n    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i=<span class=\"hljs-number\">1</span>;i&lt;pre.length;i++){\n        <span class=\"hljs-keyword\">let</span> node=<span class=\"hljs-keyword\">new</span> TreeNode(pre[i])\n        <span class=\"hljs-keyword\">while</span>(stack[stack.length<span class=\"hljs-number\">-1</span>].val===post[j]){\n            j++\n            stack.pop()\n        }\n        <span class=\"hljs-keyword\">if</span>(!stack[stack.length<span class=\"hljs-number\">-1</span>].left){\n            stack[stack.length<span class=\"hljs-number\">-1</span>].left=node\n        }<span class=\"hljs-keyword\">else</span>{\n            stack[stack.length<span class=\"hljs-number\">-1</span>].right=node\n        }\n        stack.push(node)\n    }\n    <span class=\"hljs-keyword\">return</span> stack[<span class=\"hljs-number\">0</span>]\n};\n</code></pre>\n"
  ],
  "titleSlug": "construct-binary-tree-from-preorder-and-postorder-traversal",
  "content": "<p>返回与给定的前序和后序遍历匹配的任何二叉树。</p>\n\n<p>&nbsp;<code>pre</code>&nbsp;和&nbsp;<code>post</code>&nbsp;遍历中的值是不同的正整数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre><strong>输入：</strong>pre = [1,2,4,5,3,6,7], post = [4,5,2,6,7,3,1]\n<strong>输出：</strong>[1,2,3,4,5,6,7]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= pre.length == post.length &lt;= 30</code></li>\n\t<li><code>pre[]</code>&nbsp;和&nbsp;<code>post[]</code>&nbsp;都是&nbsp;<code>1, 2, ..., pre.length</code>&nbsp;的排列</li>\n\t<li>每个输入保证至少有一个答案。如果有多个答案，可以返回其中一个。</li>\n</ul>\n"
}
