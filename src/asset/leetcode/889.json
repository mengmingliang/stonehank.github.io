{
  "code": [
    "/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {number[]} pre\n * @param {number[]} post\n * @return {TreeNode}\n */\nvar constructFromPrePost = function(pre, post) {\n    let root=new TreeNode(pre[0])\n    let stack=[root]\n    let j=0\n    for(let i=1;i<pre.length;i++){\n        let node=new TreeNode(pre[i])\n        while(stack[stack.length-1].val===post[j]){\n            j++\n            stack.pop()\n        }\n        if(!stack[stack.length-1].left){\n            stack[stack.length-1].left=node\n        }else{\n            stack[stack.length-1].right=node\n        }\n        stack.push(node)\n    }\n    return stack[0]\n};"
  ],
  "titleSlug": "construct-binary-tree-from-preorder-and-postorder-traversal",
  "content": "<p>Return any binary tree that matches the given preorder and postorder traversals.</p>\r\n\r\n<p>Values in the traversals&nbsp;<code>pre</code> and <code>post</code>&nbsp;are distinct&nbsp;positive integers.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<div>\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>pre = <span id=\"example-input-1-1\">[1,2,4,5,3,6,7]</span>, post = <span id=\"example-input-1-2\">[4,5,2,6,7,3,1]</span>\r\n<strong>Output: </strong><span id=\"example-output-1\">[1,2,3,4,5,6,7]</span>\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong><span>Note:</span></strong></p>\r\n\r\n<ul>\r\n\t<li><code>1 &lt;= pre.length == post.length &lt;= 30</code></li>\r\n\t<li><code>pre[]</code> and <code>post[]</code>&nbsp;are both permutations of <code>1, 2, ..., pre.length</code>.</li>\r\n\t<li>It is guaranteed an answer exists. If there exists multiple answers, you can return any of them.</li>\r\n</ul>\r\n</div>\r\n",
  "translatedContent": "<p>返回与给定的前序和后序遍历匹配的任何二叉树。</p>\n\n<p>&nbsp;<code>pre</code>&nbsp;和&nbsp;<code>post</code>&nbsp;遍历中的值是不同的正整数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre><strong>输入：</strong>pre = [1,2,4,5,3,6,7], post = [4,5,2,6,7,3,1]\n<strong>输出：</strong>[1,2,3,4,5,6,7]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= pre.length == post.length &lt;= 30</code></li>\n\t<li><code>pre[]</code>&nbsp;和&nbsp;<code>post[]</code>&nbsp;都是&nbsp;<code>1, 2, ..., pre.length</code>&nbsp;的排列</li>\n\t<li>每个输入保证至少有一个答案。如果有多个答案，可以返回其中一个。</li>\n</ul>\n"
}
