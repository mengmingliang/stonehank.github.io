{
  "code": [
    "<pre class=\"hljs\"><code><span class=\"hljs-keyword\">var</span> MyCalendarThree = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">this</span>.itv=[]\n  <span class=\"hljs-keyword\">this</span>.max=<span class=\"hljs-number\">0</span>\n};\n\n<span class=\"hljs-comment\">/** \n * @param {number} start \n * @param {number} end\n * @return {number}\n */</span>\nMyCalendarThree.prototype.book = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">start, end</span>) </span>{\n  <span class=\"hljs-keyword\">let</span> newItv=[],temp=[],i=<span class=\"hljs-number\">0</span>,hasInsert=<span class=\"hljs-literal\">false</span>\n  <span class=\"hljs-keyword\">for</span>(;i&lt;<span class=\"hljs-keyword\">this</span>.itv.length;i++){\n    <span class=\"hljs-keyword\">let</span> [l,r,curK]=<span class=\"hljs-keyword\">this</span>.itv[i]\n    <span class=\"hljs-keyword\">if</span>(start&gt;=r){\n      newItv.push(<span class=\"hljs-keyword\">this</span>.itv[i])\n    }<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(end&lt;=l){\n      <span class=\"hljs-keyword\">break</span>\n    }<span class=\"hljs-keyword\">else</span>{\n      hasInsert=<span class=\"hljs-literal\">true</span>\n      <span class=\"hljs-keyword\">if</span>(start&gt;=l){\n        <span class=\"hljs-keyword\">if</span>(start&gt;l)temp.push([l,start,curK])\n        <span class=\"hljs-keyword\">if</span>(r&gt;=end){\n          <span class=\"hljs-comment\">// 这种情况下已经全完插入新区间了</span>\n          temp.push([start,end,curK+<span class=\"hljs-number\">1</span>])\n          <span class=\"hljs-keyword\">if</span>(r&gt;end)temp.push([end,r,curK])\n          i++\n          <span class=\"hljs-keyword\">break</span>\n        }<span class=\"hljs-keyword\">else</span>{\n          <span class=\"hljs-comment\">// 这种情况下新区间的尾巴还未插入</span>\n          temp.push([start,r,curK+<span class=\"hljs-number\">1</span>])\n          hasInsert=<span class=\"hljs-literal\">false</span>\n          start=r\n        }\n      }<span class=\"hljs-keyword\">else</span>{\n        temp.push([start,l,<span class=\"hljs-number\">1</span>])\n        <span class=\"hljs-keyword\">if</span>(r&gt;=end){\n          temp.push([l,end,curK+<span class=\"hljs-number\">1</span>])\n          <span class=\"hljs-keyword\">if</span>(r&gt;end)temp.push([end,r,curK])\n          i++\n          <span class=\"hljs-keyword\">break</span>\n        }<span class=\"hljs-keyword\">else</span>{\n          temp.push([l,r,curK+<span class=\"hljs-number\">1</span>])\n          hasInsert=<span class=\"hljs-literal\">false</span>\n          start=r\n        }\n      }\n    }\n  }\n\n  <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> j=<span class=\"hljs-number\">0</span>;j&lt;temp.length;j++)newItv.push(temp[j])\n  <span class=\"hljs-keyword\">if</span>(!hasInsert)newItv.push([start,end,<span class=\"hljs-number\">1</span>])\n  <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> j=i;j&lt;<span class=\"hljs-keyword\">this</span>.itv.length;j++)newItv.push(<span class=\"hljs-keyword\">this</span>.itv[j])    \n\n  <span class=\"hljs-keyword\">this</span>.itv=newItv\n  <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i=<span class=\"hljs-number\">0</span>;i&lt;<span class=\"hljs-keyword\">this</span>.itv.length;i++){\n    <span class=\"hljs-keyword\">this</span>.max=<span class=\"hljs-built_in\">Math</span>.max(<span class=\"hljs-keyword\">this</span>.max,<span class=\"hljs-keyword\">this</span>.itv[i][<span class=\"hljs-number\">2</span>])\n  }\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.max\n};\n\n<span class=\"hljs-comment\">/** \n * Your MyCalendarThree object will be instantiated and called as such:\n * var obj = new MyCalendarThree()\n * var param_1 = obj.book(start,end)\n */</span>\n</code></pre>\n"
  ],
  "titleSlug": "my-calendar-iii",
  "hasThinking": true,
  "thinking": "<hr>\n<p>思路：</p>\n<p>2个方法，</p>\n<ol>\n<li>比较好理解，类似<code>NO.798</code>，通过一个<code>map</code>保存区间的叠加状态。</li>\n</ol>\n<p>对于一个区间<code>[start,end]</code>是否叠加，不需要对每一个位置增加，<code>map[start]++</code>，<code>map[start+1]++</code>，<code>...map[end]++</code>，\n因为<code>start&lt;=10^9</code>，一定会<code>TLE</code>，只需要<code>map[start]++</code>，<code>map[end]--</code>，在通过前缀和的方式计算它们的叠加状态。</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">var</span> MyCalendarThree = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-keyword\">this</span>.map={}\n};\n\n<span class=\"hljs-comment\">/** \n * @param {number} start \n * @param {number} end\n * @return {number}\n */</span>\nMyCalendarThree.prototype.book = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">start, end</span>) </span>{\n    <span class=\"hljs-keyword\">if</span>(!<span class=\"hljs-keyword\">this</span>.map[start])<span class=\"hljs-keyword\">this</span>.map[start]=<span class=\"hljs-number\">0</span>\n    <span class=\"hljs-keyword\">this</span>.map[start]++\n    <span class=\"hljs-keyword\">if</span>(!<span class=\"hljs-keyword\">this</span>.map[end])<span class=\"hljs-keyword\">this</span>.map[end]=<span class=\"hljs-number\">0</span>\n    <span class=\"hljs-keyword\">this</span>.map[end]--\n    <span class=\"hljs-keyword\">let</span> max=<span class=\"hljs-number\">-1</span>,cur=<span class=\"hljs-number\">0</span>\n    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> key <span class=\"hljs-keyword\">in</span> <span class=\"hljs-keyword\">this</span>.map){\n        cur+=<span class=\"hljs-keyword\">this</span>.map[key]\n        <span class=\"hljs-keyword\">if</span>(cur&gt;max)max=cur\n    }\n    <span class=\"hljs-keyword\">return</span> max\n};\n</code></pre>\n<ol start=\"2\">\n<li>对于每次提供的区间<code>[start,end]</code>，直接对之前的每一个区间分析，将它精确插入内部，然后处理可能发生的拆分和合并。</li>\n</ol>\n<p>例如：以下两个区间<code>[a,b]</code>和<code>[c,d]</code>，拆分后应该为<code>[a,c]</code>，<code>[c,b]</code>，<code>[b,d]</code></p>\n<pre class=\"hljs\"><code>  a      b\n   ------\n     c           d\n      -----------\n</code></pre>\n",
  "content": "<p>实现一个 <code>MyCalendar</code> 类来存放你的日程安排，你可以一直添加新的日程安排。</p>\n\n<p><code>MyCalendar</code> 有一个 <code>book(int start, int end)</code>方法。它意味着在start到end时间内增加一个日程安排，注意，这里的时间是半开区间，即 <code>[start, end)</code>, 实数&nbsp;<code>x</code> 的范围为， &nbsp;<code>start &lt;= x &lt; end</code>。</p>\n\n<p>当 <strong>K</strong> 个日程安排有一些时间上的交叉时（例如K个日程安排都在同一时间内），就会产生 <strong>K</strong> 次预订。</p>\n\n<p>每次调用 <code>MyCalendar.book</code>方法时，返回一个整数 <code>K</code> ，表示最大的 <code>K</code> 次预订。</p>\n\n<p>请按照以下步骤调用<code>MyCalendar</code> 类: <code>MyCalendar cal = new MyCalendar();</code> <code>MyCalendar.book(start, end)</code></p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\nMyCalendarThree();\nMyCalendarThree.book(10, 20); // returns 1\nMyCalendarThree.book(50, 60); // returns 1\nMyCalendarThree.book(10, 40); // returns 2\nMyCalendarThree.book(5, 15); // returns 3\nMyCalendarThree.book(5, 10); // returns 3\nMyCalendarThree.book(25, 55); // returns 3\n<strong>解释:</strong> \n前两个日程安排可以预订并且不相交，所以最大的K次预订是1。\n第三个日程安排[10,40]与第一个日程安排相交，最高的K次预订为2。\n其余的日程安排的最高K次预订仅为3。\n请注意，最后一次日程安排可能会导致局部最高K次预订为2，但答案仍然是3，原因是从开始到最后，时间[10,20]，[10,40]和[5,15]仍然会导致3次预订。\n</pre>\n\n<p><strong>说明:</strong></p>\n\n<ul>\n\t<li>每个测试用例，调用&nbsp;<code>MyCalendar.book</code>&nbsp;函数最多不超过&nbsp;<code>400</code>次。</li>\n\t<li>调用函数&nbsp;<code>MyCalendar.book(start, end)</code>时，&nbsp;<code>start</code> 和&nbsp;<code>end</code> 的取值范围为&nbsp;<code>[0, 10^9]</code>。</li>\n</ul>\n"
}
