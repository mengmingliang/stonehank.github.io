{
  "code": [
    "\n// var MyCalendarThree = function() {\n//     this.map={}\n//     this.max=-1   \n// };\n\n// /**\n//  * @param {number} start\n//  * @param {number} end\n//  * @return {number}\n//  */\n// MyCalendarThree.prototype.book = function(start, end) {\n \n//   if(!this.map[start])this.map[start]=0\n//   this.map[start]++\n//   if(!this.map[end])this.map[end]=0\n//   this.map[end]--\n\n//   let cur=0\n//   for(let key in this.map){\n//     cur+=this.map[key]\n//     if(cur>this.max){\n//       this.max=cur\n//       return this.max\n//     }\n//   }\n//   return this.max\n// };\n\n\nfunction item(date, count, next) {\n  return { date, count, next };\n}\n\n// 将item放到after后面\nfunction insert(after, item) {\n  item.next = after.next;\n  after.next = item;\n  return item;\n}\n\nvar MyCalendarThree = function() {\n  this.head = item(0, 0);\n  this.max = 1;\n};\n\n/**\n * @param {number} start\n * @param {number} end\n * @return {number}\n */\nMyCalendarThree.prototype.book = function(start, end) {\n  let p = this.head;\n\n  // Skip to last element < start\n  while (p.next && p.next.date < start) {\n    p = p.next;\n  }\n\n  // Insert start item after p\n  if (p.next && p.next.date > start) {\n    p = insert(p, item(start, p.count + 1, p.next));\n    this.max = Math.max(p.count, this.max);\n  }\n\n  // Increment existing items < end\n  while (p.next && p.next.date < end) {\n    p = p.next;\n    this.max = Math.max(++p.count, this.max);\n  }\n\n  if (!p.next) {\n    // Append to the end of the list\n    if (p.date < start) {\n      p = insert(p, item(start, 1));\n    }\n    insert(p, item(end, 0));\n  } else if (p.next.date > end) {\n    // Insert end in the middle of the list\n    insert(p, item(end, p.count - 1));\n  }\n\n  return this.max;\n};\n\n\n/** \n * Your MyCalendarThree object will be instantiated and called as such:\n * var obj = Object.create(MyCalendarThree).createNew()\n * var param_1 = obj.book(start,end)\n */"
  ],
  "titleSlug": "my-calendar-iii",
  "content": "<p>Implement a <code>MyCalendarThree</code> class to store your events. A new event can <b>always</b> be added.</p>\r\n\r\n<p>Your class will have one method, <code>book(int start, int end)</code>. Formally, this represents a booking on the half open interval <code>[start, end)</code>, the range of real numbers <code>x</code> such that <code>start &lt;= x &lt; end</code>.</p>\r\n\r\n<p>A <i>K-booking</i> happens when <b>K</b> events have some non-empty intersection (ie., there is some time that is common to all K events.)</p>\r\n\r\n<p>For each call to the method <code>MyCalendar.book</code>, return an integer <code>K</code> representing the largest integer such that there exists a <code>K</code>-booking in the calendar.</p>\r\nYour class will be called like this: <code>MyCalendarThree cal = new MyCalendarThree();</code> <code>MyCalendarThree.book(start, end)</code>\r\n\r\n<p><b>Example 1:</b></p>\r\n\r\n<pre>\r\nMyCalendarThree();\r\nMyCalendarThree.book(10, 20); // returns 1\r\nMyCalendarThree.book(50, 60); // returns 1\r\nMyCalendarThree.book(10, 40); // returns 2\r\nMyCalendarThree.book(5, 15); // returns 3\r\nMyCalendarThree.book(5, 10); // returns 3\r\nMyCalendarThree.book(25, 55); // returns 3\r\n<b>Explanation:</b> \r\nThe first two events can be booked and are disjoint, so the maximum K-booking is a 1-booking.\r\nThe third event [10, 40) intersects the first event, and the maximum K-booking is a 2-booking.\r\nThe remaining events cause the maximum K-booking to be only a 3-booking.\r\nNote that the last event locally causes a 2-booking, but the answer is still 3 because\r\neg. [10, 20), [10, 40), and [5, 15) are still triple booked.\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><b>Note:</b></p>\r\n\r\n<ul>\r\n\t<li>The number of calls to <code>MyCalendarThree.book</code> per test case will be at most <code>400</code>.</li>\r\n\t<li>In calls to <code>MyCalendarThree.book(start, end)</code>, <code>start</code> and <code>end</code> are integers in the range <code>[0, 10^9]</code>.</li>\r\n</ul>\r\n\r\n<p>&nbsp;</p>\r\n",
  "translatedContent": "<p>实现一个 <code>MyCalendar</code> 类来存放你的日程安排，你可以一直添加新的日程安排。</p>\n\n<p><code>MyCalendar</code> 有一个 <code>book(int start, int end)</code>方法。它意味着在start到end时间内增加一个日程安排，注意，这里的时间是半开区间，即 <code>[start, end)</code>, 实数&nbsp;<code>x</code> 的范围为， &nbsp;<code>start &lt;= x &lt; end</code>。</p>\n\n<p>当 <strong>K</strong> 个日程安排有一些时间上的交叉时（例如K个日程安排都在同一时间内），就会产生 <strong>K</strong> 次预订。</p>\n\n<p>每次调用 <code>MyCalendar.book</code>方法时，返回一个整数 <code>K</code> ，表示最大的 <code>K</code> 次预订。</p>\n\n<p>请按照以下步骤调用<code>MyCalendar</code> 类: <code>MyCalendar cal = new MyCalendar();</code> <code>MyCalendar.book(start, end)</code></p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\nMyCalendarThree();\nMyCalendarThree.book(10, 20); // returns 1\nMyCalendarThree.book(50, 60); // returns 1\nMyCalendarThree.book(10, 40); // returns 2\nMyCalendarThree.book(5, 15); // returns 3\nMyCalendarThree.book(5, 10); // returns 3\nMyCalendarThree.book(25, 55); // returns 3\n<strong>解释:</strong> \n前两个日程安排可以预订并且不相交，所以最大的K次预订是1。\n第三个日程安排[10,40]与第一个日程安排相交，最高的K次预订为2。\n其余的日程安排的最高K次预订仅为3。\n请注意，最后一次日程安排可能会导致局部最高K次预订为2，但答案仍然是3，原因是从开始到最后，时间[10,20]，[10,40]和[5,15]仍然会导致3次预订。\n</pre>\n\n<p><strong>说明:</strong></p>\n\n<ul>\n\t<li>每个测试用例，调用&nbsp;<code>MyCalendar.book</code>&nbsp;函数最多不超过&nbsp;<code>400</code>次。</li>\n\t<li>调用函数&nbsp;<code>MyCalendar.book(start, end)</code>时，&nbsp;<code>start</code> 和&nbsp;<code>end</code> 的取值范围为&nbsp;<code>[0, 10^9]</code>。</li>\n</ul>\n"
}
