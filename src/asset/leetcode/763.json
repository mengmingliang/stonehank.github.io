{
  "code": [
    "<pre class=\"hljs\"><code><span class=\"hljs-comment\">/**\n * @param {string} S\n * @return {number[]}\n */</span>\n<span class=\"hljs-keyword\">var</span> partitionLabels = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">S</span>) </span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">uniq</span>(<span class=\"hljs-params\">s</span>)</span>{\n        <span class=\"hljs-keyword\">let</span> arr=[];\n        <span class=\"hljs-keyword\">let</span> set=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Set</span>(s);\n        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i <span class=\"hljs-keyword\">of</span> set){\n            arr.push(i);\n        }\n        <span class=\"hljs-keyword\">return</span> arr;\n    }\n    <span class=\"hljs-keyword\">let</span> uS=uniq(S)\n    <span class=\"hljs-keyword\">let</span> matchAll=<span class=\"hljs-string\">''</span>\n    <span class=\"hljs-keyword\">let</span> res=[]\n    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i=<span class=\"hljs-number\">0</span>;i&lt;uS.length;i++){\n        <span class=\"hljs-keyword\">let</span> indOf=matchAll.indexOf(uS[i])\n        <span class=\"hljs-keyword\">if</span>(indOf!==<span class=\"hljs-number\">-1</span>){\n            <span class=\"hljs-keyword\">let</span> newM=S.match(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">RegExp</span>(uS[i]+<span class=\"hljs-string\">\".*\"</span>+uS[i])) \n            <span class=\"hljs-keyword\">if</span>(newM &amp;&amp; ((newM[<span class=\"hljs-number\">0</span>].length+indOf)&gt;matchAll.length)){\n                matchAll+=newM[<span class=\"hljs-number\">0</span>].substring(matchAll.length-indOf,newM[<span class=\"hljs-number\">0</span>].length)  \n            }\n        }<span class=\"hljs-keyword\">else</span>{\n            <span class=\"hljs-keyword\">if</span>(matchAll)res.push(matchAll)\n            <span class=\"hljs-keyword\">let</span> match=S.match(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">RegExp</span>(uS[i]+<span class=\"hljs-string\">\".*\"</span>+uS[i])) \n            matchAll=match?match[<span class=\"hljs-number\">0</span>]:uS[i]\n        }\n    }\n    res.push(matchAll)\n    <span class=\"hljs-keyword\">let</span> finalR=[]\n    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i=<span class=\"hljs-number\">0</span>;i&lt;res.length;i++){\n        finalR[i]=res[i].length\n    }\n    <span class=\"hljs-keyword\">return</span> finalR\n\n};\n</code></pre>\n"
  ],
  "titleSlug": "partition-labels",
  "translatedContent": "<p>字符串 <code>S</code> 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一个字母只会出现在其中的一个片段。返回一个表示每个字符串片段的长度的列表。</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre><strong>输入:</strong> S = &quot;ababcbacadefegdehijhklij&quot;\n<strong>输出:</strong> [9,7,8]\n<strong>解释:</strong>\n划分结果为 &quot;ababcbaca&quot;, &quot;defegde&quot;, &quot;hijhklij&quot;。\n每个字母最多出现在一个片段中。\n像 &quot;ababcbacadefegde&quot;, &quot;hijhklij&quot; 的划分是错误的，因为划分的片段数较少。\n</pre>\n\n<p><strong>注意:</strong></p>\n\n<ol>\n\t<li><code>S</code>的长度在<code>[1, 500]</code>之间。</li>\n\t<li><code>S</code>只包含小写字母<code>&#39;a&#39;</code>到<code>&#39;z&#39;</code>。</li>\n</ol>\n"
}
