{
  "code": [
    "/**\n * @param {string} S\n * @return {number[]}\n */\nvar partitionLabels = function(S) {\n    function uniq(s){\n        let arr=[];\n        let set=new Set(s);\n        for(let i of set){\n            arr.push(i);\n        }\n        return arr;\n    }\n    let uS=uniq(S)\n    let matchAll=''\n    let res=[]\n    for(let i=0;i<uS.length;i++){\n        let indOf=matchAll.indexOf(uS[i])\n        if(indOf!==-1){\n            let newM=S.match(new RegExp(uS[i]+\".*\"+uS[i])) \n            if(newM && ((newM[0].length+indOf)>matchAll.length)){\n                matchAll+=newM[0].substring(matchAll.length-indOf,newM[0].length)  \n            }\n        }else{\n            if(matchAll)res.push(matchAll)\n            let match=S.match(new RegExp(uS[i]+\".*\"+uS[i])) \n            matchAll=match?match[0]:uS[i]\n        }\n    }\n    res.push(matchAll)\n    let finalR=[]\n    for(let i=0;i<res.length;i++){\n        finalR[i]=res[i].length\n    }\n    return finalR\n\n};"
  ],
  "titleSlug": "partition-labels",
  "content": "<p>\r\nA string <code>S</code> of lowercase letters is given.  We want to partition this string into as many parts as possible so that each letter appears in at most one part, and return a list of integers representing the size of these parts.\r\n</p><p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> S = \"ababcbacadefegdehijhklij\"\r\n<b>Output:</b> [9,7,8]\r\n<b>Explanation:</b>\r\nThe partition is \"ababcbaca\", \"defegde\", \"hijhklij\".\r\nThis is a partition so that each letter appears in at most one part.\r\nA partition like \"ababcbacadefegde\", \"hijhklij\" is incorrect, because it splits S into less parts.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b><br><ol>\r\n<li><code>S</code> will have length in range <code>[1, 500]</code>.</li>\r\n<li><code>S</code> will consist of lowercase letters (<code>'a'</code> to <code>'z'</code>) only.</li>\r\n</ol></p>",
  "translatedContent": "<p>字符串 <code>S</code> 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一个字母只会出现在其中的一个片段。返回一个表示每个字符串片段的长度的列表。</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre><strong>输入:</strong> S = &quot;ababcbacadefegdehijhklij&quot;\n<strong>输出:</strong> [9,7,8]\n<strong>解释:</strong>\n划分结果为 &quot;ababcbaca&quot;, &quot;defegde&quot;, &quot;hijhklij&quot;。\n每个字母最多出现在一个片段中。\n像 &quot;ababcbacadefegde&quot;, &quot;hijhklij&quot; 的划分是错误的，因为划分的片段数较少。\n</pre>\n\n<p><strong>注意:</strong></p>\n\n<ol>\n\t<li><code>S</code>的长度在<code>[1, 500]</code>之间。</li>\n\t<li><code>S</code>只包含小写字母<code>&#39;a&#39;</code>到<code>&#39;z&#39;</code>。</li>\n</ol>\n"
}
