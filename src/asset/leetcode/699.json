{
  "code": [
    "/**\n * @param {number[][]} positions\n * @return {number[]}\n */\nvar fallingSquares = function(positions) {\n  let cache=[],res=[],maxHeight=0\n  for(let i=0;i<positions.length;i++){\n    let l=positions[i][0],r=l+positions[i][1]-1,h=positions[i][1]\n    let newH=getHeight(cache,[l,r,h])\n    maxHeight=Math.max(maxHeight,newH)\n    res.push(maxHeight)\n  }\n    \n  function getHeight(cache,positions){\n    let max=0\n    let l=positions[0],r=positions[1],h=positions[2]\n    for(let i=0;i<cache.length;i++){\n      let cl=cache[i][0],cr=cache[i][1],ch=cache[i][2]\n      if(cl>r)continue\n      if(cr<l)continue\n      max=Math.max(max,ch)\n    }\n    positions[2]+=max\n    cache.push(positions)\n    return positions[2]\n  }\n\n  return res\n};"
  ],
  "titleSlug": "falling-squares",
  "content": "<p>On an infinite number line (x-axis), we drop given squares in the order they are given.</p>\r\n<p>The <code>i</code>-th square dropped (<code>positions[i] = (left, side_length)</code>) is a square with the left-most point being <code>positions[i][0]</code> and sidelength <code>positions[i][1]</code>.</p>\r\n<p>The square is dropped with the bottom edge parallel to the number line, and from a higher height than all currently landed squares.  We wait for each square to stick before dropping the next.</p>\r\n<p>The squares are infinitely sticky on their bottom edge, and will remain fixed to any positive length surface they touch (either the number line or another square).  Squares dropped adjacent to each other will not stick together prematurely.</p>\r\n\r\n<br>\r\n<p>Return a list <code>ans</code> of heights.  Each height <code>ans[i]</code> represents the current highest height of any square we have dropped, after dropping squares represented by <code>positions[0], positions[1], ..., positions[i]</code>.\r\n</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> [[1, 2], [2, 3], [6, 1]]\r\n<b>Output:</b> [2, 5, 5]\r\n<b>Explanation:</b>\r\n<p>\r\nAfter the first drop of <code>positions[0] = [1, 2]:\r\n_aa\r\n_aa\r\n-------\r\n</code>The maximum height of any square is 2.\r\n</p><p>\r\nAfter the second drop of <code>positions[1] = [2, 3]:\r\n__aaa\r\n__aaa\r\n__aaa\r\n_aa__\r\n_aa__\r\n--------------\r\n</code>The maximum height of any square is 5.  \r\nThe larger square stays on top of the smaller square despite where its center\r\nof gravity is, because squares are infinitely sticky on their bottom edge.\r\n</p><p>\r\nAfter the third drop of <code>positions[1] = [6, 1]:\r\n__aaa\r\n__aaa\r\n__aaa\r\n_aa\r\n_aa___a\r\n--------------\r\n</code>The maximum height of any square is still 5.\r\n\r\nThus, we return an answer of <code>[2, 5, 5]</code>.\r\n</pre>\r\n</p>\r\n\r\n<br>\r\n\r\n<p><b>Example 2:</b><br />\r\n<pre>\r\n<b>Input:</b> [[100, 100], [200, 100]]\r\n<b>Output:</b> [100, 100]\r\n<b>Explanation:</b> Adjacent squares don't get stuck prematurely - only their bottom edge can stick to surfaces.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b>\r\n<li><code>1 <= positions.length <= 1000</code>.</li>\r\n<li><code>1 <= positions[i][0] <= 10^8</code>.</li>\r\n<li><code>1 <= positions[i][1] <= 10^6</code>.</li>\r\n</p>",
  "translatedContent": "<p>在无限长的数轴（即 x 轴）上，我们根据给定的顺序放置对应的正方形方块。</p>\n\n<p>第 <code>i</code> 个掉落的方块（<code>positions[i] = (left, side_length)</code>）是正方形，其中&nbsp;<code>left 表示该方块最左边的点位置(positions[i][0])，side_length 表示该方块的边长(positions[i][1])。</code></p>\n\n<p>每个方块的底部边缘平行于数轴（即 x 轴），并且从一个比目前所有的落地方块更高的高度掉落而下。在上一个方块结束掉落，并保持静止后，才开始掉落新方块。</p>\n\n<p>方块的底边具有非常大的粘性，并将保持固定在它们所接触的任何长度表面上（无论是数轴还是其他方块）。邻接掉落的边不会过早地粘合在一起，<code>因为只有底边才具有粘性。</code></p>\n\n<p>&nbsp;</p>\n\n<p>返回一个堆叠高度列表&nbsp;<code>ans</code> 。每一个堆叠高度&nbsp;<code>ans[i]</code>&nbsp;表示在通过&nbsp;<code>positions[0], positions[1], ..., positions[i]</code>&nbsp;表示的方块掉落结束后，目前所有已经落稳的方块堆叠的最高高度。</p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre><strong>输入:</strong> [[1, 2], [2, 3], [6, 1]]\n<strong>输出:</strong> [2, 5, 5]\n<strong>解释:\n\n</strong>第一个方块 <code>positions[0] = [1, 2] </code>掉落：\n<code>_aa\n_aa\n-------\n</code>方块最大高度为 2 。\n\n第二个方块 <code>positions[1] = [2, 3] </code>掉落：\n<code>__aaa\n__aaa\n__aaa\n_aa__\n_aa__\n--------------\n</code>方块最大高度为5。\n大的方块保持在较小的方块的顶部，不论它的重心在哪里，因为方块的底部边缘有非常大的粘性。\n\n第三个方块 <code>positions[1] = [6, 1] </code>掉落：\n<code>__aaa\n__aaa\n__aaa\n_aa\n_aa___a\n-------------- \n</code>方块最大高度为5。\n\n因此，我们返回结果<code>[2, 5, 5]。</code>\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 2:</strong></p>\n\n<pre><strong>输入:</strong> [[100, 100], [200, 100]]\n<strong>输出:</strong> [100, 100]\n<strong>解释:</strong> 相邻的方块不会过早地卡住，只有它们的底部边缘才能粘在表面上。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>注意:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= positions.length &lt;= 1000</code>.</li>\n\t<li><code>1 &lt;= positions[i][0] &lt;= 10^8</code>.</li>\n\t<li><code>1 &lt;= positions[i][1] &lt;= 10^6</code>.</li>\n</ul>\n\n<p>&nbsp;</p>\n"
}
