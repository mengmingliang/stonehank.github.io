{
  "code": [
    "<pre class=\"hljs\"><code><span class=\"hljs-comment\">/**\n * @param {number[][]} forest\n * @return {number}\n */</span>\n<span class=\"hljs-keyword\">var</span> cutOffTree = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">forest</span>) </span>{\n  <span class=\"hljs-keyword\">let</span> pq=[]\n  <span class=\"hljs-keyword\">let</span> m=forest.length,n=forest[<span class=\"hljs-number\">0</span>].length\n  <span class=\"hljs-keyword\">let</span> visited=<span class=\"hljs-built_in\">Array</span>(m).fill().map(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span>=&gt;</span><span class=\"hljs-built_in\">Array</span>(n).fill(<span class=\"hljs-number\">0</span>))\n  <span class=\"hljs-keyword\">let</span> uniq=<span class=\"hljs-number\">0</span>\n  <span class=\"hljs-keyword\">let</span> moves=[[<span class=\"hljs-number\">-1</span>,<span class=\"hljs-number\">0</span>],[<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">0</span>],[<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">-1</span>],[<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">1</span>]]\n  <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i=<span class=\"hljs-number\">0</span>;i&lt;m;i++){\n    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> j=<span class=\"hljs-number\">0</span>;j&lt;n;j++){\n      <span class=\"hljs-keyword\">if</span>(forest[i][j]&gt;<span class=\"hljs-number\">1</span>){\n        pq.push([forest[i][j],i,j])\n      }\n    }\n  }\n  pq.sort(<span class=\"hljs-function\">(<span class=\"hljs-params\">a,b</span>)=&gt;</span>b[<span class=\"hljs-number\">0</span>]-a[<span class=\"hljs-number\">0</span>])\n  <span class=\"hljs-keyword\">let</span> curPos=[<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">0</span>],res=<span class=\"hljs-number\">0</span>\n  <span class=\"hljs-keyword\">while</span>(pq.length&gt;<span class=\"hljs-number\">0</span>){\n    uniq++\n    <span class=\"hljs-keyword\">let</span> [h,x,y]=pq.pop()\n    visited[curPos[<span class=\"hljs-number\">0</span>]][curPos[<span class=\"hljs-number\">1</span>]]=uniq\n    <span class=\"hljs-keyword\">let</span> curSteps=bfs([curPos],[x,y])\n    <span class=\"hljs-keyword\">if</span>(curSteps===<span class=\"hljs-number\">-1</span>)<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>\n    res+=curSteps\n    curPos=[x,y]\n  }\n  <span class=\"hljs-keyword\">return</span> res\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">bfs</span>(<span class=\"hljs-params\">arr,[tx,ty]</span>)</span>{\n    <span class=\"hljs-keyword\">let</span> step=<span class=\"hljs-number\">0</span>\n    <span class=\"hljs-keyword\">while</span>(arr.length&gt;<span class=\"hljs-number\">0</span>){\n      <span class=\"hljs-keyword\">let</span> len=arr.length,aux=[]\n      <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i=<span class=\"hljs-number\">0</span>;i&lt;len;i++){\n        <span class=\"hljs-keyword\">let</span> [x,y]=arr[i]\n        <span class=\"hljs-keyword\">if</span>(x===tx &amp;&amp; y===ty)<span class=\"hljs-keyword\">return</span> step\n        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> [dx,dy] <span class=\"hljs-keyword\">of</span> moves){\n          <span class=\"hljs-keyword\">let</span> nx=dx+x,ny=dy+y\n          <span class=\"hljs-keyword\">if</span>(nx&lt;<span class=\"hljs-number\">0</span> || ny&lt;<span class=\"hljs-number\">0</span> || nx&gt;=m || ny&gt;=n)<span class=\"hljs-keyword\">continue</span>\n          <span class=\"hljs-keyword\">if</span>(visited[nx][ny]===uniq)<span class=\"hljs-keyword\">continue</span>\n          <span class=\"hljs-keyword\">if</span>(forest[nx][ny]===<span class=\"hljs-number\">0</span>)<span class=\"hljs-keyword\">continue</span>\n          visited[nx][ny]=uniq\n          aux.push([nx,ny])\n        }\n      }\n      step++\n      arr=aux\n    }\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>\n  }\n};\n</code></pre>\n"
  ],
  "titleSlug": "cut-off-trees-for-golf-event",
  "hasThinking": true,
  "thinking": "<hr>\n<p>思路：</p>\n<p>由于题目要求从低到高砍树，那么我们就可以使用<code>优先队列</code>或者直接用数组将树添加，最后再排序。</p>\n<p>按照从低到高的顺序，构建一个<code>bfs</code>函数，其中参数1是当前的位置，参数2是目标位置，每次计算最短路径即可，如果当前无法到达目标点，\n返回<code>-1</code>，否则当前位置更新为目标位置，继续下一个目标位置。</p>\n",
  "content": "<p>你被请来给一个要举办高尔夫比赛的树林砍树. 树林由一个非负的二维数组表示， 在这个数组中：</p>\n\n<ol>\n\t<li><code>0</code> 表示障碍，无法触碰到.</li>\n\t<li><code>1</code>&nbsp;表示可以行走的地面.</li>\n\t<li><code>比1大的数</code>&nbsp;表示一颗允许走过的树的高度.</li>\n</ol>\n\n<p>你被要求按照树的高度从低向高砍掉所有的树，每砍过一颗树，树的高度变为1。</p>\n\n<p>你将从（0，0）点开始工作，你应该返回你砍完所有树需要走的最小步数。 如果你无法砍完所有的树，返回 -1 。</p>\n\n<p>可以保证的是，没有两棵树的高度是相同的，并且至少有一颗树需要你砍。</p>\n\n<p><strong>示例&nbsp;1:</strong></p>\n\n<pre>\n<strong>输入:</strong> \n[\n [1,2,3],\n [0,0,4],\n [7,6,5]\n]\n<strong>输出:</strong> 6\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>示例&nbsp;2:</strong></p>\n\n<pre>\n<strong>输入:</strong> \n[\n [1,2,3],\n [0,0,0],\n [7,6,5]\n]\n<strong>输出:</strong> -1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>示例&nbsp;3:</strong></p>\n\n<pre>\n<strong>输入:</strong> \n[\n [2,3,4],\n [0,0,5],\n [8,7,6]\n]\n<strong>输出:</strong> 6\n\n<strong>解释:</strong> (0,0) 位置的树，你可以直接砍去，不用算步数\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示</strong>: 矩阵大小不会超过 50x50 。</p>\n"
}
