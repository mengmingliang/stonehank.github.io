{
  "code": [
    "/**\n * @param {number[][]} A\n * @return {number}\n */\nvar shortestBridge = function(aux) {\n  let bsf=[],moves=[[-1,0],[1,0],[0,-1],[0,1]],path=0\n\n  let startI=null,startJ=null\n  for(let i=0;i<aux.length;i++){\n    if(startI!=null&&startJ!=null)break\n    for(let j=0;j<aux[0].length;j++){\n      if(aux[i][j]===1){\n        startI=i\n        startJ=j\n        break\n      }\n    }\n  }\n\n  function dsf(arr,i,j){\n    bsf.push([i,j])\n    arr[i][j]=-1\n    for(let k=0;k<moves.length;k++){\n      let cI=i+moves[k][0],cJ=j+moves[k][1]\n      if(cI<0 || cI>=arr.length || cJ<0 || cJ>=arr.length)continue\n      if(arr[cI][cJ]!==1)continue\n      dsf(arr,cI,cJ)\n    }\n  }\n  dsf(aux,startI,startJ)\n\n  while(bsf.length>0){\n    let len=bsf.length\n    for(let i=0;i<len;i++){\n      let cur=bsf.shift()\n      let x=cur[0],y=cur[1]\n      for(let j=0;j<moves.length;j++){\n        let nX=x+moves[j][0],nY=y+moves[j][1]\n        if(nX<0 || nX>aux.length-1 || nY<0 || nY>aux.length-1)continue\n        if(aux[nX][nY]===1)return path\n        if(!aux[nX][nY]){\n          aux[nX][nY]=-1\n          bsf.push([nX,nY])\n        }\n\n      }\n    }\n    path++\n  }\n};"
  ],
  "titleSlug": "shortest-bridge",
  "content": "<p>In a given 2D binary array <code>A</code>, there are two islands.&nbsp; (An island is a 4-directionally connected group of&nbsp;<code>1</code>s not connected to any other 1s.)</p>\r\n\r\n<p>Now, we may change <code>0</code>s to <code>1</code>s so as to connect the two islands together to form 1 island.</p>\r\n\r\n<p>Return the smallest number of <code>0</code>s that must be flipped.&nbsp; (It is guaranteed that the answer is at least 1.)</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-1-1\">[[0,1],[1,0]]</span>\r\n<strong>Output: </strong>1\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-2-1\">[[0,1,0],[0,0,0],[0,0,1]]</span>\r\n<strong>Output: </strong>2\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 3:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-3-1\">[[1,1,1,1,1],[1,0,0,0,1],[1,0,1,0,1],[1,0,0,0,1],[1,1,1,1,1]]</span>\r\n<strong>Output: </strong><span id=\"example-output-3\">1</span></pre>\r\n\r\n<p>&nbsp;</p>\r\n</div>\r\n</div>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ol>\r\n\t<li><code>1 &lt;= A.length =&nbsp;A[0].length &lt;= 100</code></li>\r\n\t<li><code>A[i][j] == 0</code> or <code>A[i][j] == 1</code></li>\r\n</ol>\r\n\r\n<div>\r\n<div>\r\n<div>&nbsp;</div>\r\n</div>\r\n</div>",
  "translatedContent": "<p>在给定的二维二进制数组&nbsp;<code>A</code>&nbsp;中，存在两座岛。（岛是由四面相连的 <code>1</code> 形成的一个最大组。）</p>\n\n<p>现在，我们可以将&nbsp;<code>0</code>&nbsp;变为&nbsp;<code>1</code>，以使两座岛连接起来，变成一座岛。</p>\n\n<p>返回必须翻转的&nbsp;<code>0</code> 的最小数目。（可以保证答案至少是 1。）</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>[[0,1],[1,0]]\n<strong>输出：</strong>1\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>[[0,1,0],[0,0,0],[0,0,1]]\n<strong>输出：</strong>2\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>[[1,1,1,1,1],[1,0,0,0,1],[1,0,1,0,1],[1,0,0,0,1],[1,1,1,1,1]]\n<strong>输出：</strong>1</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ol>\n\t<li><code>1 &lt;= A.length =&nbsp;A[0].length &lt;= 100</code></li>\n\t<li><code>A[i][j] == 0</code> 或&nbsp;<code>A[i][j] == 1</code></li>\n</ol>\n\n<p>&nbsp;</p>\n"
}
