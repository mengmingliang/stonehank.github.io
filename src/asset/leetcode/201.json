{
  "code": [
    "<pre class=\"hljs\"><code><span class=\"hljs-comment\">/**\n * @param {number} m\n * @param {number} n\n * @return {number}\n */</span>\n<span class=\"hljs-keyword\">var</span> rangeBitwiseAnd = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">m, n</span>) </span>{\n  <span class=\"hljs-keyword\">let</span> k=<span class=\"hljs-built_in\">Math</span>.pow(<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">30</span>)\n  <span class=\"hljs-keyword\">let</span> str=<span class=\"hljs-string\">''</span>\n  <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i=<span class=\"hljs-number\">0</span>;i&lt;<span class=\"hljs-number\">31</span>;i++){\n    <span class=\"hljs-keyword\">let</span> c1=(m&lt;&lt;i) &amp; k,\n        c2=(n&lt;&lt;i) &amp; k\n    <span class=\"hljs-keyword\">if</span>(c1!==c2){\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">parseInt</span>(str.padEnd(<span class=\"hljs-number\">31</span>,<span class=\"hljs-number\">0</span>),<span class=\"hljs-number\">2</span>)\n    }<span class=\"hljs-keyword\">else</span>{\n      <span class=\"hljs-keyword\">if</span>(c1===<span class=\"hljs-number\">0</span>)str+=<span class=\"hljs-string\">'0'</span>\n      <span class=\"hljs-keyword\">else</span> str+=<span class=\"hljs-string\">\"1\"</span>\n    }\n  }\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">parseInt</span>(str,<span class=\"hljs-number\">2</span>)\n};\n</code></pre>\n"
  ],
  "titleSlug": "bitwise-and-of-numbers-range",
  "hasThinking": true,
  "thinking": "<hr>\n<p>思路：</p>\n<p>因为<code>n</code>和<code>m</code>最多<code>31</code>位，因此从左到右遍历它们每一个位置(31次)，按位与的规则是从m到n的每一个数的当前位置必须都是<code>1</code>，这个位置最后结果才能是<code>1</code>。</p>\n<p>如果当前位置<code>m</code>和<code>n</code>相等并且为<code>1</code>，最终结果此位置一定为<code>1</code>；</p>\n<p>如果当前位置<code>m</code>和<code>n</code>相等并且为<code>0</code>，最红结果此位置一定为<code>0</code>；</p>\n<p>如果当前位置<code>m</code>和<code>n</code>不相等，那么不需要再遍历了，后面的位置都是<code>0</code>。</p>\n<p>因为大的数<code>n</code>此位置一定为<code>1</code>，<code>m</code>这个位置一定是<code>0</code>(n&gt;=m)，从<code>m</code>到<code>n</code>的过程中，这个位置进位了，一旦发生进位，前面的每一位都要经过一次<code>0</code>，因此前面全部为<code>0</code>。</p>\n<p>最后将结果解析为数字。</p>\n",
  "content": "<p>给定范围 [m, n]，其中 0 &lt;= m &lt;= n &lt;= 2147483647，返回此范围内所有数字的按位与（包含 m, n 两端点）。</p>\n\n<p><strong>示例 1:&nbsp;</strong></p>\n\n<pre><strong>输入:</strong> [5,7]\n<strong>输出:</strong> 4</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre><strong>输入:</strong> [0,1]\n<strong>输出:</strong> 0</pre>\n"
}
