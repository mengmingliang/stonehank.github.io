{
  "code": [
    "<pre class=\"hljs\"><code><span class=\"hljs-comment\">/**\n * @param {number[]} arr\n * @return {number}\n */</span>\n<span class=\"hljs-keyword\">var</span> maxChunksToSorted = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">arr</span>) </span>{\n  <span class=\"hljs-comment\">// // 思路：排序后判断当前点，是否已经完成</span>\n  <span class=\"hljs-comment\">// // 当前点所对应的之前的索引是否已经全部出现</span>\n  <span class=\"hljs-comment\">// // 例如：21345 在1的位置，前面索引0和1都已经出现，可以分割</span>\n  <span class=\"hljs-comment\">// let aux=[]</span>\n  <span class=\"hljs-comment\">// for(let i=0;i&lt;arr.length;i++){</span>\n  <span class=\"hljs-comment\">//   aux[i]=[arr[i],i]</span>\n  <span class=\"hljs-comment\">// }</span>\n  <span class=\"hljs-comment\">// aux.sort((a,b)=&gt;{</span>\n  <span class=\"hljs-comment\">//   if(a[0]&lt;b[0])return -1</span>\n  <span class=\"hljs-comment\">//   else if(a[0]&gt;b[0])return 1</span>\n  <span class=\"hljs-comment\">//   else return a[1]-b[1]</span>\n  <span class=\"hljs-comment\">// })</span>\n  <span class=\"hljs-comment\">// let used=[]</span>\n  <span class=\"hljs-comment\">// let res=0</span>\n  <span class=\"hljs-comment\">// for(let i=0;i&lt;aux.length;i++){</span>\n  <span class=\"hljs-comment\">//   let [val,idx]=aux[i]</span>\n  <span class=\"hljs-comment\">//   used[idx]=true</span>\n  <span class=\"hljs-comment\">//   let part=true</span>\n  <span class=\"hljs-comment\">//   for(let j=0;j&lt;=i;j++){</span>\n  <span class=\"hljs-comment\">//     if(!used[j]){</span>\n  <span class=\"hljs-comment\">//       part=false</span>\n  <span class=\"hljs-comment\">//       break</span>\n  <span class=\"hljs-comment\">//     }</span>\n  <span class=\"hljs-comment\">//   }</span>\n  <span class=\"hljs-comment\">//   if(part)res++</span>\n  <span class=\"hljs-comment\">// }</span>\n  <span class=\"hljs-comment\">// return res</span>\n  \n  <span class=\"hljs-comment\">// 优化了上述的查看索引的方案，当这个点的左边的最大值&lt;=这个点右边的最小值</span>\n  <span class=\"hljs-comment\">// 说明这个点之前的索引已经完全出现。</span>\n  <span class=\"hljs-comment\">// O(n)</span>\n  <span class=\"hljs-keyword\">let</span> n = arr.length;\n  <span class=\"hljs-keyword\">let</span> maxOfLeft = []\n  <span class=\"hljs-keyword\">let</span> minOfRight = []\n\n  maxOfLeft[<span class=\"hljs-number\">0</span>] = arr[<span class=\"hljs-number\">0</span>];\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">1</span>; i &lt; n; i++) {\n      maxOfLeft[i] = <span class=\"hljs-built_in\">Math</span>.max(maxOfLeft[i<span class=\"hljs-number\">-1</span>], arr[i]);\n  }\n\n  minOfRight[n - <span class=\"hljs-number\">1</span>] = arr[n - <span class=\"hljs-number\">1</span>];\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = n - <span class=\"hljs-number\">2</span>; i &gt;= <span class=\"hljs-number\">0</span>; i--) {\n      minOfRight[i] = <span class=\"hljs-built_in\">Math</span>.min(minOfRight[i + <span class=\"hljs-number\">1</span>], arr[i]);\n  }\n  <span class=\"hljs-keyword\">let</span> res = <span class=\"hljs-number\">0</span>;\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>; i &lt; n - <span class=\"hljs-number\">1</span>; i++) {\n      <span class=\"hljs-keyword\">if</span> (maxOfLeft[i] &lt;= minOfRight[i + <span class=\"hljs-number\">1</span>]) res++;\n  }\n  <span class=\"hljs-keyword\">return</span> res + <span class=\"hljs-number\">1</span>;\n};\n</code></pre>\n"
  ],
  "titleSlug": "max-chunks-to-make-sorted-ii",
  "content": "<p><em>这个问题和&ldquo;最多能完成排序的块&rdquo;相似，但给定数组中的元素可以重复，输入数组最大长度为<code>2000</code>，其中的元素最大为<code>10**8</code>。</em></p>\n\n<p><code>arr</code>是一个可能包含<strong>重复元素</strong>的整数数组，我们将这个数组分割成几个&ldquo;块&rdquo;，并将这些块分别进行排序。之后再连接起来，使得连接的结果和按升序排序后的原数组相同。</p>\n\n<p>我们最多能将数组分成多少块？</p>\n\n<p><strong>示例&nbsp;1:</strong></p>\n\n<pre>\n<strong>输入:</strong> arr = [5,4,3,2,1]\n<strong>输出:</strong> 1\n<strong>解释:</strong>\n将数组分成2块或者更多块，都无法得到所需的结果。\n例如，分成 [5, 4], [3, 2, 1] 的结果是 [4, 5, 1, 2, 3]，这不是有序的数组。 \n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> arr = [2,1,3,4,4]\n<strong>输出:</strong> 4\n<strong>解释:</strong>\n我们可以把它分成两块，例如 [2, 1], [3, 4, 4]。\n然而，分成 [2, 1], [3], [4], [4] 可以得到最多的块数。 \n</pre>\n\n<p><strong>注意:</strong></p>\n\n<ul>\n\t<li><code>arr</code>的长度在<code>[1, 2000]</code>之间。</li>\n\t<li><code>arr[i]</code>的大小在<code>[0, 10**8]</code>之间。</li>\n</ul>\n"
}
