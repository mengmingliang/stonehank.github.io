{
  "code": [
    "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public TreeNode addOneRow(TreeNode root, int v, int d) {\n        d=d-1;\n        if(d==0){\n            TreeNode newRoot=new TreeNode(v);\n            newRoot.left=root;\n            return newRoot;\n        }\n        TreeNode[] arr={root};\n        TreeNode[] aux=new TreeNode[100];\n        while(d>0 && arr.length>0){\n            for(int i=0;i<arr.length;i++){\n                if(d==1){\n                    TreeNode newL=new TreeNode(v);\n                    TreeNode newR=new TreeNode(v);\n                    newL.left=arr[i].left;\n                    newR.right=arr[i].right;\n                    arr[i].left=newL;\n                    arr[i].right=newR;\n                }else{\n                    if(arr[i].left!=null)aux[aux.length-1]=(arr[i].left);\n                    if(arr[i].right!=null)aux[aux.length-1]=(arr[i].right);\n                }\n            }\n            arr=aux;\n            aux=new TreeNode[100];\n            d--;\n        }\n        return root;\n    }\n}\n"
  ],
  "titleSlug": "add-one-row-to-tree",
  "content": "<p>Given the root of a binary tree, then value <code>v</code> and depth <code>d</code>, you need to add a row of nodes with value <code>v</code> at the given depth <code>d</code>. The root node is at depth 1. </p>\r\n\r\n<p>The adding rule is: given a positive integer depth <code>d</code>, for each NOT null tree nodes <code>N</code> in depth <code>d-1</code>, create two tree nodes with value <code>v</code> as <code>N's</code> left subtree root and right subtree root. And <code>N's</code> <b>original left subtree</b> should be the left subtree of the new left subtree root, its <b>original right subtree</b> should be the right subtree of the new right subtree root. If depth <code>d</code> is 1 that means there is no depth d-1 at all, then create a tree node with value <b>v</b> as the new root of the whole original tree, and the original tree is the new root's left subtree.</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> \r\nA binary tree as following:\r\n       4\r\n     /   \\\r\n    2     6\r\n   / \\   / \r\n  3   1 5   \r\n\r\n<b>v = 1</b>\r\n\r\n<b>d = 2</b>\r\n\r\n<b>Output:</b> \r\n       4\r\n      / \\\r\n     1   1\r\n    /     \\\r\n   2       6\r\n  / \\     / \r\n 3   1   5   \r\n\r\n</pre>\r\n</p>\r\n\r\n\r\n<p><b>Example 2:</b><br />\r\n<pre>\r\n<b>Input:</b> \r\nA binary tree as following:\r\n      4\r\n     /   \r\n    2    \r\n   / \\   \r\n  3   1    \r\n\r\n<b>v = 1</b>\r\n\r\n<b>d = 3</b>\r\n\r\n<b>Output:</b> \r\n      4\r\n     /   \r\n    2\r\n   / \\    \r\n  1   1\r\n /     \\  \r\n3       1\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b><br>\r\n<ol>\r\n<li>The given d is in range [1, maximum depth of the given tree + 1].</li>\r\n<li>The given binary tree has at least one tree node.</li>\r\n</ol>\r\n</p>",
  "translatedContent": "<p>给定一个二叉树，根节点为第1层，深度为 1。在其第&nbsp;<code>d</code>&nbsp;层追加一行值为&nbsp;<code>v</code>&nbsp;的节点。</p>\n\n<p>添加规则：给定一个深度值 <code>d</code> （正整数），针对深度为 <code>d-1</code> 层的每一<strong>非空</strong>节点 <code>N</code>，为 <code>N</code> 创建两个值为&nbsp;<code>v</code>&nbsp;的左子树和右子树。</p>\n\n<p>将&nbsp;<code>N</code> 原先的左子树，连接为新节点&nbsp;<code>v</code> 的左子树；将&nbsp;<code>N</code> 原先的右子树，连接为新节点&nbsp;<code>v</code> 的右子树。</p>\n\n<p>如果 <code>d</code> 的值为 1，深度 d - 1 不存在，则创建一个新的根节点 <code>v</code>，原先的整棵树将作为 <code>v</code> 的左子树。</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> \n二叉树如下所示:\n       4\n     /   \\\n    2     6\n   / \\   / \n  3   1 5   \n\n<strong>v = 1</strong>\n\n<strong>d = 2</strong>\n\n<strong>输出:</strong> \n       4\n      / \\\n     1   1\n    /     \\\n   2       6\n  / \\     / \n 3   1   5   \n\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> \n二叉树如下所示:\n      4\n     /   \n    2    \n   / \\   \n  3   1    \n\n<strong>v = 1</strong>\n\n<strong>d = 3</strong>\n\n<strong>输出:</strong> \n      4\n     /   \n    2\n   / \\    \n  1   1\n /     \\  \n3       1\n</pre>\n\n<p><strong>注意:</strong></p>\n\n<ol>\n\t<li>输入的深度值 d 的范围是：[1，二叉树最大深度 + 1]。</li>\n\t<li>输入的二叉树至少有一个节点。</li>\n</ol>\n"
}
