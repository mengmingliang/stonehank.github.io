{
  "code": [
    "<pre class=\"hljs\"><code><span class=\"hljs-comment\">/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */</span>\n<span class=\"hljs-comment\">/**\n * @param {TreeNode} root\n * @param {number} v\n * @param {number} d\n * @return {TreeNode}\n */</span>\n<span class=\"hljs-keyword\">var</span> addOneRow = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">root, v, d</span>) </span>{\n    d=d<span class=\"hljs-number\">-1</span>\n    <span class=\"hljs-keyword\">if</span>(d===<span class=\"hljs-number\">0</span>){\n        <span class=\"hljs-keyword\">let</span> newR=<span class=\"hljs-keyword\">new</span> TreeNode(v)\n        newR.left=root\n        <span class=\"hljs-keyword\">return</span> newR\n    }\n    <span class=\"hljs-keyword\">let</span> arr=[root]\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">bsf</span>(<span class=\"hljs-params\">arr</span>)</span>{\n        <span class=\"hljs-keyword\">let</span> aux=[]\n        <span class=\"hljs-keyword\">while</span>(d&gt;<span class=\"hljs-number\">0</span> &amp;&amp; arr.length&gt;<span class=\"hljs-number\">0</span> ){\n            <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i=<span class=\"hljs-number\">0</span>;i&lt;arr.length;i++){\n                <span class=\"hljs-keyword\">if</span>(d===<span class=\"hljs-number\">1</span>){\n                    <span class=\"hljs-keyword\">let</span> nowL=<span class=\"hljs-keyword\">new</span> TreeNode(v)\n                   <span class=\"hljs-keyword\">let</span> nowR=<span class=\"hljs-keyword\">new</span> TreeNode(v)\n                    nowL.left=arr[i].left\n                    nowR.right=arr[i].right\n                    arr[i].left=nowL\n                    arr[i].right=nowR\n                }<span class=\"hljs-keyword\">else</span>{\n                    <span class=\"hljs-keyword\">if</span>(arr[i].left)aux.push(arr[i].left)\n                    <span class=\"hljs-keyword\">if</span>(arr[i].right)aux.push(arr[i].right)\n                }\n            }\n            d--\n            arr=aux\n            aux=[]\n        }\n    }\n    bsf(arr)\n    <span class=\"hljs-keyword\">return</span> root\n};\n</code></pre>\n",
    "<pre class=\"hljs\"><code><span class=\"hljs-comment\">/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Solution</span> </span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> TreeNode <span class=\"hljs-title\">addOneRow</span><span class=\"hljs-params\">(TreeNode root, <span class=\"hljs-keyword\">int</span> v, <span class=\"hljs-keyword\">int</span> d)</span> </span>{\n        d=d-<span class=\"hljs-number\">1</span>;\n        <span class=\"hljs-keyword\">if</span>(d==<span class=\"hljs-number\">0</span>){\n            TreeNode newRoot=<span class=\"hljs-keyword\">new</span> TreeNode(v);\n            newRoot.left=root;\n            <span class=\"hljs-keyword\">return</span> newRoot;\n        }\n        TreeNode[] arr={root};\n        TreeNode[] aux=<span class=\"hljs-keyword\">new</span> TreeNode[<span class=\"hljs-number\">100</span>];\n        <span class=\"hljs-keyword\">while</span>(d&gt;<span class=\"hljs-number\">0</span> &amp;&amp; arr.length&gt;<span class=\"hljs-number\">0</span>){\n            <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;arr.length;i++){\n                <span class=\"hljs-keyword\">if</span>(d==<span class=\"hljs-number\">1</span>){\n                    TreeNode newL=<span class=\"hljs-keyword\">new</span> TreeNode(v);\n                    TreeNode newR=<span class=\"hljs-keyword\">new</span> TreeNode(v);\n                    newL.left=arr[i].left;\n                    newR.right=arr[i].right;\n                    arr[i].left=newL;\n                    arr[i].right=newR;\n                }<span class=\"hljs-keyword\">else</span>{\n                    <span class=\"hljs-keyword\">if</span>(arr[i].left!=<span class=\"hljs-keyword\">null</span>)aux[aux.length-<span class=\"hljs-number\">1</span>]=(arr[i].left);\n                    <span class=\"hljs-keyword\">if</span>(arr[i].right!=<span class=\"hljs-keyword\">null</span>)aux[aux.length-<span class=\"hljs-number\">1</span>]=(arr[i].right);\n                }\n            }\n            arr=aux;\n            aux=<span class=\"hljs-keyword\">new</span> TreeNode[<span class=\"hljs-number\">100</span>];\n            d--;\n        }\n        <span class=\"hljs-keyword\">return</span> root;\n    }\n}\n\n</code></pre>\n"
  ],
  "titleSlug": "add-one-row-to-tree",
  "content": "<p>给定一个二叉树，根节点为第1层，深度为 1。在其第&nbsp;<code>d</code>&nbsp;层追加一行值为&nbsp;<code>v</code>&nbsp;的节点。</p>\n\n<p>添加规则：给定一个深度值 <code>d</code> （正整数），针对深度为 <code>d-1</code> 层的每一<strong>非空</strong>节点 <code>N</code>，为 <code>N</code> 创建两个值为&nbsp;<code>v</code>&nbsp;的左子树和右子树。</p>\n\n<p>将&nbsp;<code>N</code> 原先的左子树，连接为新节点&nbsp;<code>v</code> 的左子树；将&nbsp;<code>N</code> 原先的右子树，连接为新节点&nbsp;<code>v</code> 的右子树。</p>\n\n<p>如果 <code>d</code> 的值为 1，深度 d - 1 不存在，则创建一个新的根节点 <code>v</code>，原先的整棵树将作为 <code>v</code> 的左子树。</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> \n二叉树如下所示:\n       4\n     /   \\\n    2     6\n   / \\   / \n  3   1 5   \n\n<strong>v = 1</strong>\n\n<strong>d = 2</strong>\n\n<strong>输出:</strong> \n       4\n      / \\\n     1   1\n    /     \\\n   2       6\n  / \\     / \n 3   1   5   \n\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> \n二叉树如下所示:\n      4\n     /   \n    2    \n   / \\   \n  3   1    \n\n<strong>v = 1</strong>\n\n<strong>d = 3</strong>\n\n<strong>输出:</strong> \n      4\n     /   \n    2\n   / \\    \n  1   1\n /     \\  \n3       1\n</pre>\n\n<p><strong>注意:</strong></p>\n\n<ol>\n\t<li>输入的深度值 d 的范围是：[1，二叉树最大深度 + 1]。</li>\n\t<li>输入的二叉树至少有一个节点。</li>\n</ol>\n"
}
