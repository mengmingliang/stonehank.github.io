{
  "code": [
    "/**\n * @param {number[][]} times\n * @param {number} N\n * @param {number} K\n * @return {number}\n */\nvar networkDelayTime = function(times, N, K) {\n    let graph=[]\n    for(let i=0;i<N+1;i++){\n      graph[i]=[]\n    }\n    for(let i=0;i<times.length;i++){\n        let v=times[i][0],\n            w=times[i][1],\n            weight=times[i][2]\n        graph[v].push([w,weight])\n    }\n    \n  let distTo=[]\n  let queue=[]\n  let marked=[]\n  let V=N+1\n  for(let i=0;i<V;i++){\n    distTo[i]=Infinity\n    marked[i]=false\n  }\n  distTo[K]=0\n\n  queue.push(K)\n  while(queue.length>0){\n    let len=queue.length\n    for(let i=0;i<len;i++){\n      let from=queue.pop()\n      if(marked[from])continue\n      marked[from]=true\n      let adj=graph[from]\n      if(adj.length===0){\n        if(from!==N && from!==1)return -1\n        else continue\n      }\n      for(let j=0;j<adj.length;j++){\n        let to=adj[j][0],weight=adj[j][1]\n        if(!queue.includes(to)){\n          queue.push(to)\n        }\n        if(distTo[from]+weight<distTo[to]){\n          distTo[to]=distTo[from]+weight\n          if(marked[to])marked[to]=false\n        }\n      }\n    }\n  }\n  let max=-1\n  for(let i=1;i<distTo.length;i++){\n    if(i===K)continue\n    max=Math.max(max,distTo[i])\n  }\n  return max===Infinity?-1:max\n};"
  ],
  "titleSlug": "network-delay-time",
  "content": "<p>\r\nThere are <code>N</code> network nodes, labelled <code>1</code> to <code>N</code>.\r\n</p><p>\r\nGiven <code>times</code>, a list of travel times as <b>directed</b> edges <code>times[i] = (u, v, w)</code>, where <code>u</code> is the source node, <code>v</code> is the target node, and <code>w</code> is the time it takes for a signal to travel from source to target.\r\n</p><p>\r\nNow, we send a signal from a certain node <code>K</code>.  How long will it take for all nodes to receive the signal?  If it is impossible, return <code>-1</code>.\r\n</p>\r\n\r\n<p><b>Note:</b><br>\r\n<ol>\r\n<li><code>N</code> will be in the range <code>[1, 100]</code>.</li>\r\n<li><code>K</code> will be in the range <code>[1, N]</code>.</li>\r\n<li>The length of <code>times</code> will be in the range <code>[1, 6000]</code>.</li>\r\n<li>All edges <code>times[i] = (u, v, w)</code> will have <code>1 <= u, v <= N</code> and <code>1 <= w <= 100</code>.</li>\r\n</ol>\r\n</p>",
  "translatedContent": "<p>有&nbsp;<code>N</code>&nbsp;个网络节点，标记为&nbsp;<code>1</code>&nbsp;到&nbsp;<code>N</code>。</p>\n\n<p>给定一个列表&nbsp;<code>times</code>，表示信号经过<strong>有向</strong>边的传递时间。&nbsp;<code>times[i] = (u, v, w)</code>，其中&nbsp;<code>u</code>&nbsp;是源节点，<code>v</code>&nbsp;是目标节点， <code>w</code>&nbsp;是一个信号从源节点传递到目标节点的时间。</p>\n\n<p>现在，我们向当前的节点&nbsp;<code>K</code>&nbsp;发送了一个信号。需要多久才能使所有节点都收到信号？如果不能使所有节点收到信号，返回&nbsp;<code>-1</code>。</p>\n\n<p><strong>注意:</strong></p>\n\n<ol>\n\t<li><code>N</code>&nbsp;的范围在&nbsp;<code>[1, 100]</code>&nbsp;之间。</li>\n\t<li><code>K</code>&nbsp;的范围在&nbsp;<code>[1, N]</code>&nbsp;之间。</li>\n\t<li><code>times</code>&nbsp;的长度在&nbsp;<code>[1, 6000]</code>&nbsp;之间。</li>\n\t<li>所有的边&nbsp;<code>times[i] = (u, v, w)</code>&nbsp;都有&nbsp;<code>1 &lt;= u, v &lt;= N</code>&nbsp;且&nbsp;<code>1 &lt;= w &lt;= 100</code>。</li>\n</ol>\n"
}
