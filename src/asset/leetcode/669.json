{
  "code": [
    "/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {number} L\n * @param {number} R\n * @return {TreeNode}\n */\nvar trimBST = function(root, L, R) {\n    if(root===null){return null}\n    if(root.val<L){return trimBST(root.right,L,R)}\n    if(root.val>R){return trimBST(root.left,L,R)}\n    \n    root.left=trimBST(root.left,L,R)\n    root.right=trimBST(root.right,L,R)\n    return root\n};"
  ],
  "titleSlug": "trim-a-binary-search-tree",
  "content": "<p>\r\nGiven a binary search tree and the lowest and highest boundaries as <code>L</code> and <code>R</code>, trim the tree so that all its elements lies in <code>[L, R]</code> (R >= L). You might need to change the root of the tree, so the result should return the new root of the trimmed binary search tree.\r\n</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> \r\n    1\r\n   / \\\r\n  0   2\r\n\r\n  L = 1\r\n  R = 2\r\n\r\n<b>Output:</b> \r\n    1\r\n      \\\r\n       2\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 2:</b><br />\r\n<pre>\r\n<b>Input:</b> \r\n    3\r\n   / \\\r\n  0   4\r\n   \\\r\n    2\r\n   /\r\n  1\r\n\r\n  L = 1\r\n  R = 3\r\n\r\n<b>Output:</b> \r\n      3\r\n     / \r\n   2   \r\n  /\r\n 1\r\n</pre>\r\n</p>",
  "translatedContent": "<p>给定一个二叉搜索树，同时给定最小边界<code>L</code>&nbsp;和最大边界&nbsp;<code>R</code>。通过修剪二叉搜索树，使得所有节点的值在<code>[L, R]</code>中 (R&gt;=L) 。你可能需要改变树的根节点，所以结果应当返回修剪好的二叉搜索树的新的根节点。</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> \n    1\n   / \\\n  0   2\n\n  L = 1\n  R = 2\n\n<strong>输出:</strong> \n    1\n      \\\n       2\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> \n    3\n   / \\\n  0   4\n   \\\n    2\n   /\n  1\n\n  L = 1\n  R = 3\n\n<strong>输出:</strong> \n      3\n     / \n   2   \n  /\n 1\n</pre>\n"
}
