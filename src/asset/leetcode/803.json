{
  "code": [
    "<pre class=\"hljs\"><code><span class=\"hljs-comment\">/**\n * @param {number[][]} grid\n * @param {number[][]} hits\n * @return {number[]}\n */</span>\n<span class=\"hljs-keyword\">var</span> hitBricks = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">grid, hits</span>) </span>{\n  <span class=\"hljs-keyword\">if</span> (!hits || !grid) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">null</span>;\n  <span class=\"hljs-keyword\">let</span> row=grid.length,col=grid[<span class=\"hljs-number\">0</span>].length;\n  <span class=\"hljs-keyword\">let</span> moves=[[<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">0</span>],[<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">1</span>],[<span class=\"hljs-number\">-1</span>,<span class=\"hljs-number\">0</span>],[<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">-1</span>]]\n  <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> [x,y] <span class=\"hljs-keyword\">of</span> hits){\n    <span class=\"hljs-keyword\">if</span>(grid[x][y]!==<span class=\"hljs-number\">0</span>) grid[x][y] = <span class=\"hljs-number\">-1</span>;\n  }\n  \n  <span class=\"hljs-comment\">// 击碎砖块后，所有与顶端连通的变为2</span>\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i=<span class=\"hljs-number\">0</span>;i&lt;col;i++){\n    dfs(<span class=\"hljs-number\">0</span>,i);\n  }\n    \n  <span class=\"hljs-keyword\">var</span> results = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Array</span>(hits.length);\n  <span class=\"hljs-comment\">// 逆序修复</span>\n  <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i=hits.length<span class=\"hljs-number\">-1</span>;i&gt;=<span class=\"hljs-number\">0</span>;i--) {\n    <span class=\"hljs-keyword\">let</span> [x,y]=hits[i]\n    <span class=\"hljs-keyword\">if</span> (grid[x][y]===<span class=\"hljs-number\">0</span>) results[i] = <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-keyword\">else</span> {\n      grid[x][y] = <span class=\"hljs-number\">1</span>;\n      <span class=\"hljs-comment\">// 当前x，y四周存在能与顶端连通的砖块</span>\n      <span class=\"hljs-keyword\">if</span> (attachedToRoof(x,y)){\n        <span class=\"hljs-comment\">// 计算剩下没和顶端连通的砖块，并且将它们与顶端连接</span>\n        results[i]=dfs(x,y) - <span class=\"hljs-number\">1</span>;\n      }<span class=\"hljs-keyword\">else</span>{\n        results[i] = <span class=\"hljs-number\">0</span>;\n      }\n    }\n  }\n  <span class=\"hljs-keyword\">return</span> results;\n  \n  <span class=\"hljs-comment\">// 对一个点，进行dfs，当这个点周围存在1砖块，将其设置为2(能与顶端相连)</span>\n  <span class=\"hljs-comment\">// 要求初始传入的点必须能与顶端相连</span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">dfs</span>(<span class=\"hljs-params\">x,y</span>) </span>{\n    <span class=\"hljs-keyword\">if</span> (grid[x][y] !== <span class=\"hljs-number\">1</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-keyword\">var</span> count = <span class=\"hljs-number\">1</span>;\n    grid[x][y] = <span class=\"hljs-number\">2</span>;\n    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> [dx,dy] <span class=\"hljs-keyword\">of</span> moves){\n      <span class=\"hljs-keyword\">let</span> newX=x+dx,newY=y+dy\n      <span class=\"hljs-keyword\">if</span>(newX&lt;<span class=\"hljs-number\">0</span> || newY&lt;<span class=\"hljs-number\">0</span> || newX&gt;=row || newY&gt;=col)<span class=\"hljs-keyword\">continue</span>\n      count+=dfs(newX,newY)\n    }\n    <span class=\"hljs-keyword\">return</span> count;\n  }\n  <span class=\"hljs-comment\">// 判断当前点周围是否存在2(能与顶端相连)</span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">attachedToRoof</span>(<span class=\"hljs-params\">x,y</span>) </span>{\n    <span class=\"hljs-keyword\">if</span>(x===<span class=\"hljs-number\">0</span>)<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>\n    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> [dx,dy] <span class=\"hljs-keyword\">of</span> moves){\n      <span class=\"hljs-keyword\">let</span> newX=x+dx,newY=y+dy\n      <span class=\"hljs-keyword\">if</span>(newX&lt;<span class=\"hljs-number\">0</span> || newY&lt;<span class=\"hljs-number\">0</span> || newX&gt;=row || newY&gt;=col)<span class=\"hljs-keyword\">continue</span>\n      <span class=\"hljs-keyword\">if</span>(grid[newX][newY]===<span class=\"hljs-number\">2</span>)<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>\n    }\n  }\n};\n\n</code></pre>\n"
  ],
  "titleSlug": "bricks-falling-when-hit",
  "hasThinking": true,
  "thinking": "<hr>\n<p>思路：</p>\n<p>先将所有要击碎的砖块击碎(设置为<code>-1</code>)，接着对当前状态将能与顶部连通的设置为<code>2</code>，这时候的<code>grid</code>就是最终状态。</p>\n<p>然后逆序遍历<code>hits</code>，</p>\n<p>如果当前位置是<code>0</code>，说明这个<code>hits[i]</code>击碎的位置没有砖块，返回<code>0</code>；</p>\n<p>检查当前位置周围，如果周围不存在<code>2</code>，说明即使恢复这个砖块，也不能连通到顶部；返回<code>0</code>；</p>\n<p>其他情况，逐个修复每一个砖块，并且计算修复当前砖块后，能增加连通到顶部(将<code>1</code>变为<code>2</code>)的砖块的数量。</p>\n",
  "content": "<p>我们有一组包含1和0的网格；其中1表示砖块。&nbsp;当且仅当一块砖直接连接到网格的顶部，或者它至少有一块相邻（4&nbsp;个方向之一）砖块不会掉落时，它才不会落下。</p>\n\n<p>我们会依次消除一些砖块。每当我们消除&nbsp;(i, j) 位置时， 对应位置的砖块（若存在）会消失，然后其他的砖块可能因为这个消除而落下。</p>\n\n<p>返回一个数组表示每次消除操作对应落下的砖块数目。</p>\n\n<pre><strong>示例 1：</strong>\n<strong>输入：</strong>\ngrid = [[1,0,0,0],[1,1,1,0]]\nhits = [[1,0]]\n<strong>输出:</strong> [2]\n<strong>解释: </strong>\n如果我们消除(1, 0)位置的砖块, 在(1, 1) 和(1, 2) 的砖块会落下。所以我们应该返回2。</pre>\n\n<pre><strong>示例 2：</strong>\n<strong>输入：</strong>\ngrid = [[1,0,0,0],[1,1,0,0]]\nhits = [[1,1],[1,0]]\n<strong>输出：</strong>[0,0]\n<strong>解释：</strong>\n当我们消除(1, 0)的砖块时，(1, 1)的砖块已经由于上一步消除而消失了。所以每次消除操作不会造成砖块落下。注意(1, 0)砖块不会记作落下的砖块。</pre>\n\n<p><strong>注意:</strong></p>\n\n<ul>\n\t<li>网格的行数和列数的范围是[1, 200]。</li>\n\t<li>消除的数字不会超过网格的区域。</li>\n\t<li>可以保证每次的消除都不相同，并且位于网格的内部。</li>\n\t<li>一个消除的位置可能没有砖块，如果这样的话，就不会有砖块落下。</li>\n</ul>\n"
}
