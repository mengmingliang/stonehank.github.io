{
  "code": [
    "/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {TreeNode}\n */\nvar subtreeWithAllDeepest = function(root) {\n    let binMap={}\n    let deep=[]\n    function addInMap(key,val){\n        if(!binMap[key]){\n            binMap[key]=[]\n        }\n        binMap[key].push(val)\n    }\n\n    function BFS(node){\n        let arr=[root]\n        while(arr.length>0){\n            let temp=[]\n            for(let i=0;i<arr.length;i++){\n                if(arr[i].left){\n                    temp.push(arr[i].left)\n                    // addInMap(arr[i].val,arr[i].left)\n                    addInMap(arr[i].left.val,arr[i])\n                }\n                if(arr[i].right){\n                    temp.push(arr[i].right)\n                    // addInMap(arr[i].val,arr[i].right)\n                    addInMap(arr[i].right.val,arr[i])\n                }\n            }\n            if(temp.length===0){\n                deep=arr\n            }\n            arr=temp;\n        }\n    }\n    BFS(root)\n    function findFather(deep){\n        if(deep.length===1)return deep[0]\n        deep=deep.map(node=>\n            binMap[node.val][0]\n        )\n        if(deep.filter(node=>node.val===deep[0].val).length===deep.length){\n            return deep[0]\n        }else{\n            return findFather(deep)\n        }\n        return false\n    }\n    return findFather(deep)\n\n};"
  ],
  "titleSlug": "smallest-subtree-with-all-the-deepest-nodes",
  "content": "<p>Given a binary tree rooted at <code>root</code>, the <em>depth</em> of each node is the shortest distance to the root.</p>\r\n\r\n<p>A node is <em>deepest</em> if it has the largest depth possible among&nbsp;any node in the <u>entire tree</u>.</p>\r\n\r\n<p>The subtree of a node is that node, plus the set of all descendants of that node.</p>\r\n\r\n<p>Return the node with the largest depth such that it contains all the deepest nodes in its subtree.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-1-1\">[3,5,1,6,2,0,8,null,null,7,4]</span>\r\n<strong>Output: </strong><span id=\"example-output-1\">[2,7,4]</span>\r\n<strong>Explanation:\r\n</strong>\r\n<img alt=\"\" src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/01/sketch1.png\" style=\"width: 280px; height: 238px;\" />\r\n\r\nWe return the node with value 2, colored in yellow in the diagram.\r\nThe nodes colored in blue are the deepest nodes of the tree.\r\nThe input &quot;[3, 5, 1, 6, 2, 0, 8, null, null, 7, 4]&quot; is a serialization of the given tree.\r\nThe output &quot;[2, 7, 4]&quot; is a serialization of the subtree rooted at the node with value 2.\r\nBoth the input and output have TreeNode type.\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ul>\r\n\t<li>The number of nodes in the tree will be between 1 and 500.</li>\r\n\t<li>The values of each node are unique.</li>\r\n</ul>\r\n",
  "translatedContent": "<p>给定一个根为&nbsp;<code>root</code>&nbsp;的二叉树，每个结点的<em>深度</em>是它到根的最短距离。</p>\n\n<p>如果一个结点在<strong>整个树</strong>的任意结点之间具有最大的深度，则该结点是<em>最深的</em>。</p>\n\n<p>一个结点的子树是该结点加上它的所有后代的集合。</p>\n\n<p>返回能满足&ldquo;以该结点为根的子树中包含所有最深的结点&rdquo;这一条件的具有最大深度的结点。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre><strong>输入：</strong>[3,5,1,6,2,0,8,null,null,7,4]\n<strong>输出：</strong>[2,7,4]\n<strong>解释：</strong>\n<img alt=\"\" src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/01/sketch1.png\" style=\"height: 238px; width: 280px;\">\n我们返回值为 2 的结点，在图中用黄色标记。\n在图中用蓝色标记的是树的最深的结点。\n输入 &quot;[3, 5, 1, 6, 2, 0, 8, null, null, 7, 4]&quot; 是对给定的树的序列化表述。\n输出 &quot;[2, 7, 4]&quot; 是对根结点的值为 2 的子树的序列化表述。\n输入和输出都具有 TreeNode 类型。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中结点的数量介于&nbsp;1 和&nbsp;500 之间。</li>\n\t<li>每个结点的值都是独一无二的。</li>\n</ul>\n"
}
