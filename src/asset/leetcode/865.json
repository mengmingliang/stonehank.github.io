{
  "code": [
    "<pre class=\"hljs\"><code><span class=\"hljs-comment\">/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */</span>\n<span class=\"hljs-comment\">/**\n * @param {TreeNode} root\n * @return {TreeNode}\n */</span>\n<span class=\"hljs-keyword\">var</span> subtreeWithAllDeepest = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">root</span>) </span>{\n  <span class=\"hljs-keyword\">let</span> max=<span class=\"hljs-number\">-1</span>,res=<span class=\"hljs-literal\">null</span>\n  dfs(root,<span class=\"hljs-number\">0</span>)\n  <span class=\"hljs-keyword\">return</span> res\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">dfs</span>(<span class=\"hljs-params\">root,h</span>)</span>{\n    <span class=\"hljs-keyword\">if</span>(!root)<span class=\"hljs-keyword\">return</span> h\n    <span class=\"hljs-keyword\">let</span> l=dfs(root.left,h+<span class=\"hljs-number\">1</span>),\n        r=dfs(root.right,h+<span class=\"hljs-number\">1</span>)\n    <span class=\"hljs-comment\">// console.log(root.val,l,r)</span>\n    <span class=\"hljs-keyword\">if</span>(l===r &amp;&amp; l&gt;=max){\n      <span class=\"hljs-comment\">// console.log(root.val,l,r)</span>\n      max=l\n      res=root\n    }\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">Math</span>.max(l,r)\n  }\n};\n</code></pre>\n"
  ],
  "titleSlug": "smallest-subtree-with-all-the-deepest-nodes",
  "hasThinking": false,
  "content": "<p>给定一个根为&nbsp;<code>root</code>&nbsp;的二叉树，每个结点的<em>深度</em>是它到根的最短距离。</p>\n\n<p>如果一个结点在<strong>整个树</strong>的任意结点之间具有最大的深度，则该结点是<em>最深的</em>。</p>\n\n<p>一个结点的子树是该结点加上它的所有后代的集合。</p>\n\n<p>返回能满足&ldquo;以该结点为根的子树中包含所有最深的结点&rdquo;这一条件的具有最大深度的结点。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre><strong>输入：</strong>[3,5,1,6,2,0,8,null,null,7,4]\n<strong>输出：</strong>[2,7,4]\n<strong>解释：</strong>\n<img alt=\"\" src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/01/sketch1.png\" style=\"height: 238px; width: 280px;\">\n我们返回值为 2 的结点，在图中用黄色标记。\n在图中用蓝色标记的是树的最深的结点。\n输入 &quot;[3, 5, 1, 6, 2, 0, 8, null, null, 7, 4]&quot; 是对给定的树的序列化表述。\n输出 &quot;[2, 7, 4]&quot; 是对根结点的值为 2 的子树的序列化表述。\n输入和输出都具有 TreeNode 类型。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中结点的数量介于&nbsp;1 和&nbsp;500 之间。</li>\n\t<li>每个结点的值都是独一无二的。</li>\n</ul>\n"
}
