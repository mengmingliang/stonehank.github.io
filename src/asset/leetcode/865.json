{
  "code": [
    "<pre class=\"hljs\"><code><span class=\"hljs-comment\">/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */</span>\n<span class=\"hljs-comment\">/**\n * @param {TreeNode} root\n * @return {TreeNode}\n */</span>\n<span class=\"hljs-keyword\">var</span> subtreeWithAllDeepest = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">root</span>) </span>{\n    <span class=\"hljs-keyword\">let</span> binMap={}\n    <span class=\"hljs-keyword\">let</span> deep=[]\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">addInMap</span>(<span class=\"hljs-params\">key,val</span>)</span>{\n        <span class=\"hljs-keyword\">if</span>(!binMap[key]){\n            binMap[key]=[]\n        }\n        binMap[key].push(val)\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">BFS</span>(<span class=\"hljs-params\">node</span>)</span>{\n        <span class=\"hljs-keyword\">let</span> arr=[root]\n        <span class=\"hljs-keyword\">while</span>(arr.length&gt;<span class=\"hljs-number\">0</span>){\n            <span class=\"hljs-keyword\">let</span> temp=[]\n            <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i=<span class=\"hljs-number\">0</span>;i&lt;arr.length;i++){\n                <span class=\"hljs-keyword\">if</span>(arr[i].left){\n                    temp.push(arr[i].left)\n                    <span class=\"hljs-comment\">// addInMap(arr[i].val,arr[i].left)</span>\n                    addInMap(arr[i].left.val,arr[i])\n                }\n                <span class=\"hljs-keyword\">if</span>(arr[i].right){\n                    temp.push(arr[i].right)\n                    <span class=\"hljs-comment\">// addInMap(arr[i].val,arr[i].right)</span>\n                    addInMap(arr[i].right.val,arr[i])\n                }\n            }\n            <span class=\"hljs-keyword\">if</span>(temp.length===<span class=\"hljs-number\">0</span>){\n                deep=arr\n            }\n            arr=temp;\n        }\n    }\n    BFS(root)\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">findFather</span>(<span class=\"hljs-params\">deep</span>)</span>{\n        <span class=\"hljs-keyword\">if</span>(deep.length===<span class=\"hljs-number\">1</span>)<span class=\"hljs-keyword\">return</span> deep[<span class=\"hljs-number\">0</span>]\n        deep=deep.map(<span class=\"hljs-function\"><span class=\"hljs-params\">node</span>=&gt;</span>\n            binMap[node.val][<span class=\"hljs-number\">0</span>]\n        )\n        <span class=\"hljs-keyword\">if</span>(deep.filter(<span class=\"hljs-function\"><span class=\"hljs-params\">node</span>=&gt;</span>node.val===deep[<span class=\"hljs-number\">0</span>].val).length===deep.length){\n            <span class=\"hljs-keyword\">return</span> deep[<span class=\"hljs-number\">0</span>]\n        }<span class=\"hljs-keyword\">else</span>{\n            <span class=\"hljs-keyword\">return</span> findFather(deep)\n        }\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>\n    }\n    <span class=\"hljs-keyword\">return</span> findFather(deep)\n\n};\n</code></pre>\n"
  ],
  "titleSlug": "smallest-subtree-with-all-the-deepest-nodes",
  "translatedContent": "<p>给定一个根为&nbsp;<code>root</code>&nbsp;的二叉树，每个结点的<em>深度</em>是它到根的最短距离。</p>\n\n<p>如果一个结点在<strong>整个树</strong>的任意结点之间具有最大的深度，则该结点是<em>最深的</em>。</p>\n\n<p>一个结点的子树是该结点加上它的所有后代的集合。</p>\n\n<p>返回能满足&ldquo;以该结点为根的子树中包含所有最深的结点&rdquo;这一条件的具有最大深度的结点。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre><strong>输入：</strong>[3,5,1,6,2,0,8,null,null,7,4]\n<strong>输出：</strong>[2,7,4]\n<strong>解释：</strong>\n<img alt=\"\" src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/01/sketch1.png\" style=\"height: 238px; width: 280px;\">\n我们返回值为 2 的结点，在图中用黄色标记。\n在图中用蓝色标记的是树的最深的结点。\n输入 &quot;[3, 5, 1, 6, 2, 0, 8, null, null, 7, 4]&quot; 是对给定的树的序列化表述。\n输出 &quot;[2, 7, 4]&quot; 是对根结点的值为 2 的子树的序列化表述。\n输入和输出都具有 TreeNode 类型。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中结点的数量介于&nbsp;1 和&nbsp;500 之间。</li>\n\t<li>每个结点的值都是独一无二的。</li>\n</ul>\n"
}
