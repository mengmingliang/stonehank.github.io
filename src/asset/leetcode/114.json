{
  "code": [
    "<pre class=\"hljs\"><code><span class=\"hljs-comment\">/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */</span>\n<span class=\"hljs-comment\">/**\n * @param {TreeNode} root\n * @return {void} Do not return anything, modify root in-place instead.\n */</span>\n<span class=\"hljs-keyword\">var</span> flatten = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">root</span>) </span>{\n  <span class=\"hljs-keyword\">if</span>(!root)<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">null</span>\n  <span class=\"hljs-keyword\">let</span> l=root.left,\n      r=root.right\n  root.left=<span class=\"hljs-literal\">null</span>\n  root.right=flatten(l)\n  <span class=\"hljs-keyword\">let</span> node=root\n  <span class=\"hljs-keyword\">while</span>(node.right)node=node.right\n  node.right=flatten(r)\n  <span class=\"hljs-keyword\">return</span> root\n};\n</code></pre>\n"
  ],
  "titleSlug": "flatten-binary-tree-to-linked-list",
  "hasThinking": true,
  "thinking": "<hr>\n<p>思路：</p>\n<p>对于每个<code>root</code>节点，先将它的左子树和右子树分别保存为<code>l</code>和<code>r</code>；</p>\n<p>接着继续<code>flatten</code>它的左子树，将<code>flatten(l)</code>的结果作为<code>root</code>的新的右子树，因为<code>flatten(l)</code>已经是一个平铺的树，因此可以沿着它的右子树一直找到最后一个节点<code>node</code>，然后将<code>root</code>原来的右子树<code>r</code>，作为<code>node</code>的右子树连接起来。</p>\n",
  "content": "<p>给定一个二叉树，<a href=\"https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95/8010757\" target=\"_blank\">原地</a>将它展开为链表。</p>\n\n<p>例如，给定二叉树</p>\n\n<pre>    1\n   / \\\n  2   5\n / \\   \\\n3   4   6</pre>\n\n<p>将其展开为：</p>\n\n<pre>1\n \\\n  2\n   \\\n    3\n     \\\n      4\n       \\\n        5\n         \\\n          6</pre>\n"
}
