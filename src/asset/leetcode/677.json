{
  "code": [
    "<pre class=\"hljs\"><code><span class=\"hljs-comment\">/**\n * Initialize your data structure here.\n */</span>\n<span class=\"hljs-keyword\">var</span> MapSum = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">this</span>.tire={}\n};\n\n<span class=\"hljs-comment\">/** \n * @param {string} key \n * @param {number} val\n * @return {void}\n */</span>\nMapSum.prototype.insert = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">key, val</span>) </span>{\n  <span class=\"hljs-keyword\">let</span> t=<span class=\"hljs-keyword\">this</span>.tire\n  <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i=<span class=\"hljs-number\">0</span>;i&lt;key.length;i++){\n    <span class=\"hljs-keyword\">let</span> l=key[i]\n    <span class=\"hljs-keyword\">if</span>(t[l]==<span class=\"hljs-literal\">null</span>)t[l]={}\n    <span class=\"hljs-keyword\">if</span>(i===key.length<span class=\"hljs-number\">-1</span>)t[l].val=val\n    t=t[l]\n  }\n};\n\n<span class=\"hljs-comment\">/** \n * @param {string} prefix\n * @return {number}\n */</span>\nMapSum.prototype.sum = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">prefix</span>) </span>{\n  <span class=\"hljs-keyword\">let</span> sum=<span class=\"hljs-number\">0</span>,t=<span class=\"hljs-keyword\">this</span>.tire\n  <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i=<span class=\"hljs-number\">0</span>;i&lt;prefix.length;i++){\n    <span class=\"hljs-keyword\">let</span> l=prefix[i]\n    <span class=\"hljs-keyword\">if</span>(t[l]==<span class=\"hljs-literal\">null</span>)<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>\n    t=t[l]\n    <span class=\"hljs-keyword\">if</span>(i===prefix.length<span class=\"hljs-number\">-1</span>){\n      sum+=dfs(t)\n    }\n  }\n  <span class=\"hljs-keyword\">return</span> sum\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">dfs</span>(<span class=\"hljs-params\">t</span>)</span>{\n    <span class=\"hljs-keyword\">if</span>(!t)<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>\n    <span class=\"hljs-keyword\">let</span> s=<span class=\"hljs-number\">0</span>\n    <span class=\"hljs-keyword\">if</span>(t.val!=<span class=\"hljs-literal\">null</span>)s+=t.val\n    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> k <span class=\"hljs-keyword\">in</span> t){\n      s+=dfs(t[k])\n    }\n    <span class=\"hljs-keyword\">return</span> s\n  }\n};\n\n<span class=\"hljs-comment\">/** \n * Your MapSum object will be instantiated and called as such:\n * var obj = new MapSum()\n * obj.insert(key,val)\n * var param_2 = obj.sum(prefix)\n */</span>\n</code></pre>\n"
  ],
  "titleSlug": "map-sum-pairs",
  "hasThinking": true,
  "thinking": "<hr>\n<p>思路：</p>\n<p>建立<code>tire</code>树，每次<code>insert</code>的时候，对当前<code>key</code>的每个字母逐个遍历，建立<code>tire</code>的分支，到最后一个字母，添加<code>tire.val=val</code>。</p>\n<p>每次<code>sum</code>的时候，逐个遍历<code>tire</code>，如果当前分支<code>tire[key[i]]</code>不存在，说明无法匹配到这个前缀，返回<code>0</code>，当前缀成功匹配，接着<code>dfs</code>\n找出前缀之后的所有单词的<code>val</code>。</p>\n",
  "content": "<p>实现一个 MapSum 类里的两个方法，<code>insert</code>&nbsp;和&nbsp;<code>sum</code>。</p>\n\n<p>对于方法&nbsp;<code>insert</code>，你将得到一对（字符串，整数）的键值对。字符串表示键，整数表示值。如果键已经存在，那么原来的键值对将被替代成新的键值对。</p>\n\n<p>对于方法 <code>sum</code>，你将得到一个表示前缀的字符串，你需要返回所有以该前缀开头的键的值的总和。</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>输入: insert(&quot;apple&quot;, 3), 输出: Null\n输入: sum(&quot;ap&quot;), 输出: 3\n输入: insert(&quot;app&quot;, 2), 输出: Null\n输入: sum(&quot;ap&quot;), 输出: 5\n</pre>\n"
}
