{
  "code": [
    "<pre class=\"hljs\"><code><span class=\"hljs-comment\">/**\n * @param {number[]} A\n * @return {boolean}\n */</span>\n<span class=\"hljs-keyword\">var</span> isIdealPermutation = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">A</span>) </span>{\n        <span class=\"hljs-keyword\">let</span> cmax = <span class=\"hljs-number\">0</span>;\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>; i &lt; A.length - <span class=\"hljs-number\">2</span>; ++i) {\n            cmax = <span class=\"hljs-built_in\">Math</span>.max(cmax, A[i]);\n            <span class=\"hljs-comment\">// 当符合这个条件，global能获取，local 必定不能获取，因为中间隔了一个位置</span>\n            <span class=\"hljs-keyword\">if</span> (cmax &gt; A[i + <span class=\"hljs-number\">2</span>]) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\n        }\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\n};\n</code></pre>\n"
  ],
  "titleSlug": "global-and-local-inversions",
  "thinking": "<hr>\n<p>思路：</p>\n<ol>\n<li>\n<p>最初看到问题的想法是将全局倒置数量和局部倒置数量都计算出来，最后对比，但是<code>TLE</code>了，这么做时间复杂度是<code>O(N^2)</code>。</p>\n</li>\n<li>\n<p>其实仔细一思考，一旦发现存在全局倒置，就可以立刻返回<code>false</code>了，因此有局部倒置必然有全局倒置，而有全局倒置不一定有局部倒置。</p>\n</li>\n<li>\n<p>遍历的时候将遍历过的最大值保存，一旦发现当前值小于这个最大值，说明存在额外的全局倒置，最终时间复杂度是<code>O(N)</code>。</p>\n</li>\n</ol>\n",
  "content": "<p>数组&nbsp;<code>A</code>&nbsp;是&nbsp;<code>[0, 1, ..., N - 1]</code>&nbsp;的一种排列，<code>N</code> 是数组&nbsp;<code>A</code>&nbsp;的长度。全局倒置指的是 <code>i,j</code>&nbsp;满足&nbsp;<code>0 &lt;= i &lt; j &lt; N</code> 并且&nbsp;<code>A[i] &gt; A[j]</code>&nbsp;，局部倒置指的是 <code>i</code> 满足&nbsp;<code>0 &lt;= i &lt; N</code>&nbsp;并且&nbsp;<code>A[i] &gt; A[i+1]</code>&nbsp;。</p>\n\n<p>当数组&nbsp;<code>A</code>&nbsp;中全局倒置的数量等于局部倒置的数量时，返回 <code>true</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> A = [1,0,2]\n<strong>输出:</strong> true\n<strong>解释:</strong> 有 1 个全局倒置，和 1 个局部倒置。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> A = [1,2,0]\n<strong>输出:</strong> false\n<strong>解释:</strong> 有 2 个全局倒置，和 1 个局部倒置。\n</pre>\n\n<p><strong>注意:</strong></p>\n\n<ul>\n\t<li><code>A</code> 是&nbsp;<code>[0, 1, ..., A.length - 1]</code>&nbsp;的一种排列</li>\n\t<li><code>A</code> 的长度在&nbsp;<code>[1, 5000]</code>之间</li>\n\t<li>这个问题的时间限制已经减少了。</li>\n</ul>\n",
  "hasThinking": true
}
