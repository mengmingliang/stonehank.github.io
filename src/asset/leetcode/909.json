{
  "code": [
    "<pre class=\"hljs\"><code><span class=\"hljs-comment\">/**\n * @param {number[][]} board\n * @return {number}\n */</span>\n<span class=\"hljs-keyword\">var</span> snakesAndLadders = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">board</span>) </span>{\n  <span class=\"hljs-keyword\">let</span> N=board.length\n  <span class=\"hljs-keyword\">let</span> visited=<span class=\"hljs-built_in\">Array</span>(N*N+<span class=\"hljs-number\">1</span>).fill(<span class=\"hljs-literal\">false</span>)\n  visited[<span class=\"hljs-number\">1</span>]=<span class=\"hljs-literal\">true</span>\n  <span class=\"hljs-keyword\">let</span> arr=[<span class=\"hljs-number\">1</span>], step=<span class=\"hljs-number\">0</span>\n  <span class=\"hljs-keyword\">while</span>(arr.length&gt;<span class=\"hljs-number\">0</span>){\n    <span class=\"hljs-keyword\">let</span> len=arr.length\n    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i=<span class=\"hljs-number\">0</span>;i&lt;len;i++){\n      <span class=\"hljs-keyword\">let</span> num=arr.shift()\n      <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> n =<span class=\"hljs-number\">1</span>;n&lt;=<span class=\"hljs-number\">6</span>;n++){\n        <span class=\"hljs-keyword\">let</span> curNum=num+n\n        <span class=\"hljs-keyword\">if</span>(curNum&gt;N*N)<span class=\"hljs-keyword\">break</span>\n        <span class=\"hljs-keyword\">if</span>(curNum===N*N)<span class=\"hljs-keyword\">return</span> step+<span class=\"hljs-number\">1</span>\n        <span class=\"hljs-keyword\">if</span>(visited[curNum])<span class=\"hljs-keyword\">continue</span>\n        visited[curNum]=<span class=\"hljs-literal\">true</span>\n        <span class=\"hljs-keyword\">let</span> [x,y]=num2Pos(curNum)\n        <span class=\"hljs-keyword\">if</span>(board[x][y]!==<span class=\"hljs-number\">-1</span>){\n          <span class=\"hljs-keyword\">if</span>(board[x][y]===N*N)<span class=\"hljs-keyword\">return</span> step+<span class=\"hljs-number\">1</span>\n          arr.push(board[x][y])\n        }<span class=\"hljs-keyword\">else</span>{\n          arr.push(curNum)\n        }\n      }\n    }\n    step++\n  }\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>\n  \n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">num2Pos</span>(<span class=\"hljs-params\">num</span>)</span>{\n    <span class=\"hljs-keyword\">let</span> delta=num<span class=\"hljs-number\">-1</span>,\n        dx=<span class=\"hljs-built_in\">Math</span>.floor(delta/N),\n        x=N-dx<span class=\"hljs-number\">-1</span>,\n        y=delta % N\n    <span class=\"hljs-keyword\">if</span>(dx % <span class=\"hljs-number\">2</span>===<span class=\"hljs-number\">1</span>)y=N-y<span class=\"hljs-number\">-1</span>\n    <span class=\"hljs-keyword\">return</span> [x,y]\n  }\n};\n</code></pre>\n"
  ],
  "titleSlug": "snakes-and-ladders",
  "hasThinking": true,
  "thinking": "<hr>\n<p>思路：</p>\n<p>由于每一次爬梯上升或者下降的位置都是以棋盘编号显示，因此我们需要一种方法<code>num2Pos</code>能将编号转换为<code>横纵坐标</code>，然后从编号<code>1</code>开始，\n每次分别判断<code>+1</code>，<code>+2</code>，<code>+3</code>，<code>+4</code>，<code>+5</code>，<code>+6</code>后6种情况的编号应该是多少</p>\n<p>如果编号<code>num</code>超过了<code>N*N</code>，说明越界了，<code>continue</code>；</p>\n<p>如果编号不是<code>-1</code>，那么说明这个位置是需要跳转的，更新编号为跳转的编号；</p>\n<p>如果编号已经达到<code>N*N</code>，说明到达终点，返回步数。</p>\n<p>最终无法完成返回<code>-1</code>。</p>\n",
  "content": "<p>在一块 N x N 的棋盘&nbsp;<code>board</code>&nbsp;上，<strong>从棋盘的左下角开始</strong>，每一行交替方向，按从&nbsp;<code>1</code> 到 <code>N*N</code>&nbsp;的数字给方格编号。例如，对于一块 6 x 6 大小的棋盘，可以编号如下：</p>\n\n<pre><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/01/31/snakes.png\" style=\"height: 200px; width: 254px;\">\n</pre>\n\n<p>玩家从棋盘上的方格&nbsp;<code>1</code> （总是在最后一行、第一列）开始出发。</p>\n\n<p>每一次从方格&nbsp;<code>x</code>&nbsp;起始的移动都由以下部分组成：</p>\n\n<ul>\n\t<li>你选择一个目标方块 <code>S</code>，它的编号是 <code>x+1</code>，<code>x+2</code>，<code>x+3</code>，<code>x+4</code>，<code>x+5</code>，或者 <code>x+6</code>，只要这个数字&nbsp;<code>&lt;= N*N</code>。</li>\n\t<li>如果 <code>S</code> 有一个蛇或梯子，你就移动到那个蛇或梯子的目的地。否则，你会移动到 <code>S</code>。&nbsp;</li>\n</ul>\n\n<p>在 <code>r</code> 行 <code>c</code> 列上的方格里有 &ldquo;蛇&rdquo; 或 &ldquo;梯子&rdquo;；如果 <code>board[r][c] != -1</code>，那个蛇或梯子的目的地将会是 <code>board[r][c]</code>。</p>\n\n<p>注意，你每次移动最多只能爬过蛇或梯子一次：就算目的地是另一条蛇或梯子的起点，你也不会继续移动。</p>\n\n<p>返回达到方格 N*N 所需的最少移动次数，如果不可能，则返回 <code>-1</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre><strong>输入：</strong>[\n[-1,-1,-1,-1,-1,-1],\n[-1,-1,-1,-1,-1,-1],\n[-1,-1,-1,-1,-1,-1],\n[-1,35,-1,-1,13,-1],\n[-1,-1,-1,-1,-1,-1],\n[-1,15,-1,-1,-1,-1]]\n<strong>输出：</strong>4\n<strong>解释：</strong>\n首先，从方格 1 [第 5 行，第 0 列] 开始。\n你决定移动到方格 2，并必须爬过梯子移动到到方格 15。\n然后你决定移动到方格 17 [第 3 行，第 5 列]，必须爬过蛇到方格 13。\n然后你决定移动到方格 14，且必须通过梯子移动到方格 35。\n然后你决定移动到方格 36, 游戏结束。\n可以证明你需要至少 4 次移动才能到达第 N*N 个方格，所以答案是 4。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ol>\n\t<li><code>2 &lt;= board.length = board[0].length&nbsp;&lt;= 20</code></li>\n\t<li><code>board[i][j]</code>&nbsp;介于&nbsp;<code>1</code>&nbsp;和&nbsp;<code>N*N</code>&nbsp;之间或者等于&nbsp;<code>-1</code>。</li>\n\t<li>编号为&nbsp;<code>1</code>&nbsp;的方格上没有蛇或梯子。</li>\n\t<li>编号为&nbsp;<code>N*N</code>&nbsp;的方格上没有蛇或梯子。</li>\n</ol>\n"
}
