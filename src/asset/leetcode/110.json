{
  "code": [
    "<pre class=\"hljs\"><code><span class=\"hljs-comment\">/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */</span>\n<span class=\"hljs-comment\">/**\n * @param {TreeNode} root\n * @return {boolean}\n */</span>\n<span class=\"hljs-keyword\">var</span> isBalanced = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">root</span>) </span>{\n  <span class=\"hljs-keyword\">let</span> isBal=<span class=\"hljs-literal\">true</span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">getHeight</span>(<span class=\"hljs-params\">root</span>)</span>{\n    <span class=\"hljs-keyword\">if</span>(!isBal)<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>\n    <span class=\"hljs-keyword\">if</span>(!root)<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>\n    <span class=\"hljs-keyword\">let</span> leftH=getHeight(root.left)+<span class=\"hljs-number\">1</span>,\n        rightH=getHeight(root.right)+<span class=\"hljs-number\">1</span>\n    <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-built_in\">Math</span>.abs(leftH-rightH)&gt;<span class=\"hljs-number\">1</span>){\n      isBal=<span class=\"hljs-literal\">false</span> \n    } \n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">Math</span>.max(leftH,rightH)\n  }\n  getHeight(root)\n  <span class=\"hljs-keyword\">return</span> isBal\n}\n</code></pre>\n"
  ],
  "titleSlug": "balanced-binary-tree",
  "hasThinking": true,
  "thinking": "<hr>\n<p>思路：</p>\n<ul>\n<li>自顶而下<code>O(n^2)</code></li>\n</ul>\n<p>对于每一个节点，计算它左子树的高度和右子树的高度，如果它们相差超过<code>1</code>，则不平衡。</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">var</span> isBalanced = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">root</span>) </span>{\n  <span class=\"hljs-keyword\">if</span>(!root)<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>\n  <span class=\"hljs-keyword\">let</span> leftH=getHeight(root.left),\n      rightH=getHeight(root.right)\n  <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-built_in\">Math</span>.abs(leftH-rightH)&gt;<span class=\"hljs-number\">1</span>)<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>\n  <span class=\"hljs-keyword\">return</span> isBalanced(root.left) &amp;&amp; isBalanced(root.right)\n};\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">getHeight</span>(<span class=\"hljs-params\">root</span>)</span>{\n  <span class=\"hljs-keyword\">if</span>(!root)<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">Math</span>.max(getHeight(root.left),getHeight(root.right))+<span class=\"hljs-number\">1</span>\n}\n</code></pre>\n<ul>\n<li>自底而上<code>O(n)</code></li>\n</ul>\n<p>后续遍历，对于每一个节点，比较左子树和右子树的高度。</p>\n<p>自底而上更高效的原因是后序遍历是从最底端节点开始，之后每一个父节点计算高度都无须重复计算子节点的高度。</p>\n",
  "content": "<p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p>\n\n<p>本题中，一棵高度平衡二叉树定义为：</p>\n\n<blockquote>\n<p>一个二叉树<em>每个节点&nbsp;</em>的左右两个子树的高度差的绝对值不超过1。</p>\n</blockquote>\n\n<p><strong>示例 1:</strong></p>\n\n<p>给定二叉树 <code>[3,9,20,null,null,15,7]</code></p>\n\n<pre>    3\n   / \\\n  9  20\n    /  \\\n   15   7</pre>\n\n<p>返回 <code>true</code> 。<br>\n<br>\n<strong>示例 2:</strong></p>\n\n<p>给定二叉树 <code>[1,2,2,3,3,null,null,4,4]</code></p>\n\n<pre>       1\n      / \\\n     2   2\n    / \\\n   3   3\n  / \\\n 4   4\n</pre>\n\n<p>返回&nbsp;<code>false</code> 。</p>\n"
}
