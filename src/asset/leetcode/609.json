{
  "code": [
    "<pre class=\"hljs\"><code><span class=\"hljs-comment\">/**\n * @param {string[]} paths\n * @return {string[][]}\n */</span>\n<span class=\"hljs-keyword\">var</span> findDuplicate = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">paths</span>) </span>{\n    <span class=\"hljs-keyword\">let</span> cache={}\n    <span class=\"hljs-keyword\">let</span> result=[]\n    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i=<span class=\"hljs-number\">0</span>;i&lt;paths.length;i++){\n        <span class=\"hljs-keyword\">let</span> listArr=paths[i].split(<span class=\"hljs-string\">' '</span>);\n        <span class=\"hljs-keyword\">let</span> root=listArr[<span class=\"hljs-number\">0</span>]\n        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> j=<span class=\"hljs-number\">1</span>;j&lt;listArr.length;j++){\n            <span class=\"hljs-keyword\">let</span> data=listArr[j].match(<span class=\"hljs-regexp\">/(.*)(\\(.*\\))/</span>)\n            <span class=\"hljs-keyword\">let</span> fileName=data[<span class=\"hljs-number\">1</span>], content=data[<span class=\"hljs-number\">2</span>]\n            <span class=\"hljs-keyword\">if</span>(!cache[content]){\n                cache[content]=[root+<span class=\"hljs-string\">'/'</span>+fileName]\n                result[result.length]=cache[content]\n            }<span class=\"hljs-keyword\">else</span>{\n                cache[content].push(root+<span class=\"hljs-string\">'/'</span>+fileName) \n            }\n            \n        }\n    }\n    <span class=\"hljs-keyword\">return</span> result.filter(<span class=\"hljs-function\"><span class=\"hljs-params\">n</span>=&gt;</span>n.length&gt;<span class=\"hljs-number\">1</span>)\n};\n</code></pre>\n"
  ],
  "titleSlug": "find-duplicate-file-in-system",
  "content": "<p>给定一个目录信息列表，包括目录路径，以及该目录中的所有包含内容的文件，您需要找到文件系统中的所有重复文件组的路径。一组重复的文件至少包括<strong>二个</strong>具有完全相同内容的文件。</p>\n\n<p><strong>输入</strong>列表中的单个目录信息字符串的格式如下：</p>\n\n<p><code>&quot;root/d1/d2/.../dm f1.txt(f1_content) f2.txt(f2_content) ... fn.txt(fn_content)&quot;</code></p>\n\n<p>这意味着<strong>n</strong>档案（<code>f1.txt</code>,&nbsp;<code>f2.txt</code>&nbsp;...&nbsp;<code>fn.txt</code>&nbsp;有内容&nbsp;<code>f1_content</code>,&nbsp;<code>f2_content</code>&nbsp;...&nbsp;<code>fn_content</code>（分别）在目录&nbsp;<code>root/d1/d2/.../dm</code> 中注意，n&gt;=1 和 m&gt;=0。如果 m=0，则表示该目录只是根目录。</p>\n\n<p>该<strong>输出</strong>是重复文件路径组的列表。对于每个组，它包含具有相同内容的文件的所有文件路径。文件路径是具有下列格式的字符串：</p>\n\n<p><code>&quot;directory_path/file_name.txt&quot;</code></p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>\n[&quot;root/a 1.txt(abcd) 2.txt(efgh)&quot;, &quot;root/c 3.txt(abcd)&quot;, &quot;root/c/d 4.txt(efgh)&quot;, &quot;root 4.txt(efgh)&quot;]\n<strong>输出：</strong>  \n[[&quot;root/a/2.txt&quot;,&quot;root/c/d/4.txt&quot;,&quot;root/4.txt&quot;],[&quot;root/a/1.txt&quot;,&quot;root/c/3.txt&quot;]]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>注：</strong></p>\n\n<ol>\n\t<li>最终输出不需要顺序。</li>\n\t<li>您可以假设目录名、文件名和文件内容只有字母和数字，并且文件内容的长度在 [1，50] 的范围内。</li>\n\t<li>给定的文件数量在 [1，20000] 个范围内。</li>\n\t<li>您可以假设在同一目录中没有任何文件或目录共享相同的名称。</li>\n\t<li>您可以假设每个给定的目录信息代表一个唯一的目录。目录路径和文件信息用一个空格分隔。</li>\n</ol>\n\n<p>&nbsp;</p>\n\n<p><strong>超越竞赛的后续行动：</strong></p>\n\n<ol>\n\t<li>假设您有一个真正的文件系统，您将如何搜索文件？广度搜索还是宽度搜索？</li>\n\t<li>如果文件内容非常大（GB级别），您将如何修改您的解决方案？</li>\n\t<li>如果每次只能读取 1 kb 的文件，您将如何修改解决方案？</li>\n\t<li>修改后的解决方案的时间复杂度是多少？其中最耗时的部分和消耗内存的部分是什么？如何优化？</li>\n\t<li>如何确保您发现的重复文件不是误报？</li>\n</ol>\n"
}
