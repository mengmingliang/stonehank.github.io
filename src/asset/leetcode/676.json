{
  "code": [
    "<pre class=\"hljs\"><code><span class=\"hljs-comment\">/**\n * Initialize your data structure here.\n */</span>\n<span class=\"hljs-keyword\">var</span> MagicDictionary = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">this</span>.dictArr=[]\n  <span class=\"hljs-keyword\">this</span>.check=<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">dictWord,word</span>)</span>{\n    <span class=\"hljs-keyword\">let</span> count=<span class=\"hljs-number\">0</span>\n    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i=<span class=\"hljs-number\">0</span>;i&lt;dictWord.length;i++){\n      <span class=\"hljs-keyword\">if</span>(dictWord[i]!==word[i]){\n        <span class=\"hljs-keyword\">if</span>(count===<span class=\"hljs-number\">1</span>)<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>\n        <span class=\"hljs-keyword\">else</span> count++\n      }\n    }\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>\n  }\n};\n\n<span class=\"hljs-comment\">/**\n * Build a dictionary through a list of words \n * @param {string[]} dict\n * @return {void}\n */</span>\nMagicDictionary.prototype.buildDict = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">dict</span>) </span>{\n  <span class=\"hljs-keyword\">this</span>.dictArr=dict\n};\n\n<span class=\"hljs-comment\">/**\n * Returns if there is any word in the trie that equals to the given word after modifying exactly one character \n * @param {string} word\n * @return {boolean}\n */</span>\nMagicDictionary.prototype.search = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">word</span>) </span>{\n  <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i=<span class=\"hljs-number\">0</span>;i&lt;<span class=\"hljs-keyword\">this</span>.dictArr.length;i++){\n    <span class=\"hljs-keyword\">let</span> dictWord=<span class=\"hljs-keyword\">this</span>.dictArr[i]\n    <span class=\"hljs-keyword\">if</span>(dictWord.length!==word.length || dictWord===word)<span class=\"hljs-keyword\">continue</span>\n    <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-keyword\">this</span>.check(dictWord,word))<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>\n  }\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>\n};\n\n<span class=\"hljs-comment\">/** \n * Your MagicDictionary object will be instantiated and called as such:\n * var obj = Object.create(MagicDictionary).createNew()\n * obj.buildDict(dict)\n * var param_2 = obj.search(word)\n */</span>\n</code></pre>\n"
  ],
  "titleSlug": "implement-magic-dictionary",
  "hasThinking": true,
  "thinking": "<hr>\n<p>思路：</p>\n<p>这道题本身在测试量比较小的情况下，<code>search</code>时间复杂度可以是<code>O(n)</code>，<code>n</code>为<code>dict</code>的长度，空间复杂度也是<code>O(n)</code></p>\n<p>每次<code>search</code>，检查每一个长度相同的<code>dict[i]</code>，如果发现不同的<code>diff</code>只有1处，则返回<code>true</code>。</p>\n<ul>\n<li>进阶</li>\n</ul>\n<p>如果在测试量更大的情况，那么需要构建一个<code>hash</code>，这个<code>hash</code>保存了<code>dict</code>中所有可能的值；</p>\n<p>例如：<code>bass</code>，我们需要保存的不是<code>bass</code>，而是<code>*ass</code>，<code>b*ss</code>，<code>ba*s</code>，<code>bas*</code>这4个。</p>\n<p>而在<code>search</code>中，对于<code>word</code>，我们先将它的可能值算出<code>candidates</code>，然后遍历<code>candidates</code>，如果<code>hash[candidates[i]]</code>存在，返回<code>true</code>。</p>\n<p>这种情况下，<code>search</code>的时间复杂度是<code>O(m)</code>，<code>m</code>是<code>dict[i]</code>的长度，空间复杂度是<code>O(mn)</code>，<code>n</code>是<code>dict</code>的长度。</p>\n<hr>\n",
  "content": "<p>实现一个带有<code>buildDict</code>, 以及&nbsp;<code>search</code>方法的魔法字典。</p>\n\n<p>对于<code>buildDict</code>方法，你将被给定一串不重复的单词来构建一个字典。</p>\n\n<p>对于<code>search</code>方法，你将被给定一个单词，并且判定能否只将这个单词中<strong>一个</strong>字母换成另一个字母，使得所形成的新单词存在于你构建的字典中。</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\nInput: buildDict([&quot;hello&quot;, &quot;leetcode&quot;]), Output: Null\nInput: search(&quot;hello&quot;), Output: False\nInput: search(&quot;hhllo&quot;), Output: True\nInput: search(&quot;hell&quot;), Output: False\nInput: search(&quot;leetcoded&quot;), Output: False\n</pre>\n\n<p><strong>注意:</strong></p>\n\n<ol>\n\t<li>你可以假设所有输入都是小写字母&nbsp;<code>a-z</code>。</li>\n\t<li>为了便于竞赛，测试所用的数据量很小。你可以在竞赛结束后，考虑更高效的算法。</li>\n\t<li>请记住<strong>重置</strong>MagicDictionary类中声明的类变量，因为静态/类变量会在多个测试用例中保留。 请参阅<a href=\"http://leetcode.com/faq/#different-output\">这里</a>了解更多详情。</li>\n</ol>\n"
}
