{
  "code": [
    "<pre class=\"hljs\"><code><span class=\"hljs-comment\">/**\n * @param {number[]} stones\n * @return {number}\n */</span>\n<span class=\"hljs-keyword\">var</span> lastStoneWeightII = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">stones</span>) </span>{\n  <span class=\"hljs-keyword\">let</span> sum=stones.reduce(<span class=\"hljs-function\">(<span class=\"hljs-params\">a,b</span>)=&gt;</span>a+b)\n  <span class=\"hljs-keyword\">let</span> dp=<span class=\"hljs-built_in\">Array</span>(sum+<span class=\"hljs-number\">1</span>).fill(<span class=\"hljs-number\">0</span>)\n  dp[<span class=\"hljs-number\">0</span>]=<span class=\"hljs-number\">1</span>\n  <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i=<span class=\"hljs-number\">0</span>;i&lt;stones.length;i++){\n    <span class=\"hljs-keyword\">let</span> cur=stones[i]\n    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> j=dp.length<span class=\"hljs-number\">-1</span>;j&gt;=cur;j--){\n      <span class=\"hljs-keyword\">if</span>(dp[j-cur]){\n        dp[j]=<span class=\"hljs-number\">1</span>\n      }\n    }\n  }\n  <span class=\"hljs-keyword\">let</span> minLen=<span class=\"hljs-literal\">Infinity</span>\n  <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i=<span class=\"hljs-number\">0</span>;i&lt;dp.length;i++){\n    <span class=\"hljs-keyword\">if</span>(dp[i]){\n      <span class=\"hljs-keyword\">if</span>(i*<span class=\"hljs-number\">2</span>-sum&gt;=<span class=\"hljs-number\">0</span>)minLen=<span class=\"hljs-built_in\">Math</span>.min(minLen,i*<span class=\"hljs-number\">2</span>-sum)\n    }\n  }\n  <span class=\"hljs-keyword\">return</span> minLen\n};\n</code></pre>\n"
  ],
  "titleSlug": "last-stone-weight-ii",
  "hasThinking": true,
  "thinking": "<hr>\n<p>思路：</p>\n<p>目的就是将这个<code>stones</code>数组分割成2堆，使得这两堆的差最小，为什么可以这么分？</p>\n<p>例如有几个数<code>a,b,c,d,e</code>，根据题目意思，两个石头互相减去重量，即其中2种分法为(假设都保证是大数减小数)：</p>\n<p><code>(a-b)-(c-d)-e</code> ===&gt;<code>a-b-c+d-e</code>===&gt;<code>(a+d)-(b+c+e)</code></p>\n<p><code>((a-b)-c)-(d-e)</code> ===&gt;<code>a-b-c-d+e</code>===&gt;<code>(a+e)-(b+c+d)</code></p>\n<p>可以看出，最后的结果相当于用一部分数字的和减去另一部分数字的和，也就是分成两堆的差。</p>\n<p>因此要求出两堆的最小差，只需要先确定一部分的和<code>s</code>，那么另一个部分的和为<code>sum-s</code>。</p>\n<p>使用<code>DP</code>，<code>dp[i]</code>表示<code>i</code>这个数是否是当前数组的某几个数字组成的和，例如<code>[1,2,5]</code>，那么能组成的和为<code>1,2,3,5,6,7,8</code>；</p>\n<p>最后对<code>dp[i]</code>存在的数，算出两堆的差<code>i-(sum-i)</code>，取最小值。</p>\n",
  "content": "<p>有一堆石头，每块石头的重量都是正整数。</p>\n\n<p>每一回合，从中选出<strong>任意两块石头</strong>，然后将它们一起粉碎。假设石头的重量分别为&nbsp;<code>x</code> 和&nbsp;<code>y</code>，且&nbsp;<code>x &lt;= y</code>。那么粉碎的可能结果如下：</p>\n\n<ul>\n\t<li>如果&nbsp;<code>x == y</code>，那么两块石头都会被完全粉碎；</li>\n\t<li>如果&nbsp;<code>x != y</code>，那么重量为&nbsp;<code>x</code>&nbsp;的石头将会完全粉碎，而重量为&nbsp;<code>y</code>&nbsp;的石头新重量为&nbsp;<code>y-x</code>。</li>\n</ul>\n\n<p>最后，最多只会剩下一块石头。返回此石头<strong>最小的可能重量</strong>。如果没有石头剩下，就返回 <code>0</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre><strong>输入：</strong>[2,7,4,1,8,1]\n<strong>输出：</strong>1\n<strong>解释：</strong>\n组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]，\n组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]，\n组合 2 和 1，得到 1，所以数组转化为 [1,1,1]，\n组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ol>\n\t<li><code>1 &lt;= stones.length &lt;= 30</code></li>\n\t<li><code>1 &lt;= stones[i] &lt;= 1000</code></li>\n</ol>\n"
}
