{
  "code": [
    "<pre class=\"hljs\"><code><span class=\"hljs-comment\">/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */</span>\n\n<span class=\"hljs-comment\">/**\n * Encodes a tree to a single string.\n *\n * @param {TreeNode} root\n * @return {string}\n */</span>\n<span class=\"hljs-keyword\">var</span> serialize = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">root</span>) </span>{\n  <span class=\"hljs-keyword\">let</span> res=<span class=\"hljs-string\">''</span>\n  <span class=\"hljs-keyword\">let</span> arr=[root]\n  <span class=\"hljs-keyword\">while</span>(arr.length&gt;<span class=\"hljs-number\">0</span>){\n    <span class=\"hljs-keyword\">let</span> len=arr.length\n    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i=<span class=\"hljs-number\">0</span>;i&lt;len;i++){\n      <span class=\"hljs-keyword\">let</span> node=arr.shift()\n      <span class=\"hljs-keyword\">if</span>(node){\n        <span class=\"hljs-keyword\">if</span>(res===<span class=\"hljs-string\">''</span>)res+=node.val\n        <span class=\"hljs-keyword\">else</span> res+=<span class=\"hljs-string\">','</span>+node.val\n        arr.push(node.left)\n        arr.push(node.right)\n      }\n    }\n  }\n  <span class=\"hljs-keyword\">return</span> res\n};\n\n<span class=\"hljs-comment\">/**\n * Decodes your encoded data to tree.\n *\n * @param {string} data\n * @return {TreeNode}\n */</span>\n<span class=\"hljs-keyword\">var</span> deserialize = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">data</span>) </span>{\n  <span class=\"hljs-keyword\">if</span>(!data)<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">null</span>\n  <span class=\"hljs-keyword\">let</span> arr=data.split(<span class=\"hljs-string\">','</span>)\n  <span class=\"hljs-keyword\">let</span> root=<span class=\"hljs-keyword\">new</span> TreeNode(+arr[<span class=\"hljs-number\">0</span>])\n  <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i=<span class=\"hljs-number\">1</span>;i&lt;arr.length;i++){\n    <span class=\"hljs-keyword\">let</span> n=+arr[i]\n    root=insert(root,n)\n  }\n  <span class=\"hljs-keyword\">return</span> root\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">insert</span>(<span class=\"hljs-params\">root,n</span>)</span>{\n    <span class=\"hljs-keyword\">if</span>(!root)<span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> TreeNode(n)\n    <span class=\"hljs-keyword\">if</span>(root.val&lt;=n){\n      root.right=insert(root.right,n)\n    }<span class=\"hljs-keyword\">else</span>{\n      root.left=insert(root.left,n)\n    }\n    <span class=\"hljs-keyword\">return</span> root\n  }\n};\n\n<span class=\"hljs-comment\">/**\n * Your functions will be called as such:\n * deserialize(serialize(root));\n */</span>\n</code></pre>\n"
  ],
  "titleSlug": "serialize-and-deserialize-bst",
  "hasThinking": false,
  "content": "<p>序列化是将数据结构或对象转换为一系列位的过程，以便它可以存储在文件或内存缓冲区中，或通过网络连接链路传输，以便稍后在同一个或另一个计算机环境中重建。</p>\n\n<p>设计一个算法来序列化和反序列化<strong>二叉搜索树</strong>。 对序列化/反序列化算法的工作方式没有限制。 您只需确保二叉搜索树可以序列化为字符串，并且可以将该字符串反序列化为最初的二叉搜索树。</p>\n\n<p><strong>编码的字符串应尽可能紧凑。</strong></p>\n\n<p><strong>注意</strong>：不要使用类成员/全局/静态变量来存储状态。 你的序列化和反序列化算法应该是无状态的。</p>\n"
}
