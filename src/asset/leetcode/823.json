{
  "code": [
    "<pre class=\"hljs\"><code><span class=\"hljs-comment\">/**\n * @param {number[]} A\n * @return {number}\n */</span>\n<span class=\"hljs-keyword\">var</span> numFactoredBinaryTrees = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">A</span>) </span>{\n  <span class=\"hljs-keyword\">let</span> MOD=<span class=\"hljs-number\">1000000007</span>\n  A.sort(<span class=\"hljs-function\">(<span class=\"hljs-params\">a,b</span>)=&gt;</span>a-b)\n  <span class=\"hljs-keyword\">let</span> dp=<span class=\"hljs-built_in\">Array</span>(A.length).fill(<span class=\"hljs-number\">0</span>),\n      hash=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Map</span>()\n  dp[<span class=\"hljs-number\">0</span>]=<span class=\"hljs-number\">1</span>\n  <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i=<span class=\"hljs-number\">0</span>;i&lt;A.length;i++){\n    hash.set(A[i],i)\n  }\n  <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i=<span class=\"hljs-number\">1</span>;i&lt;dp.length;i++){\n    <span class=\"hljs-keyword\">let</span> count=<span class=\"hljs-number\">1</span>\n    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> j=<span class=\"hljs-number\">0</span>;j&lt;i;j++){\n      <span class=\"hljs-keyword\">if</span>(A[i] % A[j]===<span class=\"hljs-number\">0</span>){\n        <span class=\"hljs-keyword\">let</span> d=A[i]/A[j]\n        <span class=\"hljs-keyword\">if</span>(hash.has(d)){\n          <span class=\"hljs-keyword\">let</span> l=j,r=hash.get(d)\n          count+=(dp[l]-(dp[l<span class=\"hljs-number\">-1</span>]||<span class=\"hljs-number\">0</span>) ) *(dp[r]-(dp[r<span class=\"hljs-number\">-1</span>]||<span class=\"hljs-number\">0</span>) ) % MOD\n        }\n      }\n    }\n    dp[i]=(count+dp[i<span class=\"hljs-number\">-1</span>] + MOD) % MOD\n  }\n  <span class=\"hljs-keyword\">return</span> dp[dp.length<span class=\"hljs-number\">-1</span>]\n};\n</code></pre>\n"
  ],
  "titleSlug": "binary-trees-with-factors",
  "hasThinking": true,
  "thinking": "<hr>\n<p>思路：</p>\n<p><code>DP</code>或者<code>递归+hash</code>。</p>\n<p><code>dp[i]</code>表示当前索引上存在的二叉树的总和。</p>\n<h2>先升序排序，排序后对于索引为<code>i</code>上的值，能成为它的子节点的只可能是索引<code>&lt;i</code>的值，遍历如果存在3个数，<code>a=b*c</code>，那么<code>dp[ai]+=dp[bi]*dp[ci]</code>。</h2>\n",
  "content": "<p>给出一个含有不重复整数元素的数组，每个整数均大于 1。</p>\n\n<p>我们用这些整数来构建二叉树，每个整数可以使用任意次数。</p>\n\n<p>其中：每个非叶结点的值应等于它的两个子结点的值的乘积。</p>\n\n<p>满足条件的二叉树一共有多少个？返回的结果应<strong>模除 10 ** 9 + 7</strong>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> <code>A = [2, 4]</code>\n<strong>输出:</strong> 3\n<strong>解释:</strong> 我们可以得到这些二叉树: <code>[2], [4], [4, 2, 2]</code></pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> <code>A = [2, 4, 5, 10]</code>\n<strong>输出:</strong> <code>7</code>\n<strong>解释:</strong> 我们可以得到这些二叉树: <code>[2], [4], [5], [10], [4, 2, 2], [10, 2, 5], [10, 5, 2]</code>.</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ol>\n\t<li><code>1 &lt;= A.length &lt;=&nbsp;1000.</code></li>\n\t<li><code>2 &lt;=&nbsp;A[i]&nbsp;&lt;=&nbsp;10 ^ 9</code>.</li>\n</ol>\n"
}
