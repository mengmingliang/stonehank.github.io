{
  "code": [
    "<pre class=\"hljs\"><code><span class=\"hljs-comment\">/**\n * @param {string} S\n * @return {number}\n */</span>\n<span class=\"hljs-keyword\">var</span> uniqueLetterString = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">S</span>) </span>{\n  <span class=\"hljs-keyword\">if</span>(S===<span class=\"hljs-string\">''</span>)<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>\n  <span class=\"hljs-keyword\">let</span> MOD=<span class=\"hljs-number\">1e9</span>+<span class=\"hljs-number\">7</span>,\n      idxes=<span class=\"hljs-built_in\">Array</span>(<span class=\"hljs-number\">26</span>).fill().map(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span>=&gt;</span>[<span class=\"hljs-number\">-1</span>,<span class=\"hljs-number\">-1</span>]),\n      dp=<span class=\"hljs-built_in\">Array</span>(S.length).fill(<span class=\"hljs-number\">0</span>)\n  dp[<span class=\"hljs-number\">0</span>]=<span class=\"hljs-number\">1</span>\n  idxes[S.charCodeAt(<span class=\"hljs-number\">0</span>)<span class=\"hljs-number\">-65</span>]=[<span class=\"hljs-number\">-1</span>,<span class=\"hljs-number\">0</span>]\n  <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i=<span class=\"hljs-number\">1</span>;i&lt;S.length;i++){\n    <span class=\"hljs-keyword\">let</span> code=S.charCodeAt(i)<span class=\"hljs-number\">-65</span>\n    \n    dp[i]=(dp[i<span class=\"hljs-number\">-1</span>]+(dp[i<span class=\"hljs-number\">-1</span>]-(dp[i<span class=\"hljs-number\">-2</span>]||<span class=\"hljs-number\">0</span>))+(i+<span class=\"hljs-number\">1</span>)-(idxes[code][<span class=\"hljs-number\">1</span>]-idxes[code][<span class=\"hljs-number\">0</span>])*<span class=\"hljs-number\">2</span>-(idxes[code][<span class=\"hljs-number\">0</span>]-(<span class=\"hljs-number\">-1</span>))) % MOD\n     updateIdxes(i,code)\n\n  }\n  <span class=\"hljs-keyword\">return</span> dp[dp.length<span class=\"hljs-number\">-1</span>]\n  \n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">updateIdxes</span>(<span class=\"hljs-params\">i,code</span>)</span>{\n    <span class=\"hljs-keyword\">let</span> t=idxes[code][<span class=\"hljs-number\">1</span>]\n    idxes[code][<span class=\"hljs-number\">1</span>]=i\n    idxes[code][<span class=\"hljs-number\">0</span>]=t    \n  }\n};\n</code></pre>\n"
  ],
  "titleSlug": "unique-letter-string",
  "hasThinking": true,
  "thinking": "<hr>\n<p>思路：</p>\n<p>我们使用一个<code>idxes</code>保存每个字母的前2个索引，为什么要前2个索引呢？</p>\n<p>例如：</p>\n<pre class=\"hljs\"><code>A B C A B C A\n0 1 2 3 4 5 6\n</code></pre>\n<p>在最后一个(索引为6)的<code>A</code>时，它的前两个索引分别是<code>0</code>和<code>3</code>，写成<code>[0,3]</code>，那么当检查它的子数组时，\n我们首先将最理想的状态，即每个子数组都增加<code>1</code>，因此<code>+7</code>，因为带有索引<code>6</code>的子数组有<code>7</code>个。</p>\n<p>再看：</p>\n<ul>\n<li>\n<p>从索引<code>6</code>到<code>3</code>之间这3个数，<code>A</code>是没有重复值的，每个子数组可以增加<code>1</code>个独特字符，因此不变(因为之前<code>+7</code>包括了)。</p>\n</li>\n<li>\n<p>从索引<code>3</code>到<code>0</code>之间这3个数，<code>A</code>有了重复值，每个子数组要减少<code>n</code>个独特字符，这<code>n</code>是多少呢？</p>\n<p>因为在上一次，即索引<code>5</code>时，那时候从索引<code>3</code>到<code>0</code>之间这3个数，<code>A</code>是没有重复值，他们的独特字符都增加<code>1</code>。</p>\n<p>而这次(索引<code>6</code>)，这几个数突然有了重复值，那么他们的独特字符则需要<code>-1</code>，因为我们之间<code>+7</code>里面这里每个相当于<code>+1</code>，\n因此最终需要<code>-2</code>。</p>\n</li>\n<li>\n<p>从索引<code>0</code>之前，<code>A</code>在之前就已经有了重复值，再来一个重复值也没有影响，因此这之前的不需要变化，但我们之前<code>+7</code>的时候，\n里面每个值都<code>+1</code>，因此这里需要<code>-1</code>。</p>\n</li>\n</ul>\n<p>因此递推公式为<code>dp[i]=dp[i-1]+(dp[i-1]-dp[i-2])+(i+1)-(idxes[code][1]-idxes[code][0])*2-(idxes[code][0]-(-1))</code></p>\n<p>这里<code>dp[i-1]-dp[i-2]</code>指的是上一次的独特字符增加的数量；</p>\n<p><code>i+1</code>指这一次独特字符最理想的增加数量；</p>\n<p><code>(idxes[code][1]-idxes[code][0])*2</code>即上面介绍的第一阶段需要减去的。</p>\n<p><code>(idxes[code][0]-(-1))</code>即上面介绍第二阶段需要减去的。</p>\n<h2>最后我们需要更新<code>idex</code>，只需要保存最近的2个索引。</h2>\n",
  "content": "<p>如果一个字符在字符串&nbsp;<code>S</code>&nbsp;中有且仅有出现一次，那么我们称其为独特字符。</p>\n\n<p>例如，在字符串&nbsp;<code>S = &quot;LETTER&quot;</code>&nbsp;中，<code>&quot;L&quot;</code>&nbsp;和&nbsp;<code>&quot;R&quot;</code>&nbsp;可以被称为独特字符。</p>\n\n<p>我们再定义&nbsp;<code>UNIQ(S)</code>&nbsp;作为字符串&nbsp;<code>S</code>&nbsp;中独特字符的个数。</p>\n\n<p>那么，在&nbsp;<code>S = &quot;LETTER&quot;</code>&nbsp;中，&nbsp;<code>UNIQ(&quot;LETTER&quot;) =&nbsp; 2</code>。</p>\n\n<p>对于给定字符串&nbsp;<code>S</code>，计算其所有非空子串的独特字符的个数（即&nbsp;<code>UNIQ(substring)</code>）之和。</p>\n\n<p>如果在 <code>S</code>&nbsp;的不同位置上出现两个甚至多个相同的子串，那么我们认为这些子串是不同的。</p>\n\n<p>考虑到答案可能会非常大，规定返回格式为：结果 mod&nbsp;<code>10 ^ 9 + 7</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre><strong>输入: </strong>&quot;ABC&quot;\n<strong>输出: </strong>10\n<strong>解释:</strong> 所有可能的子串为：&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;AB&quot;,&quot;BC&quot; 和 &quot;ABC&quot;。\n     其中，每一个子串都由独特字符构成。\n     所以其长度总和为：1 + 1 + 1 + 2 + 2 + 3 = 10\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre><strong>输入: </strong>&quot;ABA&quot;\n<strong>输出: </strong>8\n<strong>解释: </strong>除了子串 UNIQ(&#39;ABA&#39;) = 1，其余与示例1相同。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>说明:</strong> <code>0 &lt;= S.length &lt;= 10000</code>。</p>\n"
}
