{
  "code": [
    "/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {number} sum\n * @return {number[][]}\n */\nvar pathSum = function(root, sum) {\n  // bfs\n//   let node=root\n//   let arr=[node]\n//   while(arr.length>0){\n//     let len=arr.length\n//     for(let i=0;i<len;i++){\n//       let cur=arr.shift(),val=cur.val\n//       if(cur.left){\n//         cur.left.val+=val\n//         arr.push(cur.left)\n//       }\n//       if(cur.right){\n//         cur.right.val+=val\n//         arr.push(cur.right)\n//       }\n//       if(!cur.left && !cur.right){\n        \n//       }\n//     }\n//   }\n  // dfs\n  if(!root)return []\n  let result=[]\n  let temp=[root.val],curSum=root.val\n  function dfs(node,temp,curSum){\n    if(node.left){\n      temp.push(node.left.val)\n      dfs(node.left,temp,curSum+node.left.val)\n      temp.pop()\n    }\n    if(node.right){\n      temp.push(node.right.val)\n      dfs(node.right,temp,curSum+node.right.val)\n      temp.pop()\n    }\n    if(!node.left && !node.right){\n      if(curSum===sum)result.push(temp.slice())\n    }\n  }\n  dfs(root,temp,curSum)\n  return result\n};"
  ],
  "titleSlug": "path-sum-ii",
  "content": "<p>Given a binary tree and a sum, find all root-to-leaf paths where each path&#39;s sum equals the given sum.</p>\r\n\r\n<p><strong>Note:</strong>&nbsp;A leaf is a node with no children.</p>\r\n\r\n<p><strong>Example:</strong></p>\r\n\r\n<p>Given the below binary tree and <code>sum = 22</code>,</p>\r\n\r\n<pre>\r\n      <strong>5</strong>\r\n     <strong>/ \\</strong>\r\n    <strong>4   8</strong>\r\n   <strong>/</strong>   / <strong>\\</strong>\r\n  <strong>11</strong>  13  <strong>4</strong>\r\n /  <strong>\\</strong>    <strong>/</strong> \\\r\n7    <strong>2</strong>  <strong>5</strong>   1\r\n</pre>\r\n\r\n<p>Return:</p>\r\n\r\n<pre>\r\n[\r\n   [5,4,11,2],\r\n   [5,8,4,5]\r\n]\r\n</pre>\r\n",
  "translatedContent": "<p>给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。</p>\n\n<p><strong>说明:</strong>&nbsp;叶子节点是指没有子节点的节点。</p>\n\n<p><strong>示例:</strong><br>\n给定如下二叉树，以及目标和&nbsp;<code>sum = 22</code>，</p>\n\n<pre>              <strong>5</strong>\n             / \\\n            <strong>4</strong>   <strong>8</strong>\n           /   / \\\n          <strong>11</strong>  13  <strong>4</strong>\n         /  \\    / \\\n        7    <strong>2</strong>  <strong>5</strong>   1\n</pre>\n\n<p>返回:</p>\n\n<pre>[\n   [5,4,11,2],\n   [5,8,4,5]\n]\n</pre>\n"
}
