{
  "code": [
    "<pre class=\"hljs\"><code><span class=\"hljs-comment\">/**\n * // This is the interface that allows for creating nested lists.\n * // You should not implement it, or speculate about its implementation\n * function NestedInteger() {\n *\n *     Return true if this NestedInteger holds a single integer, rather than a nested list.\n *     @return {boolean}\n *     this.isInteger = function() {\n *         ...\n *     };\n *\n *     Return the single integer that this NestedInteger holds, if it holds a single integer\n *     Return null if this NestedInteger holds a nested list\n *     @return {integer}\n *     this.getInteger = function() {\n *         ...\n *     };\n *\n *     Return the nested list that this NestedInteger holds, if it holds a nested list\n *     Return null if this NestedInteger holds a single integer\n *     @return {NestedInteger[]}\n *     this.getList = function() {\n *         ...\n *     };\n * };\n */</span>\n<span class=\"hljs-comment\">/**\n * @constructor\n * @param {NestedInteger[]} nestedList\n */</span>\n<span class=\"hljs-keyword\">var</span> NestedIterator = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">nestedList</span>) </span>{\n  <span class=\"hljs-keyword\">let</span> stack=[],res=[]\n  <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i=<span class=\"hljs-number\">0</span>;i&lt;nestedList.length;i++){\n    stack.push(nestedList[i])\n  }\n  <span class=\"hljs-keyword\">let</span> nestedNode=stack.pop()\n  <span class=\"hljs-keyword\">while</span>(nestedNode){\n    <span class=\"hljs-keyword\">if</span>(nestedNode.isInteger()){\n      res.push(nestedNode.getInteger())\n    }<span class=\"hljs-keyword\">else</span>{\n      <span class=\"hljs-keyword\">let</span> list=nestedNode.getList()\n      <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i=<span class=\"hljs-number\">0</span>;i&lt;list.length;i++){\n        stack.push(list[i])\n      }      \n    }\n    nestedNode=stack.pop()\n  }\n  <span class=\"hljs-keyword\">this</span>.res=res.reverse()\n  <span class=\"hljs-keyword\">this</span>.id=<span class=\"hljs-number\">0</span>\n};\n\n\n<span class=\"hljs-comment\">/**\n * @this NestedIterator\n * @returns {boolean}\n */</span>\nNestedIterator.prototype.hasNext = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.id&lt;<span class=\"hljs-keyword\">this</span>.res.length\n};\n\n<span class=\"hljs-comment\">/**\n * @this NestedIterator\n * @returns {integer}\n */</span>\nNestedIterator.prototype.next = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.res[<span class=\"hljs-keyword\">this</span>.id++]\n};\n\n<span class=\"hljs-comment\">/**\n * Your NestedIterator will be called like this:\n * var i = new NestedIterator(nestedList), a = [];\n * while (i.hasNext()) a.push(i.next());\n*/</span>\n</code></pre>\n"
  ],
  "titleSlug": "flatten-nested-list-iterator",
  "hasThinking": true,
  "thinking": "<hr>\n<p>思路：</p>\n<p>只需要将<code>nestedList</code>转换成<code>Array&lt;number&gt;</code>后，<code>hasNext</code>和<code>next</code>对数组来说都是很简单的。</p>\n<p>转换方式可以选择2种方法，递归或者循环。</p>\n<p>递归很好理解，遇到是整数，添加到<code>arr</code>，非数字，继续递归。</p>\n<h2>遍历需要定义一个<code>stack</code>，先将<code>nestedList</code>所有内容压栈，然后一个一个出栈并且判断，如果是整数，放进<code>arr</code>，如果是列表，继续压栈。</h2>\n",
  "content": "<p>给定一个嵌套的整型列表。设计一个迭代器，使其能够遍历这个整型列表中的所有整数。</p>\n\n<p>列表中的项或者为一个整数，或者是另一个列表。</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre><strong>输入: </strong>[[1,1],2,[1,1]]\n<strong>输出: </strong>[1,1,2,1,1]\n<strong>解释: </strong>通过重复调用&nbsp;<em>next </em>直到&nbsp;<em>hasNex</em>t 返回false，<em>next&nbsp;</em>返回的元素的顺序应该是: <code>[1,1,2,1,1]</code>。</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre><strong>输入: </strong>[1,[4,[6]]]\n<strong>输出: </strong>[1,4,6]\n<strong>解释: </strong>通过重复调用&nbsp;<em>next&nbsp;</em>直到&nbsp;<em>hasNex</em>t 返回false，<em>next&nbsp;</em>返回的元素的顺序应该是: <code>[1,4,6]</code>。\n</pre>\n"
}
