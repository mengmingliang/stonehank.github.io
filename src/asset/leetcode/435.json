{
  "code": [
    "/**\n * Definition for an interval.\n * function Interval(start, end) {\n *     this.start = start;\n *     this.end = end;\n * }\n */\n/**\n * @param {Interval[]} intervals\n * @return {number}\n */\nvar eraseOverlapIntervals = function(itv) {\n  var quick = function (array, left, right) {\n    var index;\n    if (array.length > 1) {\n      if(right<=left)return\n      index = partition(array, left, right);\n      quick(array, left, index - 1);\n      quick(array, index, right);\n    }\n  };\n\n  var partition = function (array, left, right) {\n    var pivot = array[Math.floor((right + left) / 2)].end,\n      i = left,\n      j = right;\n    while (i <= j) {\n      while (array[i].end < pivot) {\n        i++;\n      }\n      while (array[j].end > pivot) {\n        j--;\n      }\n      if (i <= j) {\n        swapQuickStort(array, i, j);\n        i++;\n        j--;\n      }\n    }\n    return i;\n\n  };\n  var swapQuickStort = function (a, i, j) {\n    var t = a[i];\n    a[i] = a[j];\n    a[j] = t;\n  };\n  \n  quick(itv,0,itv.length-1)\n\n  if(itv.length===0)return 0\n  let prevE=itv[0].end\n  let res=1\n  for(let i=1;i<itv.length;i++){\n    let curS=itv[i].start,curE=itv[i].end\n    if(curS<prevE)continue\n    prevE=curE\n    res++\n  }\n  return itv.length-res\n};"
  ],
  "titleSlug": "non-overlapping-intervals",
  "content": "<p>\r\nGiven a collection of intervals, find the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping.\r\n</p>\r\n\r\n<p><b>Note:</b><br />\r\n<ol>\r\n<li>You may assume the interval's end point is always bigger than its start point.</li>\r\n<li>Intervals like [1,2] and [2,3] have borders \"touching\" but they don't overlap each other.</li>\r\n</ol>\r\n</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> [ [1,2], [2,3], [3,4], [1,3] ]\r\n\r\n<b>Output:</b> 1\r\n\r\n<b>Explanation:</b> [1,3] can be removed and the rest of intervals are non-overlapping.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 2:</b><br />\r\n<pre>\r\n<b>Input:</b> [ [1,2], [1,2], [1,2] ]\r\n\r\n<b>Output:</b> 2\r\n\r\n<b>Explanation:</b> You need to remove two [1,2] to make the rest of intervals non-overlapping.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 3:</b><br />\r\n<pre>\r\n<b>Input:</b> [ [1,2], [2,3] ]\r\n\r\n<b>Output:</b> 0\r\n\r\n<b>Explanation:</b> You don't need to remove any of the intervals since they're already non-overlapping.\r\n</pre>\r\n</p>",
  "translatedContent": "<p>给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。</p>\n\n<p><strong>注意:</strong></p>\n\n<ol>\n\t<li>可以认为区间的终点总是大于它的起点。</li>\n\t<li>区间 [1,2] 和 [2,3] 的边界相互&ldquo;接触&rdquo;，但没有相互重叠。</li>\n</ol>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> [ [1,2], [2,3], [3,4], [1,3] ]\n\n<strong>输出:</strong> 1\n\n<strong>解释:</strong> 移除 [1,3] 后，剩下的区间没有重叠。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> [ [1,2], [1,2], [1,2] ]\n\n<strong>输出:</strong> 2\n\n<strong>解释:</strong> 你需要移除两个 [1,2] 来使剩下的区间没有重叠。\n</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre>\n<strong>输入:</strong> [ [1,2], [2,3] ]\n\n<strong>输出:</strong> 0\n\n<strong>解释:</strong> 你不需要移除任何区间，因为它们已经是无重叠的了。\n</pre>\n"
}
