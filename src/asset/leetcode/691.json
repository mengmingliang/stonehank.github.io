{
  "code": [
    "<pre class=\"hljs\"><code><span class=\"hljs-comment\">/**\n * @param {string[]} stickers\n * @param {string} target\n * @return {number}\n */</span>\n<span class=\"hljs-keyword\">var</span> minStickers = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">stickers, target</span>) </span>{\n  <span class=\"hljs-keyword\">let</span> all=[],\n      acode=<span class=\"hljs-string\">'a'</span>.charCodeAt(<span class=\"hljs-number\">0</span>)\n  <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i=<span class=\"hljs-number\">0</span>;i&lt;stickers.length;i++){\n    all[i]=[]\n    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> j=<span class=\"hljs-number\">0</span>;j&lt;<span class=\"hljs-number\">26</span>;j++){\n      all[i][j]=<span class=\"hljs-number\">0</span>\n    }\n  }\n  <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i=<span class=\"hljs-number\">0</span>;i&lt;stickers.length;i++){\n    <span class=\"hljs-keyword\">let</span> word=stickers[i]\n    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> j=<span class=\"hljs-number\">0</span>;j&lt;word.length;j++){\n      <span class=\"hljs-keyword\">let</span> curcode=word.charCodeAt(j)-acode\n      all[i][curcode]++\n    }\n  }\n  <span class=\"hljs-keyword\">let</span> mem={}\n  <span class=\"hljs-keyword\">let</span> result= dfs(target)\n  <span class=\"hljs-keyword\">if</span>(result===<span class=\"hljs-literal\">Infinity</span>)<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>\n  <span class=\"hljs-keyword\">return</span> result\n  \n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">dfs</span>(<span class=\"hljs-params\">target</span>)</span>{\n    <span class=\"hljs-keyword\">if</span>(target===<span class=\"hljs-string\">\"\"</span>)<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>\n    <span class=\"hljs-keyword\">if</span>(mem[target])<span class=\"hljs-keyword\">return</span> mem[target]\n    <span class=\"hljs-keyword\">let</span> minStep=<span class=\"hljs-literal\">Infinity</span>\n    <span class=\"hljs-keyword\">let</span> tars=<span class=\"hljs-built_in\">Array</span>(<span class=\"hljs-number\">26</span>).fill(<span class=\"hljs-number\">0</span>)\n    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i=<span class=\"hljs-number\">0</span>;i&lt;target.length;i++){\n      <span class=\"hljs-keyword\">let</span> curcode=target.charCodeAt(i)-acode\n      tars[curcode]++\n    }\n    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i=<span class=\"hljs-number\">0</span>;i&lt;all.length;i++){\n      <span class=\"hljs-keyword\">let</span> newtarget=<span class=\"hljs-string\">''</span>,find=<span class=\"hljs-literal\">false</span>\n      <span class=\"hljs-keyword\">let</span> keyletter=target.charCodeAt(<span class=\"hljs-number\">0</span>)-acode\n      <span class=\"hljs-keyword\">if</span>(all[i][keyletter]===<span class=\"hljs-number\">0</span>)<span class=\"hljs-keyword\">continue</span>\n      find=<span class=\"hljs-literal\">true</span>\n      <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> j=<span class=\"hljs-number\">0</span>;j&lt;<span class=\"hljs-number\">26</span>;j++){\n        <span class=\"hljs-keyword\">let</span> gap=<span class=\"hljs-built_in\">Math</span>.max(tars[j]-all[i][j],<span class=\"hljs-number\">0</span>)\n        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> k=<span class=\"hljs-number\">0</span>;k&lt;gap;k++){\n          newtarget+=<span class=\"hljs-built_in\">String</span>.fromCharCode(j+acode)\n        }\n      }\n      <span class=\"hljs-keyword\">if</span>(!find)<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">Infinity</span>\n      <span class=\"hljs-keyword\">let</span> res=dfs(newtarget)\n      minStep=<span class=\"hljs-built_in\">Math</span>.min(minStep,res+<span class=\"hljs-number\">1</span>)\n    }\n    mem[target]=minStep\n    <span class=\"hljs-keyword\">return</span> minStep\n  }\n};\n</code></pre>\n"
  ],
  "titleSlug": "stickers-to-spell-word",
  "content": "<p>我们给出了 N 种不同类型的贴纸。每个贴纸上都有一个小写的英文单词。</p>\n\n<p>你希望从自己的贴纸集合中裁剪单个字母并重新排列它们，从而拼写出给定的目标字符串 <code>target</code>。</p>\n\n<p>如果你愿意的话，你可以不止一次地使用每一张贴纸，而且每一张贴纸的数量都是无限的。</p>\n\n<p>拼出目标&nbsp;<code>target</code> 所需的最小贴纸数量是多少？如果任务不可能，则返回 -1。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p>输入：</p>\n\n<pre>[&quot;with&quot;, &quot;example&quot;, &quot;science&quot;], &quot;thehat&quot;\n</pre>\n\n<p>输出：</p>\n\n<pre>3\n</pre>\n\n<p>解释：</p>\n\n<pre>我们可以使用 2 个 &quot;with&quot; 贴纸，和 1 个 &quot;example&quot; 贴纸。\n把贴纸上的字母剪下来并重新排列后，就可以形成目标 &ldquo;thehat&ldquo; 了。\n此外，这是形成目标字符串所需的最小贴纸数量。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p>输入：</p>\n\n<pre>[&quot;notice&quot;, &quot;possible&quot;], &quot;basicbasic&quot;\n</pre>\n\n<p>输出：</p>\n\n<pre>-1\n</pre>\n\n<p>解释：</p>\n\n<pre>我们不能通过剪切给定贴纸的字母来形成目标&ldquo;basicbasic&rdquo;。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>stickers</code> 长度范围是&nbsp;<code>[1, 50]</code>。</li>\n\t<li><code>stickers</code> 由小写英文单词组成（不带撇号）。</li>\n\t<li><code>target</code> 的长度在&nbsp;<code>[1, 15]</code>&nbsp;范围内，由小写字母组成。</li>\n\t<li>在所有的测试案例中，所有的单词都是从 1000 个最常见的美国英语单词中随机选取的，目标是两个随机单词的串联。</li>\n\t<li>时间限制可能比平时更具挑战性。预计 50 个贴纸的测试案例平均可在35ms内解决。</li>\n</ul>\n\n<p>&nbsp;</p>\n"
}
