{
  "code": [
    "<pre class=\"hljs\"><code><span class=\"hljs-comment\">/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */</span>\n<span class=\"hljs-comment\">/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */</span>\n<span class=\"hljs-comment\">/**\n * @param {ListNode} head\n * @return {TreeNode}\n */</span>\n<span class=\"hljs-keyword\">var</span> sortedListToBST = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">head</span>) </span>{\n  <span class=\"hljs-keyword\">let</span> arr=[]\n  <span class=\"hljs-keyword\">let</span> listNode=head\n  <span class=\"hljs-keyword\">while</span>(listNode){\n    arr.push(listNode.val)\n    listNode=listNode.next\n  }\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">createTree</span>(<span class=\"hljs-params\">arr,lo,hi</span>)</span>{\n    <span class=\"hljs-keyword\">if</span>(lo&gt;hi)<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">null</span>\n    <span class=\"hljs-keyword\">let</span> mid=<span class=\"hljs-built_in\">Math</span>.floor((lo+hi)/<span class=\"hljs-number\">2</span>)\n    <span class=\"hljs-keyword\">let</span> node=<span class=\"hljs-keyword\">new</span> TreeNode(arr[mid])\n    node.left=createTree(arr,lo,mid<span class=\"hljs-number\">-1</span>)\n    node.right=createTree(arr,mid+<span class=\"hljs-number\">1</span>,hi)\n    <span class=\"hljs-keyword\">return</span> node\n  }\n  <span class=\"hljs-keyword\">return</span> createTree(arr,<span class=\"hljs-number\">0</span>,arr.length<span class=\"hljs-number\">-1</span>)\n};\n</code></pre>\n"
  ],
  "titleSlug": "convert-sorted-list-to-binary-search-tree",
  "hasThinking": true,
  "thinking": "<hr>\n<p>思路：</p>\n<p>为了达到<code>平衡树</code>，每次都要插入<code>中间值</code>，左子树再插入左侧的中间值，右子树插入右侧的中间值，然后递归。</p>\n<p>可以将链表转化为数组，然后通过<code>mid=Math.floor((lo+hi)/2)</code>去查找中间值；</p>\n<h2>也可以直接通过链表的<code>slow=slow.next;fast=fast.next.next</code>找中间值。</h2>\n",
  "content": "<p>给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。</p>\n\n<p>本题中，一个高度平衡二叉树是指一个二叉树<em>每个节点&nbsp;</em>的左右两个子树的高度差的绝对值不超过 1。</p>\n\n<p><strong>示例:</strong></p>\n\n<pre>给定的有序链表： [-10, -3, 0, 5, 9],\n\n一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树：\n\n      0\n     / \\\n   -3   9\n   /   /\n -10  5\n</pre>\n"
}
