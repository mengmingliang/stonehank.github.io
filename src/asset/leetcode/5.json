{
  "code": [
    "/**\n * @param {string} s\n * @return {string}\n */\nvar longestPalindrome = function(s) {\n  // 这里不论奇偶，都将s转换成 '#x$x$x$' 的形式\n  let str='#'\n  for(let i=0;i<s.length;i++) str+=s[i]+'$'\n  // p为一个数组，储存每一个值的最大回文数量的一半+1，例如：'ababa' 对应的p 就是[1,2,3,2,1]\n  let p=[1]\n  // max为当前 已经计算过得最大回文量(p[id])+对应的位置(id)，默认为0或者-infinity，可以保证最后的max和id不为0\n  let max=0,id=0\n  // 暴力计算时，从左右什么位置开始进行对比\n  let temp=1\n  // newCenter是目前需要重新暴力计算的位置\n  let newCenter=0\n  // 从第一个开始遍历，第0个不用管，是'#'\n  for(let i=1;i<str.length;i++){\n    // i在当前max所涵盖的范围内，如下图，i在max范围内，j是对称的点\n    /*\n      *        j        i\n      *      ------id------\n    * */\n    if(max>i){\n      // 在范围内对称的位置\n      let j=id-(i-id)\n      // 通过boundary判断对称位置那个是否会超出范围\n      let boundary=p[j]+i\n      // j超出范围，那么i只取范围内，如下图\n      /*\n      *    ---j---      -i-\n      *      ------id------\n      * */\n      if(boundary>max){\n        p[i]=p[j]-(boundary-max)\n        continue;\n      // j边界刚好在范围上，不仅将i设置，并且还要继续扩展i，即设置newCenter和temp\n        /*\n        *      --j--    --i--  \n        *      ------id------   =>  继续扩展i\n        * */        \n      }else if(boundary===max){\n        temp=p[j]\n        newCenter=i\n      // j边界在范围内，只需要简单赋值给i即可，因为此时j和i的值完全相等\n        /*\n        *       -j-      -i-\n        *      ------id------\n        * */        \n      }else{\n        p[i]=p[j]\n        continue;\n      }\n      // i不在当前max所涵盖的范围内，需要暴力计算，如下图\n      /*\n        *                     i\n        *      ------id------     => 需要扩展i\n      * */      \n    }else{\n      temp=1\n      newCenter=i\n    }\n    // 暴力计算\n    while(newCenter-temp>=0 && newCenter+temp <str.length && str[newCenter-temp]===str[newCenter+temp]){\n      temp++\n    }\n    // 暴力计算完后重新定义p[i]和max，id\n    p[i]=temp\n    if(p[i]>max-id){\n      max=p[i]+i\n      id=i\n    }\n  }\n  // 此时max-id就是最大回文字符串的length\n  \n  // 去掉# 和 $符号\n  let res=str[id],realRes=''\n  for(let i=1;i<max-id;i++){\n    res=str[id-i]+res+str[id+i]\n  }\n  for(let i=0;i<res.length;i++){\n    if(res[i]==='$' || res[i]==='#')continue\n    realRes+=res[i]\n  }\n  return realRes\n};"
  ],
  "titleSlug": "longest-palindromic-substring",
  "content": "<p>Given a string <strong>s</strong>, find the longest palindromic substring in <strong>s</strong>. You may assume that the maximum length of <strong>s</strong> is 1000.</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> &quot;babad&quot;\r\n<strong>Output:</strong> &quot;bab&quot;\r\n<strong>Note:</strong> &quot;aba&quot; is also a valid answer.\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> &quot;cbbd&quot;\r\n<strong>Output:</strong> &quot;bb&quot;\r\n</pre>\r\n",
  "translatedContent": "<p>给定一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。你可以假设&nbsp;<code>s</code> 的最大长度为 1000。</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入:</strong> &quot;babad&quot;\n<strong>输出:</strong> &quot;bab&quot;\n<strong>注意:</strong> &quot;aba&quot; 也是一个有效答案。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入:</strong> &quot;cbbd&quot;\n<strong>输出:</strong> &quot;bb&quot;\n</pre>\n"
}
