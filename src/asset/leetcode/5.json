{
  "code": [
    "<pre class=\"hljs\"><code><span class=\"hljs-comment\">/**\n * @param {string} s\n * @return {string}\n */</span>\n<span class=\"hljs-keyword\">var</span> longestPalindrome = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">str</span>) </span>{\n  <span class=\"hljs-keyword\">let</span> max=<span class=\"hljs-number\">0</span>\n  <span class=\"hljs-keyword\">let</span> maxStr=<span class=\"hljs-string\">''</span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">check</span>(<span class=\"hljs-params\">lo,hi</span>)</span>{\n    <span class=\"hljs-keyword\">let</span> count=<span class=\"hljs-number\">0</span>,s=<span class=\"hljs-string\">''</span>\n    <span class=\"hljs-keyword\">while</span>(lo&gt;=<span class=\"hljs-number\">0</span> &amp;&amp; hi&lt;str.length &amp;&amp; str[lo]===str[hi]){\n      count+=<span class=\"hljs-number\">2</span>\n      lo--\n      hi++\n    }\n    s=str.slice(lo+<span class=\"hljs-number\">1</span>,hi)\n    <span class=\"hljs-keyword\">return</span> [count,s]\n  }\n  <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i=<span class=\"hljs-number\">0</span>;i&lt;str.length;i++){\n    <span class=\"hljs-keyword\">let</span> [c1,s1]=check(i,i),\n        [c2,s2]=check(i,i+<span class=\"hljs-number\">1</span>)\n    c1--\n    <span class=\"hljs-keyword\">if</span>(c1&gt;max){\n      max=c1\n      maxStr=s1\n    }\n    <span class=\"hljs-keyword\">if</span>(c2&gt;max){\n      max=c2\n      maxStr=s2\n    }\n  }\n  <span class=\"hljs-keyword\">return</span> maxStr\n};\n</code></pre>\n"
  ],
  "titleSlug": "longest-palindromic-substring",
  "hasThinking": true,
  "thinking": "<hr>\n<p>思路：</p>\n<p>对于每一个<code>str[i]</code>，都去检查它作为回文的中心的回文长度，</p>\n<p>例如 <code>ababcba</code>，</p>\n<p>索引<code>1</code>的<code>b</code>作为中心，那么对应的回文就是<code>aba</code>，</p>\n<p>索引<code>2</code>作为中心，对应的回文就是<code>bab</code>，</p>\n<p>索引<code>4</code>作为中心，对应的回文就是<code>abcba</code>。</p>\n<p>注意的是，回文有2种，<code>ababa</code>，以<code>a</code>为中心，<code>abba</code>，以<code>bb</code>为中心，因此对于每一个索引，都要计算2种形成回文的方式，最后选择最长的。</p>\n",
  "content": "<p>给定一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。你可以假设&nbsp;<code>s</code> 的最大长度为 1000。</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入:</strong> &quot;babad&quot;\n<strong>输出:</strong> &quot;bab&quot;\n<strong>注意:</strong> &quot;aba&quot; 也是一个有效答案。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入:</strong> &quot;cbbd&quot;\n<strong>输出:</strong> &quot;bb&quot;\n</pre>\n"
}
