{
  "code": [
    "/**\n * @param {number[]} nums\n * @return {boolean}\n */\nvar increasingTriplet = function(nums) {\n    // let increase=[nums[0]]\n    // for(let i=1;i<nums.length;i++){\n    //   let cur=nums[i]\n    //   let len=increase.length\n    //   let last=increase[len-1]\n    //   if(cur>last)increase[len]=cur\n    //   else {\n    //     let idx=bs(increase,nums[i])\n    //     increase[idx]=cur\n    //   }\n    //   if(increase.length===3)return true\n    // }\n    // function bs(arr,n){\n    //   let lo=0,hi=arr.length-1\n    //   while(lo<hi){\n    //     let mid=Math.floor((lo+hi)/2)\n    //     if(arr[mid]<n)lo=mid+1\n    //     else hi=mid\n    //   }\n    //   return hi\n    // }\n    // return false\n  \n  let first=Infinity,second=Infinity\n  for(let n of nums){\n    if(n<=first)first=n\n    else if(n<=second)second=n\n    else return true\n  }\n  return false\n};"
  ],
  "titleSlug": "increasing-triplet-subsequence",
  "content": "<p>Given an unsorted array return whether an increasing subsequence of length 3 exists or not in the array.</p>\r\n\r\n<p>Formally the function should:</p>\r\n\r\n<blockquote>Return true if there exists <i>i, j, k </i><br />\r\nsuch that <i>arr[i]</i> &lt; <i>arr[j]</i> &lt; <i>arr[k]</i> given 0 &le; <i>i</i> &lt; <i>j</i> &lt; <i>k</i> &le; <i>n</i>-1 else return false.</blockquote>\r\n\r\n<p><strong>Note: </strong>Your algorithm should run in O(<i>n</i>) time complexity and O(<i>1</i>) space complexity.</p>\r\n\r\n<div>\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-1-1\">[1,2,3,4,5]</span>\r\n<strong>Output: </strong><span id=\"example-output-1\">true</span>\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-2-1\">[5,4,3,2,1]</span>\r\n<strong>Output: </strong><span id=\"example-output-2\">false</span>\r\n</pre>\r\n</div>\r\n</div>",
  "translatedContent": "<p>给定一个未排序的数组，判断这个数组中是否存在长度为 3 的递增子序列。</p>\n\n<p>数学表达式如下:</p>\n\n<blockquote>如果存在这样的&nbsp;<em>i, j, k,&nbsp;</em>&nbsp;且满足&nbsp;0 &le; <em>i</em> &lt; <em>j</em> &lt; <em>k</em> &le; <em>n</em>-1，<br>\n使得&nbsp;<em>arr[i]</em> &lt; <em>arr[j]</em> &lt; <em>arr[k] </em>，返回 true ;&nbsp;否则返回 false 。</blockquote>\n\n<p><strong>说明:</strong> 要求算法的时间复杂度为 O(<em>n</em>)，空间复杂度为 O(<em>1</em>) 。</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre><strong>输入: </strong>[1,2,3,4,5]\n<strong>输出: </strong>true\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre><strong>输入: </strong>[5,4,3,2,1]\n<strong>输出: </strong>false</pre>\n"
}
