{
  "code": [
    "<pre class=\"hljs\"><code><span class=\"hljs-comment\">/**\n * @param {character[][]} board\n * @param {string[]} words\n * @return {string[]}\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">findWords</span>(<span class=\"hljs-params\">board, words</span>) </span>{\n  <span class=\"hljs-keyword\">let</span> tire={}\n  <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i=<span class=\"hljs-number\">0</span>;i&lt;words.length;i++){\n    <span class=\"hljs-keyword\">let</span> t=tire\n    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> j=<span class=\"hljs-number\">0</span>;j&lt;words[i].length;j++){\n      <span class=\"hljs-keyword\">let</span> l=words[i][j]\n      <span class=\"hljs-keyword\">if</span>(t[l]==<span class=\"hljs-literal\">null</span>)t[l]={}\n      <span class=\"hljs-keyword\">if</span>(j===words[i].length<span class=\"hljs-number\">-1</span>){\n        t[l].word=words[i]\n      }\n      t=t[l]\n    }\n  }\n  <span class=\"hljs-keyword\">let</span> res=[]\n  <span class=\"hljs-keyword\">let</span> m=board.length,n=board[<span class=\"hljs-number\">0</span>].length\n  <span class=\"hljs-keyword\">let</span> moves=[[<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">0</span>],[<span class=\"hljs-number\">-1</span>,<span class=\"hljs-number\">0</span>],[<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">1</span>],[<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">-1</span>]]\n  <span class=\"hljs-keyword\">let</span> used=<span class=\"hljs-built_in\">Array</span>(m).fill().map(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span>=&gt;</span><span class=\"hljs-built_in\">Array</span>(n).fill(<span class=\"hljs-number\">0</span>)),uniq=<span class=\"hljs-number\">0</span>\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>; i &lt; board.length; i++) {\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> j = <span class=\"hljs-number\">0</span>; j &lt; board[<span class=\"hljs-number\">0</span>].length; j++) {\n      <span class=\"hljs-keyword\">if</span>(tire[board[i][j]]==<span class=\"hljs-literal\">null</span>)<span class=\"hljs-keyword\">continue</span>\n      uniq++\n      dfs([i,j],tire[board[i][j]])\n    }\n  }\n\n  <span class=\"hljs-keyword\">return</span> res\n\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">dfs</span>(<span class=\"hljs-params\">[x,y],tire</span>)</span>{\n    <span class=\"hljs-keyword\">if</span>(tire.word){\n      res.push(tire.word)    \n      tire.word=<span class=\"hljs-literal\">null</span>\n    }\n    used[x][y]=uniq\n    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> [dX,dY] <span class=\"hljs-keyword\">of</span> moves){\n      <span class=\"hljs-keyword\">let</span> nX=x+dX,nY=y+dY\n      <span class=\"hljs-keyword\">if</span>(nX&lt;<span class=\"hljs-number\">0</span> || nY&lt;<span class=\"hljs-number\">0</span> || nX&gt;=m || nY&gt;=n)<span class=\"hljs-keyword\">continue</span>\n      <span class=\"hljs-keyword\">if</span>(used[nX][nY]===uniq)<span class=\"hljs-keyword\">continue</span>\n      <span class=\"hljs-keyword\">if</span>(tire[board[nX][nY]]==<span class=\"hljs-literal\">null</span>)<span class=\"hljs-keyword\">continue</span>\n      dfs([nX,nY],tire[board[nX][nY]])\n    }\n    used[x][y]=uniq<span class=\"hljs-number\">-1</span>\n  }\n};\n</code></pre>\n"
  ],
  "titleSlug": "word-search-ii",
  "hasThinking": true,
  "thinking": "<hr>\n<p>思路：</p>\n<p>先对<code>words</code>构建<code>Tire</code>树，接着对<code>board</code>上每一个点作为起点，<code>dfs</code>遍历查找是否存在<code>tire.word</code>，<code>tire.word</code>意味着单词背查找到，\n如果存在，将<code>tire.word</code>添加到结果中并且设置为<code>null</code>(避免重复查找)。</p>\n",
  "content": "<p>给定一个二维网格&nbsp;<strong>board&nbsp;</strong>和一个字典中的单词列表 <strong>words</strong>，找出所有同时在二维网格和字典中出现的单词。</p>\n\n<p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中&ldquo;相邻&rdquo;单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母在一个单词中不允许被重复使用。</p>\n\n<p><strong>示例:</strong></p>\n\n<pre><strong>输入:</strong> \n<strong>words</strong> = <code>[&quot;oath&quot;,&quot;pea&quot;,&quot;eat&quot;,&quot;rain&quot;]</code> and <strong>board </strong>=\n[\n  [&#39;<strong>o</strong>&#39;,&#39;<strong>a</strong>&#39;,&#39;a&#39;,&#39;n&#39;],\n  [&#39;e&#39;,&#39;<strong>t</strong>&#39;,&#39;<strong>a</strong>&#39;,&#39;<strong>e</strong>&#39;],\n  [&#39;i&#39;,&#39;<strong>h</strong>&#39;,&#39;k&#39;,&#39;r&#39;],\n  [&#39;i&#39;,&#39;f&#39;,&#39;l&#39;,&#39;v&#39;]\n]\n\n<strong>输出:&nbsp;</strong><code>[&quot;eat&quot;,&quot;oath&quot;]</code></pre>\n\n<p><strong>说明:</strong><br>\n你可以假设所有输入都由小写字母 <code>a-z</code>&nbsp;组成。</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li>你需要优化回溯算法以通过更大数据量的测试。你能否早点停止回溯？</li>\n\t<li>如果当前单词不存在于所有单词的前缀中，则可以立即停止回溯。什么样的数据结构可以有效地执行这样的操作？散列表是否可行？为什么？ 前缀树如何？如果你想学习如何实现一个基本的前缀树，请先查看这个问题： <a href=\"/problems/implement-trie-prefix-tree/description/\">实现Trie（前缀树）</a>。</li>\n</ul>\n"
}
