{
  "code": [
    "<pre class=\"hljs\"><code><span class=\"hljs-comment\">/**\n * @param {character[][]} board\n * @param {string[]} words\n * @return {string[]}\n */</span>\n<span class=\"hljs-keyword\">var</span> findWords = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">board, words</span>) </span>{\n  <span class=\"hljs-keyword\">let</span> moves=[[<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">0</span>],[<span class=\"hljs-number\">-1</span>,<span class=\"hljs-number\">0</span>],[<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">1</span>],[<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">-1</span>]]\n  <span class=\"hljs-keyword\">let</span> hash={},find=<span class=\"hljs-literal\">false</span>\n  <span class=\"hljs-keyword\">let</span> used=[],result=[],uniqueId=<span class=\"hljs-number\">0</span>\n  <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i=<span class=\"hljs-number\">0</span>;i&lt;words.length;i++){\n    hash[words[i][<span class=\"hljs-number\">0</span>]]=<span class=\"hljs-literal\">false</span>\n  }\n  <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i=<span class=\"hljs-number\">0</span>;i&lt;board.length;i++){\n    used[i]=[]\n    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> j=<span class=\"hljs-number\">0</span>;j&lt;board[i].length;j++){\n      used[i][j]=uniqueId\n      <span class=\"hljs-keyword\">let</span> l=board[i][j]\n      <span class=\"hljs-keyword\">if</span>(hash[l]===<span class=\"hljs-literal\">false</span>)hash[l]=[[i,j]]\n      <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(hash[l]!=<span class=\"hljs-literal\">null</span>)hash[l].push([i,j])\n    }\n  }\n  <span class=\"hljs-comment\">// console.log(hash)</span>\n  words.sort()\n  <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i=<span class=\"hljs-number\">0</span>;i&lt;words.length;i++){\n    <span class=\"hljs-keyword\">let</span> head=words[i][<span class=\"hljs-number\">0</span>]\n    <span class=\"hljs-keyword\">if</span>(i&gt;<span class=\"hljs-number\">0</span> &amp;&amp; words[i]===words[i<span class=\"hljs-number\">-1</span>])<span class=\"hljs-keyword\">continue</span>\n    <span class=\"hljs-keyword\">if</span>(hash[head]){\n      <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> j=<span class=\"hljs-number\">0</span>;j&lt;hash[head].length;j++){\n        find=<span class=\"hljs-literal\">false</span>\n        uniqueId++  \n        dfs(hash[head][j],i,<span class=\"hljs-number\">1</span>)\n        <span class=\"hljs-keyword\">if</span>(find){\n          result.push(words[i])\n          <span class=\"hljs-keyword\">break</span>\n        }\n      }\n    }\n  }\n  <span class=\"hljs-keyword\">return</span> result\n  \n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">dfs</span>(<span class=\"hljs-params\">[x,y],wordIdx,letterIdx</span>)</span>{\n    <span class=\"hljs-keyword\">if</span>(letterIdx===words[wordIdx].length)<span class=\"hljs-keyword\">return</span> find=<span class=\"hljs-literal\">true</span>\n    used[x][y]=uniqueId\n    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> [dX,dY] <span class=\"hljs-keyword\">of</span> moves){\n      <span class=\"hljs-keyword\">let</span> nX=x+dX,nY=y+dY\n      <span class=\"hljs-keyword\">if</span>(nX&lt;<span class=\"hljs-number\">0</span> || nY&lt;<span class=\"hljs-number\">0</span> || nX&gt;=board.length || nY&gt;=board[<span class=\"hljs-number\">0</span>].length)<span class=\"hljs-keyword\">continue</span>\n      <span class=\"hljs-keyword\">if</span>(used[nX][nY]===uniqueId)<span class=\"hljs-keyword\">continue</span>\n      <span class=\"hljs-keyword\">if</span>(board[nX][nY]!==words[wordIdx][letterIdx])<span class=\"hljs-keyword\">continue</span>\n       dfs([nX,nY],wordIdx,letterIdx+<span class=\"hljs-number\">1</span>)\n      <span class=\"hljs-keyword\">if</span>(find)<span class=\"hljs-keyword\">return</span>\n    }\n    used[x][y]=uniqueId<span class=\"hljs-number\">-1</span>\n  }\n};\n</code></pre>\n"
  ],
  "titleSlug": "word-search-ii",
  "content": "<p>给定一个二维网格&nbsp;<strong>board&nbsp;</strong>和一个字典中的单词列表 <strong>words</strong>，找出所有同时在二维网格和字典中出现的单词。</p>\n\n<p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中&ldquo;相邻&rdquo;单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母在一个单词中不允许被重复使用。</p>\n\n<p><strong>示例:</strong></p>\n\n<pre><strong>输入:</strong> \n<strong>words</strong> = <code>[&quot;oath&quot;,&quot;pea&quot;,&quot;eat&quot;,&quot;rain&quot;]</code> and <strong>board </strong>=\n[\n  [&#39;<strong>o</strong>&#39;,&#39;<strong>a</strong>&#39;,&#39;a&#39;,&#39;n&#39;],\n  [&#39;e&#39;,&#39;<strong>t</strong>&#39;,&#39;<strong>a</strong>&#39;,&#39;<strong>e</strong>&#39;],\n  [&#39;i&#39;,&#39;<strong>h</strong>&#39;,&#39;k&#39;,&#39;r&#39;],\n  [&#39;i&#39;,&#39;f&#39;,&#39;l&#39;,&#39;v&#39;]\n]\n\n<strong>输出:&nbsp;</strong><code>[&quot;eat&quot;,&quot;oath&quot;]</code></pre>\n\n<p><strong>说明:</strong><br>\n你可以假设所有输入都由小写字母 <code>a-z</code>&nbsp;组成。</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li>你需要优化回溯算法以通过更大数据量的测试。你能否早点停止回溯？</li>\n\t<li>如果当前单词不存在于所有单词的前缀中，则可以立即停止回溯。什么样的数据结构可以有效地执行这样的操作？散列表是否可行？为什么？ 前缀树如何？如果你想学习如何实现一个基本的前缀树，请先查看这个问题： <a href=\"/problems/implement-trie-prefix-tree/description/\">实现Trie（前缀树）</a>。</li>\n</ul>\n"
}
