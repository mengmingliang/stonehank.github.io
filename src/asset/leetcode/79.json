{
  "code": [
    "<pre class=\"hljs\"><code><span class=\"hljs-comment\">/**\n * @param {character[][]} board\n * @param {string} word\n * @return {boolean}\n */</span>\n<span class=\"hljs-keyword\">var</span> exist = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">board, word</span>) </span>{\n  <span class=\"hljs-keyword\">let</span> m=board.length,n=board[<span class=\"hljs-number\">0</span>].length\n  <span class=\"hljs-keyword\">let</span> moves=[[<span class=\"hljs-number\">-1</span>,<span class=\"hljs-number\">0</span>],[<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">0</span>],[<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">1</span>],[<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">-1</span>]]\n  <span class=\"hljs-keyword\">let</span> uniq=<span class=\"hljs-number\">0</span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">dfs</span>(<span class=\"hljs-params\">[x,y],id</span>)</span>{\n    <span class=\"hljs-keyword\">if</span>(id===word.length)<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>\n    <span class=\"hljs-keyword\">if</span>(x&lt;<span class=\"hljs-number\">0</span> || y&lt;<span class=\"hljs-number\">0</span> || x&gt;=m || y&gt;=n)<span class=\"hljs-keyword\">return</span>\n    <span class=\"hljs-keyword\">if</span>(board[x][y]!==word[id])<span class=\"hljs-keyword\">return</span>\n    <span class=\"hljs-keyword\">if</span>(board[x][y]===<span class=\"hljs-string\">'*'</span>)<span class=\"hljs-keyword\">return</span>\n    <span class=\"hljs-keyword\">let</span> tmp=board[x][y]\n    board[x][y]=<span class=\"hljs-string\">'*'</span>\n    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> [dx,dy] <span class=\"hljs-keyword\">of</span> moves){\n      <span class=\"hljs-keyword\">if</span>(dfs([x+dx,y+dy],id+<span class=\"hljs-number\">1</span>))<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>\n    }\n    board[x][y]=tmp\n  }\n  <span class=\"hljs-keyword\">let</span> start=word[<span class=\"hljs-number\">0</span>]\n  <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i=<span class=\"hljs-number\">0</span>;i&lt;m;i++){\n    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> j=<span class=\"hljs-number\">0</span>;j&lt;n;j++){\n      <span class=\"hljs-keyword\">if</span>(dfs([i,j],<span class=\"hljs-number\">0</span>))<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>\n    }\n  }\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>\n};\n</code></pre>\n"
  ],
  "titleSlug": "word-search",
  "hasThinking": true,
  "thinking": "<hr>\n<p>思路：</p>\n<p><code>DFS</code>搜索，对于每一个<code>board[i][j]===word[0]</code>，都进行尝试，只要存在一个<code>true</code>，返回<code>true</code>。</p>\n<p>由于<code>dfs</code>过程中，使用<code>visited</code>，保存当前已经搜索过的路径，但每一次找到<code>board[i][j]===word[0]</code>，相当于需要一个全新的<code>visited</code>。</p>\n<p>个人之前做法，设定一个<code>uniq</code>值，初始为<code>0</code>，每当找到<code>board[i][j]===word[0]</code>，首先<code>uniq++</code>，每次检索路径<code>visited[i][j]=uniq</code>，检索完毕，<code>visited[i][j]=uniq-1</code>；\n这样做，需要创建<code>visited</code>，但只需要创建一次。</p>\n<p>更好的做法是，对于每次检索的路径，<code>board[i][j]='*'</code>，检查完毕，再改回来，这么做的最大优点是节省空间。</p>\n",
  "content": "<p>给定一个二维网格和一个单词，找出该单词是否存在于网格中。</p>\n\n<p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中&ldquo;相邻&rdquo;单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p>\n\n<p><strong>示例:</strong></p>\n\n<pre>board =\n[\n  [&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;E&#39;],\n  [&#39;S&#39;,&#39;F&#39;,&#39;C&#39;,&#39;S&#39;],\n  [&#39;A&#39;,&#39;D&#39;,&#39;E&#39;,&#39;E&#39;]\n]\n\n给定 word = &quot;<strong>ABCCED</strong>&quot;, 返回 <strong>true</strong>.\n给定 word = &quot;<strong>SEE</strong>&quot;, 返回 <strong>true</strong>.\n给定 word = &quot;<strong>ABCB</strong>&quot;, 返回 <strong>false</strong>.</pre>\n"
}
