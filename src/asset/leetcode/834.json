{
  "code": [
    "<pre class=\"hljs\"><code><span class=\"hljs-comment\">/**\n * @param {number} N\n * @param {number[][]} edges\n * @return {number[]}\n */</span>\n<span class=\"hljs-keyword\">var</span> sumOfDistancesInTree = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">N, edges</span>) </span>{\n  <span class=\"hljs-keyword\">let</span> graph=<span class=\"hljs-built_in\">Array</span>(N).fill(<span class=\"hljs-number\">0</span>).map(<span class=\"hljs-function\"><span class=\"hljs-params\">n</span>=&gt;</span>[])\n  <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i=<span class=\"hljs-number\">0</span>;i&lt;edges.length;i++){\n    <span class=\"hljs-keyword\">let</span> [v,w]=edges[i]\n    graph[v].push(w)\n    graph[w].push(v)\n  }\n  <span class=\"hljs-keyword\">let</span> root=<span class=\"hljs-number\">0</span>\n  <span class=\"hljs-comment\">// counts 定义了包括本节点和子节点的数量</span>\n  <span class=\"hljs-keyword\">let</span> counts=<span class=\"hljs-built_in\">Array</span>(N).fill(<span class=\"hljs-number\">1</span>)\n  <span class=\"hljs-keyword\">let</span> res=<span class=\"hljs-built_in\">Array</span>(N).fill(<span class=\"hljs-number\">0</span>)\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">fillCount</span>(<span class=\"hljs-params\">v,p</span>)</span>{\n    <span class=\"hljs-keyword\">let</span> adj=graph[v]\n    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> child <span class=\"hljs-keyword\">of</span> adj){\n      <span class=\"hljs-keyword\">if</span>(child===p)<span class=\"hljs-keyword\">continue</span>\n      fillCount(child,v)\n      counts[v]+=counts[child]\n      <span class=\"hljs-comment\">// res[v] += res[child] + counts[child]</span>\n    }\n  }\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">fillRes</span>(<span class=\"hljs-params\">v,p</span>)</span>{\n    <span class=\"hljs-keyword\">let</span> adj=graph[v]\n    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i=<span class=\"hljs-number\">0</span>;i&lt;adj.length;i++){\n      <span class=\"hljs-keyword\">if</span>(adj[i]===p)<span class=\"hljs-keyword\">continue</span>\n      <span class=\"hljs-comment\">// res[adj[i]]=res[v]-counts[adj[i]]+N-counts[adj[i]]</span>\n      <span class=\"hljs-comment\">// 当前 i 节点的 和 = 它的父节点v 的和 + </span>\n      <span class=\"hljs-comment\">// 变得更远的距离(除了当前counts[i](当前节点和子节点)以外的节点数量) - </span>\n      <span class=\"hljs-comment\">// 变得更近的距离(counts[i](当前节点和子节点)的节点数量)</span>\n      res[adj[i]]=res[v]+(N-counts[adj[i]])-counts[adj[i]]\n      fillRes(adj[i],v)\n    }\n  }\n  fillCount(root,root)\n  <span class=\"hljs-comment\">// console.log(counts)</span>\n  <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> j=<span class=\"hljs-number\">1</span>;j&lt;counts.length;j++){\n    res[<span class=\"hljs-number\">0</span>]+=counts[j]\n  }\n  fillRes(root,root)\n  <span class=\"hljs-keyword\">return</span> res\n\n};\n</code></pre>\n"
  ],
  "titleSlug": "sum-of-distances-in-tree",
  "thinking": "<hr>\n<p>思路：</p>\n<p>我们要计算一个节点i到其余节点的和<code>res[i]</code>，有2种办法，</p>\n<ol>\n<li>暴力解，直接对每一个节点计算它到其他所有节点的和，时间复杂度是<code>O(n^2)</code>不符合要求</li>\n<li>通过它的父节点的<code>p</code>的<code>res[p]</code>，来推导出<code>res[i]</code>的结果，这样，我们只需要计算一次根节点的<code>res[root]</code>，\n其他的节点的结果都可以通过推导求出，最终时间复杂度<code>O(n)</code>，具体步骤如下：</li>\n</ol>\n<ul>\n<li>\n<p>定义一个<code>count</code>为以<code>0</code>为根节点，包含当前节点和它的所有子节点数量的数组。</p>\n</li>\n<li>\n<p>首先求出<code>res[0]</code>,这时如果想求出<code>0</code>节点的子节点<code>i</code>，</p>\n<p>当要计算<code>i</code>到其余节点的和时，<code>i</code>相对<code>0</code>来说，有一部分节点离它更近了，也有一部分节点离它更远了。</p>\n<ul>\n<li>离得更近的节点：<code>count[i]</code></li>\n<li>离得更远的节点：<code>N-count[i]</code></li>\n</ul>\n<p>因此最后，要加上离得更远的节点的数量，再减去离得更近的节点的数量。</p>\n<p><code>res[i]=res[0] + (N-count[i]) - count[i]</code></p>\n</li>\n</ul>\n",
  "content": "<p>给定一个无向、连通的树。树中有 <code>N</code> 个标记为 <code>0...N-1</code> 的节点以及 <code>N-1</code>&nbsp;条边&nbsp;。</p>\n\n<p>第 <code>i</code> 条边连接节点&nbsp;<code>edges[i][0]</code> 和 <code>edges[i][1]</code>&nbsp;。</p>\n\n<p>返回一个表示节点 <code>i</code> 与其他所有节点距离之和的列表 <code>ans</code>。</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入: </strong>N = 6, edges = [[0,1],[0,2],[2,3],[2,4],[2,5]]\n<strong>输出: </strong>[8,12,6,10,10,10]\n<strong>解释: </strong>\n如下为给定的树的示意图：\n  0\n / \\\n1   2\n   /|\\\n  3 4 5\n\n我们可以计算出 dist(0,1) + dist(0,2) + dist(0,3) + dist(0,4) + dist(0,5) \n也就是 1 + 1 + 2 + 2 + 2 = 8。 因此，answer[0] = 8，以此类推。\n</pre>\n\n<p><strong>说明:</strong>&nbsp;<code>1 &lt;= N &lt;= 10000</code></p>\n",
  "hasThinking": true
}
