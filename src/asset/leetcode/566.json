{
  "code": [
    "/**\n * @param {number[][]} nums\n * @param {number} r\n * @param {number} c\n * @return {number[][]}\n */\nvar matrixReshape = function(nums, r, c) {\n    const oldCount=nums.length*nums[0].length\n    const newCount=r*c\n    if(oldCount===newCount && (r!==nums.length && c!==nums[0].length)){\n        let allData=[]\n        let res=[]\n        for(let i=0;i<nums.length;i++){\n            allData=allData.concat(nums[i])\n        }\n        for(let i=0;i<r;i++){\n            res.push(allData.splice(0,c))\n        }\n        return res\n    }else{\n        return nums\n    }\n};"
  ],
  "titleSlug": "reshape-the-matrix",
  "content": "<p>In MATLAB, there is a very useful function called 'reshape', which can reshape a matrix into a new one with different size but keep its original data.\r\n</p>\r\n\r\n<p>\r\nYou're given a matrix represented by a two-dimensional array, and two <b>positive</b> integers <b>r</b> and <b>c</b> representing the <b>row</b> number and <b>column</b> number of the wanted reshaped matrix, respectively.</p>\r\n\r\n <p>The reshaped matrix need to be filled with all the elements of the original matrix in the same <b>row-traversing</b> order as they were.\r\n</p>\r\n\r\n<p>\r\nIf the 'reshape' operation with given parameters is possible and legal, output the new reshaped matrix; Otherwise, output the original matrix.\r\n</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> \r\nnums = \r\n[[1,2],\r\n [3,4]]\r\nr = 1, c = 4\r\n<b>Output:</b> \r\n[[1,2,3,4]]\r\n<b>Explanation:</b><br>The <b>row-traversing</b> of nums is [1,2,3,4]. The new reshaped matrix is a 1 * 4 matrix, fill it row by row by using the previous list.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 2:</b><br />\r\n<pre>\r\n<b>Input:</b> \r\nnums = \r\n[[1,2],\r\n [3,4]]\r\nr = 2, c = 4\r\n<b>Output:</b> \r\n[[1,2],\r\n [3,4]]\r\n<b>Explanation:</b><br>There is no way to reshape a 2 * 2 matrix to a 2 * 4 matrix. So output the original matrix.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b><br>\r\n<ol>\r\n<li>The height and width of the given matrix is in range [1, 100].</li>\r\n<li>The given r and c are all positive.</li>\r\n</ol>\r\n</p>",
  "translatedContent": "<p>在MATLAB中，有一个非常有用的函数 <code>reshape</code>，它可以将一个矩阵重塑为另一个大小不同的新矩阵，但保留其原始数据。</p>\n\n<p>给出一个由二维数组表示的矩阵，以及两个正整数<code>r</code>和<code>c</code>，分别表示想要的重构的矩阵的行数和列数。</p>\n\n<p>重构后的矩阵需要将原始矩阵的所有元素以相同的<strong>行遍历顺序</strong>填充。</p>\n\n<p>如果具有给定参数的<code>reshape</code>操作是可行且合理的，则输出新的重塑矩阵；否则，输出原始矩阵。</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> \nnums = \n[[1,2],\n [3,4]]\nr = 1, c = 4\n<strong>输出:</strong> \n[[1,2,3,4]]\n<strong>解释:</strong>\n行遍历nums的结果是 [1,2,3,4]。新的矩阵是 1 * 4 矩阵, 用之前的元素值一行一行填充新矩阵。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> \nnums = \n[[1,2],\n [3,4]]\nr = 2, c = 4\n<strong>输出:</strong> \n[[1,2],\n [3,4]]\n<strong>解释:</strong>\n没有办法将 2 * 2 矩阵转化为 2 * 4 矩阵。 所以输出原矩阵。\n</pre>\n\n<p><strong>注意：</strong></p>\n\n<ol>\n\t<li>给定矩阵的宽和高范围在 [1, 100]。</li>\n\t<li>给定的 r 和 c 都是正数。</li>\n</ol>\n"
}
