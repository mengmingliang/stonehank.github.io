{
  "code": [
    "/**\n * @param {number[]} pushed\n * @param {number[]} popped\n * @return {boolean}\n */\nvar validateStackSequences = function(pushed, popped) {\n  let mem={},popMem={}\n  for(let i=0;i<pushed.length;i++){\n    mem[pushed[i]]=i\n  }\n  for(let i=0;i<popped.length;i++){\n    popMem[popped[i]]=i\n  }\n  // let used=Array(pushed.length).fill(false)\n  let posted=Array(pushed.length).fill(false)\n  for(let i=0;i<popped.length;i++){\n    let idx=mem[popped[i]]\n    // used[idx]=true\n    posted[idx]=true\n    // if(used[idx-1])continue\n    // 最后一个则将之前未排的倒序\n    if(idx===popped.length-1){\n      let step=i+1\n      for(let k=posted.length-1;k>=0;k--){\n        if(posted[k])continue\n        if(pushed[k]!==popped[step++])return false\n      }\n    }else{\n      // // 非最后一个\n      // let slice=pushed.slice(0,idx)\n      // let lastIdx=popped.length\n      // for(let j=0;j<slice.length;j++){\n      //   if(used[j])continue\n      //   used[j]=true\n      //   let cur=popMem[slice[j]]\n      //   if(cur<lastIdx){\n      //     lastIdx=cur\n      //   }else{\n      //     return false\n      //   }\n      // }\n    }\n  }\n  return true\n  // let j=0,s=[]\n  //  for (let i=0;i<pushed.length;i++) {\n  //     s.push(pushed[i]);\n  //     while (s.length>0 && s[s.length-1] == popped[j]) {\n  //         s.pop();\n  //         j++;\n  //     }\n  //   }\n  // return j == popped.length;\n};"
  ],
  "titleSlug": "validate-stack-sequences",
  "content": "<p>Given two sequences <code>pushed</code> and <code>popped</code>&nbsp;<strong>with distinct values</strong>,&nbsp;return <code>true</code> if and only if this could have been the result of a sequence of push and pop operations on an initially empty stack.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<div>\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>pushed = <span id=\"example-input-1-1\">[1,2,3,4,5]</span>, popped = <span id=\"example-input-1-2\">[4,5,3,2,1]</span>\r\n<strong>Output: </strong><span id=\"example-output-1\">true</span>\r\n<strong>Explanation: </strong>We might do the following sequence:\r\npush(1), push(2), push(3), push(4), pop() -&gt; 4,\r\npush(5), pop() -&gt; 5, pop() -&gt; 3, pop() -&gt; 2, pop() -&gt; 1\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>pushed = <span id=\"example-input-2-1\">[1,2,3,4,5]</span>, popped = <span id=\"example-input-2-2\">[4,3,5,1,2]</span>\r\n<strong>Output: </strong><span id=\"example-output-2\">false</span>\r\n<strong>Explanation: </strong>1 cannot be popped before 2.\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ol>\r\n\t<li><code>0 &lt;= pushed.length == popped.length &lt;= 1000</code></li>\r\n\t<li><code>0 &lt;= pushed[i], popped[i] &lt; 1000</code></li>\r\n\t<li><code>pushed</code> is a permutation of <code>popped</code>.</li>\r\n\t<li><code>pushed</code> and <code>popped</code> have distinct values.</li>\r\n</ol>\r\n</div>\r\n</div>",
  "translatedContent": "<p>给定&nbsp;<code>pushed</code>&nbsp;和&nbsp;<code>popped</code>&nbsp;两个序列，只有当它们可能是在最初空栈上进行的推入 push 和弹出 pop 操作序列的结果时，返回 <code>true</code>；否则，返回 <code>false</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>pushed = [1,2,3,4,5], popped = [4,5,3,2,1]\n<strong>输出：</strong>true\n<strong>解释：</strong>我们可以按以下顺序执行：\npush(1), push(2), push(3), push(4), pop() -&gt; 4,\npush(5), pop() -&gt; 5, pop() -&gt; 3, pop() -&gt; 2, pop() -&gt; 1\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>pushed = [1,2,3,4,5], popped = [4,3,5,1,2]\n<strong>输出：</strong>false\n<strong>解释：</strong>1 不能在 2 之前弹出。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ol>\n\t<li><code>0 &lt;= pushed.length == popped.length &lt;= 1000</code></li>\n\t<li><code>0 &lt;= pushed[i], popped[i] &lt; 1000</code></li>\n\t<li><code>pushed</code>&nbsp;是&nbsp;<code>popped</code>&nbsp;的排列。</li>\n</ol>\n"
}
