{
  "code": [
    "<pre class=\"hljs\"><code><span class=\"hljs-comment\">/**\n * @param {number[]} pushed\n * @param {number[]} popped\n * @return {boolean}\n */</span>\n<span class=\"hljs-keyword\">var</span> validateStackSequences = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">pushed, popped</span>) </span>{\n  <span class=\"hljs-keyword\">let</span> mem={},popMem={}\n  <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i=<span class=\"hljs-number\">0</span>;i&lt;pushed.length;i++){\n    mem[pushed[i]]=i\n  }\n  <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i=<span class=\"hljs-number\">0</span>;i&lt;popped.length;i++){\n    popMem[popped[i]]=i\n  }\n  <span class=\"hljs-comment\">// let used=Array(pushed.length).fill(false)</span>\n  <span class=\"hljs-keyword\">let</span> posted=<span class=\"hljs-built_in\">Array</span>(pushed.length).fill(<span class=\"hljs-literal\">false</span>)\n  <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i=<span class=\"hljs-number\">0</span>;i&lt;popped.length;i++){\n    <span class=\"hljs-keyword\">let</span> idx=mem[popped[i]]\n    <span class=\"hljs-comment\">// used[idx]=true</span>\n    posted[idx]=<span class=\"hljs-literal\">true</span>\n    <span class=\"hljs-comment\">// if(used[idx-1])continue</span>\n    <span class=\"hljs-comment\">// 最后一个则将之前未排的倒序</span>\n    <span class=\"hljs-keyword\">if</span>(idx===popped.length<span class=\"hljs-number\">-1</span>){\n      <span class=\"hljs-keyword\">let</span> step=i+<span class=\"hljs-number\">1</span>\n      <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> k=posted.length<span class=\"hljs-number\">-1</span>;k&gt;=<span class=\"hljs-number\">0</span>;k--){\n        <span class=\"hljs-keyword\">if</span>(posted[k])<span class=\"hljs-keyword\">continue</span>\n        <span class=\"hljs-keyword\">if</span>(pushed[k]!==popped[step++])<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>\n      }\n    }<span class=\"hljs-keyword\">else</span>{\n      <span class=\"hljs-comment\">// // 非最后一个</span>\n      <span class=\"hljs-comment\">// let slice=pushed.slice(0,idx)</span>\n      <span class=\"hljs-comment\">// let lastIdx=popped.length</span>\n      <span class=\"hljs-comment\">// for(let j=0;j&lt;slice.length;j++){</span>\n      <span class=\"hljs-comment\">//   if(used[j])continue</span>\n      <span class=\"hljs-comment\">//   used[j]=true</span>\n      <span class=\"hljs-comment\">//   let cur=popMem[slice[j]]</span>\n      <span class=\"hljs-comment\">//   if(cur&lt;lastIdx){</span>\n      <span class=\"hljs-comment\">//     lastIdx=cur</span>\n      <span class=\"hljs-comment\">//   }else{</span>\n      <span class=\"hljs-comment\">//     return false</span>\n      <span class=\"hljs-comment\">//   }</span>\n      <span class=\"hljs-comment\">// }</span>\n    }\n  }\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>\n  <span class=\"hljs-comment\">// let j=0,s=[]</span>\n  <span class=\"hljs-comment\">//  for (let i=0;i&lt;pushed.length;i++) {</span>\n  <span class=\"hljs-comment\">//     s.push(pushed[i]);</span>\n  <span class=\"hljs-comment\">//     while (s.length&gt;0 &amp;&amp; s[s.length-1] == popped[j]) {</span>\n  <span class=\"hljs-comment\">//         s.pop();</span>\n  <span class=\"hljs-comment\">//         j++;</span>\n  <span class=\"hljs-comment\">//     }</span>\n  <span class=\"hljs-comment\">//   }</span>\n  <span class=\"hljs-comment\">// return j == popped.length;</span>\n};\n</code></pre>\n"
  ],
  "titleSlug": "validate-stack-sequences",
  "content": "<p>给定&nbsp;<code>pushed</code>&nbsp;和&nbsp;<code>popped</code>&nbsp;两个序列，只有当它们可能是在最初空栈上进行的推入 push 和弹出 pop 操作序列的结果时，返回 <code>true</code>；否则，返回 <code>false</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>pushed = [1,2,3,4,5], popped = [4,5,3,2,1]\n<strong>输出：</strong>true\n<strong>解释：</strong>我们可以按以下顺序执行：\npush(1), push(2), push(3), push(4), pop() -&gt; 4,\npush(5), pop() -&gt; 5, pop() -&gt; 3, pop() -&gt; 2, pop() -&gt; 1\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>pushed = [1,2,3,4,5], popped = [4,3,5,1,2]\n<strong>输出：</strong>false\n<strong>解释：</strong>1 不能在 2 之前弹出。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ol>\n\t<li><code>0 &lt;= pushed.length == popped.length &lt;= 1000</code></li>\n\t<li><code>0 &lt;= pushed[i], popped[i] &lt; 1000</code></li>\n\t<li><code>pushed</code>&nbsp;是&nbsp;<code>popped</code>&nbsp;的排列。</li>\n</ol>\n"
}
