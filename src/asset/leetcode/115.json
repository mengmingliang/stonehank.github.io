{
  "code": [
    "<pre class=\"hljs\"><code><span class=\"hljs-comment\">/**\n * @param {string} s\n * @param {string} t\n * @return {number}\n */</span>\n<span class=\"hljs-keyword\">var</span> numDistinct = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">s, t</span>) </span>{\n  <span class=\"hljs-keyword\">let</span> M=t.length, N=s.length\n  <span class=\"hljs-keyword\">let</span> dp=<span class=\"hljs-built_in\">Array</span>(M+<span class=\"hljs-number\">1</span>).fill().map(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span>=&gt;</span><span class=\"hljs-built_in\">Array</span>(N+<span class=\"hljs-number\">1</span>).fill(<span class=\"hljs-number\">0</span>))\n  <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i=<span class=\"hljs-number\">0</span>;i&lt;N;i++){\n    dp[<span class=\"hljs-number\">0</span>][i]=<span class=\"hljs-number\">1</span>\n  }\n  <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i=<span class=\"hljs-number\">1</span>;i&lt;=M;i++){\n    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> j=<span class=\"hljs-number\">1</span>;j&lt;=N;j++){\n      <span class=\"hljs-keyword\">let</span> si=j<span class=\"hljs-number\">-1</span>,ti=i<span class=\"hljs-number\">-1</span>\n      <span class=\"hljs-keyword\">if</span>(s[si]===t[ti]){\n        dp[i][j]=dp[i<span class=\"hljs-number\">-1</span>][j<span class=\"hljs-number\">-1</span>]+dp[i][j<span class=\"hljs-number\">-1</span>]\n      }<span class=\"hljs-keyword\">else</span>{\n        dp[i][j]=dp[i][j<span class=\"hljs-number\">-1</span>]\n      }\n    }\n  }\n  <span class=\"hljs-keyword\">return</span> dp[M][N]\n};\n</code></pre>\n"
  ],
  "titleSlug": "distinct-subsequences",
  "hasThinking": true,
  "thinking": "<hr>\n<p>思路：</p>\n<p>DP，<code>dp[i][j]</code>表示<code>[0,i]</code>区间的<code>t</code>和<code>[0,j]</code>区间的<code>s</code>，之间有多少个独立子序列。</p>\n<p>设置所有<code>dp[0][i]</code>为<code>true</code>，表示当<code>t</code>为空字符串时，总是存在1个独立子序列。</p>\n<p>当<code>s[j-1]===t[i-1]</code>，那么<code>dp[i][j]</code>就是除了当前相等的两个的序列数(<code>dp[i-1][j-1]</code>)和上一个<code>s</code>和当前<code>j</code>能匹配的序列数(<code>dp[i][j-1]</code>)。</p>\n<p>方程为：<code>dp[i][j]=dp[i-1][j-1]+dp[i][j-1]</code></p>\n<p>当<code>s[j-1]!==t[i-1]</code>，那么只需要将上一次<code>s</code>与当前<code>j</code>的匹配数赋值给当前<code>dp[i][j]</code>。</p>\n<p>方程为：<code>dp[i][j]=dp[i][j-1]</code></p>\n",
  "content": "<p>给定一个字符串&nbsp;<strong>S&nbsp;</strong>和一个字符串&nbsp;<strong>T</strong>，计算在 <strong>S</strong> 的子序列中 <strong>T</strong> 出现的个数。</p>\n\n<p>一个字符串的一个子序列是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，<code>&quot;ACE&quot;</code>&nbsp;是&nbsp;<code>&quot;ABCDE&quot;</code>&nbsp;的一个子序列，而&nbsp;<code>&quot;AEC&quot;</code>&nbsp;不是）</p>\n\n<p><strong>示例&nbsp;1:</strong></p>\n\n<pre><strong>输入: </strong>S = <code>&quot;rabbbit&quot;</code>, T = <code>&quot;rabbit&quot;\n<strong>输出:</strong>&nbsp;3\n</code><strong>解释:\n</strong>\n如下图所示, 有 3 种可以从 S 中得到 <code>&quot;rabbit&quot; 的方案</code>。\n(上箭头符号 ^ 表示选取的字母)\n\n<code>rabbbit</code>\n^^^^ ^^\n<code>rabbbit</code>\n^^ ^^^^\n<code>rabbbit</code>\n^^^ ^^^\n</pre>\n\n<p><strong>示例&nbsp;2:</strong></p>\n\n<pre><strong>输入: </strong>S = <code>&quot;babgbag&quot;</code>, T = <code>&quot;bag&quot;\n<strong>输出:</strong>&nbsp;5\n</code><strong>解释:\n</strong>\n如下图所示, 有 5 种可以从 S 中得到 <code>&quot;bag&quot; 的方案</code>。 \n(上箭头符号 ^ 表示选取的字母)\n\n<code>babgbag</code>\n^^ ^\n<code>babgbag</code>\n^^    ^\n<code>babgbag</code>\n^    ^^\n<code>babgbag</code>\n  ^  ^^\n<code>babgbag</code>\n    ^^^</pre>\n"
}
