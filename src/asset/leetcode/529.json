{
  "code": [
    "<pre class=\"hljs\"><code><span class=\"hljs-comment\">/**\n * @param {character[][]} board\n * @param {number[]} click\n * @return {character[][]}\n */</span>\n<span class=\"hljs-keyword\">var</span> updateBoard = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">board, click</span>) </span>{\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">reveal</span>(<span class=\"hljs-params\">board,i,j</span>)</span>{\n    <span class=\"hljs-keyword\">if</span>(board[i][j]===<span class=\"hljs-string\">\"M\"</span>)board[i][j]=<span class=\"hljs-string\">\"X\"</span>\n    <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(board[i][j]===<span class=\"hljs-string\">\"E\"</span>){\n      checkAdj(board,i,j)\n    }\n  }\n    \n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">checkAdj</span>(<span class=\"hljs-params\">b,i,j</span>)</span>{\n    <span class=\"hljs-keyword\">let</span> mine=<span class=\"hljs-number\">0</span>\n    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> k=i<span class=\"hljs-number\">-1</span>;k&lt;i+<span class=\"hljs-number\">2</span>;k++){\n      <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> l=j<span class=\"hljs-number\">-1</span>;l&lt;j+<span class=\"hljs-number\">2</span>;l++){\n        <span class=\"hljs-keyword\">if</span>(k&lt;<span class=\"hljs-number\">0</span> || l&lt;<span class=\"hljs-number\">0</span> || k&gt;b.length<span class=\"hljs-number\">-1</span> || l&gt;b[k].length<span class=\"hljs-number\">-1</span> ||(k===i &amp;&amp; l===j))<span class=\"hljs-keyword\">continue</span>\n        <span class=\"hljs-keyword\">if</span>(b[k][l]===<span class=\"hljs-string\">\"M\"</span>)mine++\n      }\n    }\n    <span class=\"hljs-keyword\">if</span>(mine&gt;<span class=\"hljs-number\">0</span>)b[i][j]=mine+<span class=\"hljs-string\">''</span>\n    <span class=\"hljs-keyword\">else</span>{\n      b[i][j]=<span class=\"hljs-string\">'B'</span>\n      <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> k=i<span class=\"hljs-number\">-1</span>;k&lt;i+<span class=\"hljs-number\">2</span>;k++){\n        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> l=j<span class=\"hljs-number\">-1</span>;l&lt;j+<span class=\"hljs-number\">2</span>;l++){\n          <span class=\"hljs-keyword\">if</span>(k&lt;<span class=\"hljs-number\">0</span> || l&lt;<span class=\"hljs-number\">0</span> || k&gt;b.length<span class=\"hljs-number\">-1</span> || l&gt;b[k].length<span class=\"hljs-number\">-1</span> ||(k===i &amp;&amp; l===j))<span class=\"hljs-keyword\">continue</span>\n          reveal(b,k,l)\n        }\n      }\n    }\n  }\n  reveal(board,click[<span class=\"hljs-number\">0</span>],click[<span class=\"hljs-number\">1</span>])\n    <span class=\"hljs-keyword\">return</span> board\n};\n</code></pre>\n"
  ],
  "titleSlug": "minesweeper",
  "translatedContent": "<p>让我们一起来玩扫雷游戏！</p>\r\n\r\n<p>给定一个代表游戏板的二维字符矩阵。&nbsp;<strong>&#39;M&#39;</strong>&nbsp;代表一个<strong>未挖出的</strong>地雷，<strong>&#39;E&#39;</strong>&nbsp;代表一个<strong>未挖出的</strong>空方块，<strong>&#39;B&#39;&nbsp;</strong>代表没有相邻（上，下，左，右，和所有4个对角线）地雷的<strong>已挖出的</strong>空白方块，<strong>数字</strong>（&#39;1&#39; 到 &#39;8&#39;）表示有多少地雷与这块<strong>已挖出的</strong>方块相邻，<strong>&#39;X&#39;</strong>&nbsp;则表示一个<strong>已挖出的</strong>地雷。</p>\r\n\r\n<p>现在给出在所有<strong>未挖出的</strong>方块中（&#39;M&#39;或者&#39;E&#39;）的下一个点击位置（行和列索引），根据以下规则，返回相应位置被点击后对应的面板：</p>\r\n\r\n<ol>\r\n\t<li>如果一个地雷（&#39;M&#39;）被挖出，游戏就结束了- 把它改为&nbsp;<strong>&#39;X&#39;</strong>。</li>\r\n\t<li>如果一个<strong>没有相邻地雷</strong>的空方块（&#39;E&#39;）被挖出，修改它为（&#39;B&#39;），并且所有和其相邻的方块都应该被递归地揭露。</li>\r\n\t<li>如果一个<strong>至少与一个地雷相邻</strong>的空方块（&#39;E&#39;）被挖出，修改它为数字（&#39;1&#39;到&#39;8&#39;），表示相邻地雷的数量。</li>\r\n\t<li>如果在此次点击中，若无更多方块可被揭露，则返回面板。</li>\r\n</ol>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>示例 1：</strong></p>\r\n\r\n<pre><strong>输入:</strong> \r\n\r\n[[&#39;E&#39;, &#39;E&#39;, &#39;E&#39;, &#39;E&#39;, &#39;E&#39;],\r\n [&#39;E&#39;, &#39;E&#39;, &#39;M&#39;, &#39;E&#39;, &#39;E&#39;],\r\n [&#39;E&#39;, &#39;E&#39;, &#39;E&#39;, &#39;E&#39;, &#39;E&#39;],\r\n [&#39;E&#39;, &#39;E&#39;, &#39;E&#39;, &#39;E&#39;, &#39;E&#39;]]\r\n\r\nClick : [3,0]\r\n\r\n<strong>输出:</strong> \r\n\r\n[[&#39;B&#39;, &#39;1&#39;, &#39;E&#39;, &#39;1&#39;, &#39;B&#39;],\r\n [&#39;B&#39;, &#39;1&#39;, &#39;M&#39;, &#39;1&#39;, &#39;B&#39;],\r\n [&#39;B&#39;, &#39;1&#39;, &#39;1&#39;, &#39;1&#39;, &#39;B&#39;],\r\n [&#39;B&#39;, &#39;B&#39;, &#39;B&#39;, &#39;B&#39;, &#39;B&#39;]]\r\n\r\n<strong>解释:</strong>\r\n<img src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/minesweeper_example_1.png\" style=\"width: 100%; max-width: 400px\">\r\n</pre>\r\n\r\n<p><strong>示例 2：</strong></p>\r\n\r\n<pre><strong>输入:</strong> \r\n\r\n[[&#39;B&#39;, &#39;1&#39;, &#39;E&#39;, &#39;1&#39;, &#39;B&#39;],\r\n [&#39;B&#39;, &#39;1&#39;, &#39;M&#39;, &#39;1&#39;, &#39;B&#39;],\r\n [&#39;B&#39;, &#39;1&#39;, &#39;1&#39;, &#39;1&#39;, &#39;B&#39;],\r\n [&#39;B&#39;, &#39;B&#39;, &#39;B&#39;, &#39;B&#39;, &#39;B&#39;]]\r\n\r\nClick : [1,2]\r\n\r\n<strong>输出:</strong> \r\n\r\n[[&#39;B&#39;, &#39;1&#39;, &#39;E&#39;, &#39;1&#39;, &#39;B&#39;],\r\n [&#39;B&#39;, &#39;1&#39;, &#39;X&#39;, &#39;1&#39;, &#39;B&#39;],\r\n [&#39;B&#39;, &#39;1&#39;, &#39;1&#39;, &#39;1&#39;, &#39;B&#39;],\r\n [&#39;B&#39;, &#39;B&#39;, &#39;B&#39;, &#39;B&#39;, &#39;B&#39;]]\r\n\r\n<strong>解释:</strong>\r\n<img src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/minesweeper_example_2.png\" style=\"width: 100%; max-width: 400px\">\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>注意：</strong></p>\r\n\r\n<ol>\r\n\t<li>输入矩阵的宽和高的范围为 [1,50]。</li>\r\n\t<li>点击的位置只能是未被挖出的方块 (&#39;M&#39; 或者 &#39;E&#39;)，这也意味着面板至少包含一个可点击的方块。</li>\r\n\t<li>输入面板不会是游戏结束的状态（即有地雷已被挖出）。</li>\r\n\t<li>简单起见，未提及的规则在这个问题中可被忽略。例如，当游戏结束时你不需要挖出所有地雷，考虑所有你可能赢得游戏或标记方块的情况。</li>\r\n</ol>"
}
