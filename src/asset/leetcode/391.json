{
  "code": [
    "<pre class=\"hljs\"><code><span class=\"hljs-comment\">/**\n * @param {number[][]} rectangles\n * @return {boolean}\n */</span>\n<span class=\"hljs-keyword\">var</span> isRectangleCover = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">rectangles</span>) </span>{\n  <span class=\"hljs-keyword\">let</span> hash=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Map</span>()\n  <span class=\"hljs-keyword\">let</span> area=<span class=\"hljs-number\">0</span>\n  <span class=\"hljs-keyword\">let</span> minX=<span class=\"hljs-literal\">Infinity</span>,minY=<span class=\"hljs-literal\">Infinity</span>,maxX=-<span class=\"hljs-literal\">Infinity</span>,maxY=-<span class=\"hljs-literal\">Infinity</span>\n  <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i=<span class=\"hljs-number\">0</span>;i&lt;rectangles.length;i++){\n    <span class=\"hljs-keyword\">let</span> [x1,y1,x2,y2]=rectangles[i]\n    minX=<span class=\"hljs-built_in\">Math</span>.min(minX,x1)\n    minY=<span class=\"hljs-built_in\">Math</span>.min(minY,y1)\n    maxX=<span class=\"hljs-built_in\">Math</span>.max(maxX,x2)\n    maxY=<span class=\"hljs-built_in\">Math</span>.max(maxY,y2)\n    area+=(x2-x1)*(y2-y1)\n    deleteAtDouble(x1+<span class=\"hljs-string\">'-'</span>+y2)\n    deleteAtDouble(x1+<span class=\"hljs-string\">'-'</span>+y1)\n    deleteAtDouble(x2+<span class=\"hljs-string\">'-'</span>+y2)\n    deleteAtDouble(x2+<span class=\"hljs-string\">'-'</span>+y1)\n  }\n  \n  <span class=\"hljs-keyword\">if</span>(hash.size!==<span class=\"hljs-number\">4</span>)<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>\n  <span class=\"hljs-keyword\">if</span>(!(hash.has(minX+<span class=\"hljs-string\">'-'</span>+minY) &amp;&amp;\n       hash.has(minX+<span class=\"hljs-string\">'-'</span>+maxY) &amp;&amp;\n       hash.has(maxX+<span class=\"hljs-string\">'-'</span>+minY) &amp;&amp;\n       hash.has(maxX+<span class=\"hljs-string\">'-'</span>+maxY)))\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>\n\n  <span class=\"hljs-keyword\">if</span>(area!==(maxX-minX)*(maxY-minY))<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>\n  \n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>\n  \n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">deleteAtDouble</span>(<span class=\"hljs-params\">key</span>)</span>{\n    <span class=\"hljs-keyword\">if</span>(!hash.has(key))hash.set(key,<span class=\"hljs-number\">1</span>)\n    <span class=\"hljs-keyword\">else</span> hash.delete(key)\n  }\n};\n</code></pre>\n"
  ],
  "titleSlug": "perfect-rectangle",
  "hasThinking": true,
  "thinking": "<hr>\n<p>思路：</p>\n<p>题目定义的完美矩形，包括2个方面：</p>\n<ol>\n<li>每一个矩形的面积和与整个矩形的面积相等。</li>\n<li>任意两个矩形都是不相交的。</li>\n</ol>\n<p>如果按照上面做，对每一个矩形都要与另外所有的矩形检查是否相交，因此时间复杂度是<code>O(N^2)</code>，整体算法速度较慢。</p>\n<p>因此对于第<code>2</code>点，需要优化；如果2个矩形不相交，那么除了他们合并的大矩形的四个边角出现的次数只有<code>1</code>次，其余所有点出现的次数都是偶数次。</p>\n<p>因此可以定义一个<code>hash</code>，<code>hash</code>保存每一个点出现的次数，如果当前点是边角点，那么只能出现1次；\n其他情况只能出现偶数次；</p>\n<h2>再次优化，可以考虑在每个点出现<code>2</code>次的时候，删除这个点，因此最后<code>hash</code>内的值只有<code>4</code>个边角点，可以降低空间使用。</h2>\n",
  "content": "<p>我们有 N 个与坐标轴对齐的矩形, 其中 N &gt; 0, 判断它们是否能精确地覆盖一个矩形区域。</p>\n\n<p>每个矩形用左下角的点和右上角的点的坐标来表示。例如，&nbsp;一个单位正方形可以表示为 [1,1,2,2]。&nbsp;( 左下角的点的坐标为 (1, 1) 以及右上角的点的坐标为 (2, 2) )。</p>\n\n<p><img src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rectangle_perfect.gif\"></p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>rectangles = [\n  [1,1,3,3],\n  [3,1,4,2],\n  [3,2,4,4],\n  [1,3,2,4],\n  [2,3,3,4]\n]\n\n返回 true。5个矩形一起可以精确地覆盖一个矩形区域。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><img src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rectangle_separated.gif\"></p>\n\n<p><strong>示例&nbsp;2:</strong></p>\n\n<pre>rectangles = [\n  [1,1,2,3],\n  [1,3,2,4],\n  [3,1,4,2],\n  [3,2,4,4]\n]\n\n返回 false。两个矩形之间有间隔，无法覆盖成一个矩形。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><img src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rectangle_hole.gif\"></p>\n\n<p><strong>示例 3:</strong></p>\n\n<pre>rectangles = [\n  [1,1,3,3],\n  [3,1,4,2],\n  [1,3,2,4],\n  [3,2,4,4]\n]\n\n返回 false。图形顶端留有间隔，无法覆盖成一个矩形。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><img src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rectangle_intersect.gif\"></p>\n\n<p><strong>示例 4:</strong></p>\n\n<pre>rectangles = [\n  [1,1,3,3],\n  [3,1,4,2],\n  [1,3,2,4],\n  [2,2,4,4]\n]\n\n返回 false。因为中间有相交区域，虽然形成了矩形，但不是精确覆盖。\n</pre>\n"
}
