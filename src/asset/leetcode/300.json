{
  "code": [
    "<pre class=\"hljs\"><code><span class=\"hljs-comment\">/**\n * @param {number[]} nums\n * @return {number}\n */</span>\n<span class=\"hljs-keyword\">var</span> lengthOfLIS = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">arr</span>) </span>{\n  <span class=\"hljs-keyword\">if</span>(arr.length===<span class=\"hljs-number\">0</span>)<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>\n  <span class=\"hljs-comment\">// let longestLens=Array(arr.length).fill(1)</span>\n  <span class=\"hljs-comment\">// let preIndex=0,curIndex=1</span>\n  <span class=\"hljs-comment\">// while(curIndex&lt;arr.length){</span>\n  <span class=\"hljs-comment\">//   if(arr[curIndex]&gt;arr[preIndex]){</span>\n  <span class=\"hljs-comment\">//     let curLen=longestLens[preIndex]+1</span>\n  <span class=\"hljs-comment\">//     longestLens[curIndex]=Math.max(longestLens[curIndex],curLen)</span>\n  <span class=\"hljs-comment\">//   }</span>\n  <span class=\"hljs-comment\">//   preIndex++</span>\n  <span class=\"hljs-comment\">//   if(preIndex===curIndex){</span>\n  <span class=\"hljs-comment\">//     preIndex=0</span>\n  <span class=\"hljs-comment\">//     curIndex++</span>\n  <span class=\"hljs-comment\">//   }</span>\n  <span class=\"hljs-comment\">// }</span>\n  <span class=\"hljs-comment\">// let maxLen=0</span>\n  <span class=\"hljs-comment\">// for(let i=0;i&lt;longestLens.length;i++){</span>\n  <span class=\"hljs-comment\">//   if(longestLens[i]&gt;maxLen)maxLen=longestLens[i]</span>\n  <span class=\"hljs-comment\">// }</span>\n  <span class=\"hljs-comment\">// return maxLen</span>\n  \n  \n  <span class=\"hljs-keyword\">let</span> len=<span class=\"hljs-number\">1</span>\n  <span class=\"hljs-keyword\">let</span> temp=[]\n  <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i=<span class=\"hljs-number\">0</span>;i&lt;arr.length;i++){\n    <span class=\"hljs-keyword\">if</span>(temp.length===<span class=\"hljs-number\">0</span>)temp.push(arr[i])\n    <span class=\"hljs-keyword\">else</span>{\n      <span class=\"hljs-keyword\">if</span>(temp[temp.length<span class=\"hljs-number\">-1</span>]&gt;=arr[i]){\n        <span class=\"hljs-keyword\">let</span> idx=binarySearch(arr[i],temp)\n        temp[idx]=arr[i]\n      }<span class=\"hljs-keyword\">else</span>{\n        temp.push(arr[i])\n        len++\n      }\n      <span class=\"hljs-comment\">// console.log(temp,len)</span>\n    }\n  }\n  <span class=\"hljs-keyword\">return</span> len\n  \n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">binarySearch</span>(<span class=\"hljs-params\">n,arr</span>)</span>{\n    <span class=\"hljs-keyword\">let</span> lo=<span class=\"hljs-number\">0</span>,hi=arr.length<span class=\"hljs-number\">-1</span>\n    <span class=\"hljs-keyword\">while</span>(lo&lt;hi){\n      <span class=\"hljs-keyword\">let</span> mid=<span class=\"hljs-built_in\">Math</span>.floor((lo+hi)/<span class=\"hljs-number\">2</span>)\n      <span class=\"hljs-keyword\">if</span>(arr[mid]&gt;=n)hi=mid\n      <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(arr[mid]&lt;n)lo=mid+<span class=\"hljs-number\">1</span>\n    }\n  <span class=\"hljs-keyword\">return</span> hi\n}\n};\n</code></pre>\n"
  ],
  "titleSlug": "longest-increasing-subsequence",
  "thinking": "<hr>\n<p>思路：</p>\n<p>这道题用<code>DP</code>解就是<code>O(n^2)</code>时间复杂度。</p>\n<ul>\n<li>创建一个<code>dp数组</code>，用来储存每个<code>index</code>及它之前的最长子序列，<code>dp[j]</code>会去检查前面的每一个<code>dp[i]</code>，如果<code>nums[i]&lt;nums[j]</code>，\n那么<code>dp[j]=Math.max(dp[j],dp[i]+1)</code>。</li>\n</ul>\n<p>另外一个<code>O(nlgn)</code>的方法不太容易想到，需要搭建一个<code>单调递增数组</code>。</p>\n<ul>\n<li>\n<p>维护一个数组<code>stack</code>，当<code>stack[-1]</code>比当前<code>nums[i]</code>小的时候，直接<code>append</code>，如果更大，需要二分搜索到<code>nums[i]</code>应该存在的位置，\n并且替换，最终<code>stack</code>的长度就是最长结果。</p>\n<p>例如<code>[1,3,6,7,9,4,10,5,6]</code></p>\n<p>当<code>nums[i]</code>为<code>4</code>时，<code>stack</code>为<code>[1,3,6,7,9]</code>\n当<code>nums[i]</code>为<code>10</code>时，<code>stack</code>为<code>[1,3,4,7,9]</code></p>\n</li>\n</ul>\n",
  "content": "<p>给定一个无序的整数数组，找到其中最长上升子序列的长度。</p>\n\n<p><strong>示例:</strong></p>\n\n<pre><strong>输入:</strong> <code>[10,9,2,5,3,7,101,18]\n</code><strong>输出: </strong>4 \n<strong>解释: </strong>最长的上升子序列是&nbsp;<code>[2,3,7,101]，</code>它的长度是 <code>4</code>。</pre>\n\n<p><strong>说明:</strong></p>\n\n<ul>\n\t<li>可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。</li>\n\t<li>你算法的时间复杂度应该为&nbsp;O(<em>n<sup>2</sup></em>) 。</li>\n</ul>\n\n<p><strong>进阶:</strong> 你能将算法的时间复杂度降低到&nbsp;O(<em>n</em> log <em>n</em>) 吗?</p>\n",
  "hasThinking": true
}
