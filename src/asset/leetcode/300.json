{
  "code": [
    "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar lengthOfLIS = function(arr) {\n  if(arr.length===0)return 0\n  // let longestLens=Array(arr.length).fill(1)\n  // let preIndex=0,curIndex=1\n  // while(curIndex<arr.length){\n  //   if(arr[curIndex]>arr[preIndex]){\n  //     let curLen=longestLens[preIndex]+1\n  //     longestLens[curIndex]=Math.max(longestLens[curIndex],curLen)\n  //   }\n  //   preIndex++\n  //   if(preIndex===curIndex){\n  //     preIndex=0\n  //     curIndex++\n  //   }\n  // }\n  // let maxLen=0\n  // for(let i=0;i<longestLens.length;i++){\n  //   if(longestLens[i]>maxLen)maxLen=longestLens[i]\n  // }\n  // return maxLen\n  \n  \n  let len=1\n  let temp=[]\n  for(let i=0;i<arr.length;i++){\n    if(temp.length===0)temp.push(arr[i])\n    else{\n      if(temp[temp.length-1]>=arr[i]){\n        let idx=binarySearch(arr[i],temp)\n        temp[idx]=arr[i]\n      }else{\n        temp.push(arr[i])\n        len++\n      }\n      // console.log(temp,len)\n    }\n  }\n  return len\n  \n  function binarySearch(n,arr){\n    let lo=0,hi=arr.length-1\n    while(lo<hi){\n      let mid=Math.floor((lo+hi)/2)\n      if(arr[mid]>=n)hi=mid\n      else if(arr[mid]<n)lo=mid+1\n    }\n  return hi\n}\n};"
  ],
  "titleSlug": "longest-increasing-subsequence",
  "content": "<p>Given an unsorted array of integers, find the length of longest increasing subsequence.</p>\r\n\r\n<p><b>Example:</b></p>\r\n\r\n<pre>\r\n<b>Input:</b> <code>[10,9,2,5,3,7,101,18]\r\n</code><b>Output: </b>4 \r\n<strong>Explanation: </strong>The longest increasing subsequence is <code>[2,3,7,101]</code>, therefore the length is <code>4</code>. </pre>\r\n\r\n<p><strong>Note: </strong></p>\r\n\r\n<ul>\r\n\t<li>There may be more than one LIS combination, it is only necessary for you to return the length.</li>\r\n\t<li>Your algorithm should run in O(<i>n<sup>2</sup></i>) complexity.</li>\r\n</ul>\r\n\r\n<p><b>Follow up:</b> Could you improve it to O(<i>n</i> log <i>n</i>) time complexity?</p>\r\n",
  "translatedContent": "<p>给定一个无序的整数数组，找到其中最长上升子序列的长度。</p>\n\n<p><strong>示例:</strong></p>\n\n<pre><strong>输入:</strong> <code>[10,9,2,5,3,7,101,18]\n</code><strong>输出: </strong>4 \n<strong>解释: </strong>最长的上升子序列是&nbsp;<code>[2,3,7,101]，</code>它的长度是 <code>4</code>。</pre>\n\n<p><strong>说明:</strong></p>\n\n<ul>\n\t<li>可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。</li>\n\t<li>你算法的时间复杂度应该为&nbsp;O(<em>n<sup>2</sup></em>) 。</li>\n</ul>\n\n<p><strong>进阶:</strong> 你能将算法的时间复杂度降低到&nbsp;O(<em>n</em> log <em>n</em>) 吗?</p>\n"
}
