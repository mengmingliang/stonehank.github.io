{
  "code": [
    "<pre class=\"hljs\"><code><span class=\"hljs-comment\">/**\n * @param {number[]} A\n * @return {number}\n */</span>\n<span class=\"hljs-keyword\">var</span> largestComponentSize = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">A</span>) </span>{\n  <span class=\"hljs-comment\">// 求质数</span>\n  <span class=\"hljs-keyword\">let</span> prime=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Set</span>()\n  prime.add(<span class=\"hljs-number\">2</span>)\n  prime.add(<span class=\"hljs-number\">3</span>)\n  <span class=\"hljs-keyword\">let</span> limit=<span class=\"hljs-built_in\">Math</span>.max.apply(<span class=\"hljs-built_in\">Math</span>,A)\n  <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i=<span class=\"hljs-number\">3</span>;i&lt;=limit;i+=<span class=\"hljs-number\">2</span>){\n    <span class=\"hljs-keyword\">let</span> is=<span class=\"hljs-literal\">true</span>\n    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> p <span class=\"hljs-keyword\">of</span> prime){\n      <span class=\"hljs-keyword\">if</span>(i % p===<span class=\"hljs-number\">0</span>){\n        is=<span class=\"hljs-literal\">false</span>\n        <span class=\"hljs-keyword\">break</span>\n      }\n    }\n    <span class=\"hljs-keyword\">if</span>(is)prime.add(i)\n  }\n  <span class=\"hljs-comment\">// 初始化并查集</span>\n  <span class=\"hljs-keyword\">let</span> connect=[],weight=<span class=\"hljs-built_in\">Array</span>(A.length).fill(<span class=\"hljs-number\">1</span>)\n  <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i=<span class=\"hljs-number\">0</span>;i&lt;A.length;i++){\n    connect[i]=i\n  }\n\n  <span class=\"hljs-keyword\">let</span> max=<span class=\"hljs-number\">0</span>\n  <span class=\"hljs-comment\">// 用来保存是否存在连通</span>\n  <span class=\"hljs-keyword\">let</span> primeToIndex=<span class=\"hljs-built_in\">Array</span>(<span class=\"hljs-number\">100001</span>).fill(<span class=\"hljs-number\">-1</span>)\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>; i &lt; A.length; i++) {\n      <span class=\"hljs-keyword\">let</span> a = A[i];\n      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> p <span class=\"hljs-keyword\">of</span> prime) {\n          <span class=\"hljs-comment\">// 如果当前a是质数，直接处理这个质数，然后跳过此次遍历</span>\n          <span class=\"hljs-keyword\">if</span> (prime.has(a)) { <span class=\"hljs-comment\">// Optimization</span>\n              p = a;\n          }\n          <span class=\"hljs-keyword\">if</span> (a % p == <span class=\"hljs-number\">0</span>) {\n              <span class=\"hljs-keyword\">if</span> (primeToIndex[p] &gt; <span class=\"hljs-number\">-1</span>) {\n                  union(  primeToIndex[p], i);\n              }\n              primeToIndex[p] = i;\n              <span class=\"hljs-keyword\">while</span> (a % p == <span class=\"hljs-number\">0</span>) {\n                  a /= p;\n              }\n          }\n          <span class=\"hljs-keyword\">if</span> (a == <span class=\"hljs-number\">1</span>) {\n              <span class=\"hljs-keyword\">break</span>;\n          }\n      }\n  }\n  <span class=\"hljs-keyword\">return</span> max;\n\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">union</span>(<span class=\"hljs-params\">a,b</span>)</span>{\n    <span class=\"hljs-keyword\">let</span> i=find(a), j=find(b)\n    <span class=\"hljs-keyword\">if</span>(i===j)<span class=\"hljs-keyword\">return</span>\n    <span class=\"hljs-keyword\">let</span> count=weight[i]+weight[j]\n    max=<span class=\"hljs-built_in\">Math</span>.max(max,count)\n    <span class=\"hljs-keyword\">if</span>(weight[i]&lt;weight[j]){\n      weight[j]+=weight[i]\n      connect[i]=j\n    }<span class=\"hljs-keyword\">else</span>{\n      weight[i]+=weight[j]\n      connect[j]=i\n    }\n  }\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">find</span>(<span class=\"hljs-params\">i</span>)</span>{\n    <span class=\"hljs-keyword\">while</span>(connect[i]!==i){\n      i=connect[i]\n    }\n    <span class=\"hljs-keyword\">return</span> i\n  }\n};\n</code></pre>\n"
  ],
  "titleSlug": "largest-component-size-by-common-factor",
  "content": "<p>给定一个由不同正整数的组成的非空数组 <code>A</code>，考虑下面的图：</p>\n\n<ul>\n\t<li>有&nbsp;<code>A.length</code>&nbsp;个节点，按从&nbsp;<code>A[0]</code>&nbsp;到&nbsp;<code>A[A.length - 1]</code>&nbsp;标记；</li>\n\t<li>只有当 <code>A[i]</code> 和 <code>A[j]</code> 共用一个大于 1 的公因数时，<code>A[i]</code>&nbsp;和 <code>A[j]</code> 之间才有一条边。</li>\n</ul>\n\n<p>返回图中最大连通组件的大小。</p>\n\n<p>&nbsp;</p>\n\n<ol>\n</ol>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>[4,6,15,35]\n<strong>输出：</strong>4\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-uploads/uploads/2018/12/01/ex1.png\" style=\"height: 37px; width: 255px;\"><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/01/ex1.png\" style=\"height: 50px; width: 257px;\">\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>[20,50,9,63]\n<strong>输出：</strong>2\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/01/ex2.png\" style=\"height: 50px; width: 293px;\">\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>[2,3,6,7,4,12,21,39]\n<strong>输出：</strong>8\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/01/ex3.png\" style=\"height: 180px; width: 346px;\">\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ol>\n\t<li><code>1 &lt;= A.length &lt;= 20000</code></li>\n\t<li><code>1 &lt;= A[i] &lt;= 100000</code></li>\n</ol>\n"
}
