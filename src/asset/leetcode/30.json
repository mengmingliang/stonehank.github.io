{
  "code": [
    "<pre class=\"hljs\"><code><span class=\"hljs-comment\">/**\n * @param {string} s\n * @param {string[]} words\n * @return {number[]}\n */</span>\n<span class=\"hljs-keyword\">var</span> findSubstring = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">s, words</span>) </span>{\n  <span class=\"hljs-keyword\">let</span> hash={}\n  <span class=\"hljs-keyword\">let</span> acode=<span class=\"hljs-string\">\"a\"</span>.charCodeAt(<span class=\"hljs-number\">0</span>)\n  <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> w <span class=\"hljs-keyword\">of</span> words){\n    <span class=\"hljs-keyword\">if</span>(hash[w]==<span class=\"hljs-literal\">null</span>)hash[w]=<span class=\"hljs-number\">1</span>\n    <span class=\"hljs-keyword\">else</span> hash[w]++\n  }\n  <span class=\"hljs-keyword\">let</span> tire={},len=<span class=\"hljs-number\">0</span>\n  <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i=<span class=\"hljs-number\">0</span>;i&lt;words.length;i++){\n    <span class=\"hljs-keyword\">let</span> t=tire\n    len+=words[i].length\n    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> j=<span class=\"hljs-number\">0</span>;j&lt;words[i].length;j++){\n      <span class=\"hljs-keyword\">let</span> code=words[i].charCodeAt(j)-acode\n      <span class=\"hljs-keyword\">if</span>(!t[code])t[code]={}\n      t=t[code]\n      <span class=\"hljs-keyword\">if</span>(j===words[i].length<span class=\"hljs-number\">-1</span>)t.idx=i\n    }\n  }\n  \n  <span class=\"hljs-keyword\">let</span> res=[]\n\n  <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i=<span class=\"hljs-number\">0</span>;i&lt;=s.length-len;i++){\n    <span class=\"hljs-keyword\">let</span> t=tire\n    <span class=\"hljs-keyword\">let</span> used={}\n    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> j=i;j&lt;i+len;j++){\n      <span class=\"hljs-keyword\">let</span> code=s.charCodeAt(j)-acode\n      t=t[code]\n      <span class=\"hljs-keyword\">if</span>(!t)<span class=\"hljs-keyword\">break</span>\n      <span class=\"hljs-keyword\">if</span>(t.idx!=<span class=\"hljs-literal\">null</span>){\n        <span class=\"hljs-keyword\">let</span> curWord=words[t.idx]\n        <span class=\"hljs-keyword\">if</span>(!used[curWord])used[curWord]=<span class=\"hljs-number\">1</span>\n        <span class=\"hljs-keyword\">else</span> used[curWord]++\n        <span class=\"hljs-keyword\">if</span>(used[curWord]&gt;hash[curWord]) <span class=\"hljs-keyword\">break</span>\n        t=tire\n      }      \n      <span class=\"hljs-keyword\">if</span>(j===i+len<span class=\"hljs-number\">-1</span>) res.push(i)\n    }\n  }\n  <span class=\"hljs-keyword\">return</span> res\n};\n</code></pre>\n"
  ],
  "titleSlug": "substring-with-concatenation-of-all-words",
  "hasThinking": true,
  "thinking": "<hr>\n<p>两种思路，</p>\n<p>一：因为题目提示了<code>words</code>内的长度都相等，因此，我们先用2个<code>hash</code>分别保存<code>words</code>内部单词的重复数量和每个单词的首字母，\n并且去除单词的长度<code>eachLen</code>和所有单词总长度<code>allLen</code>。</p>\n<p>遍历<code>s</code>，一旦发现存在匹配首字母，我们可以根据<code>eachLen</code>来判断当前单词是否存在<code>words</code>中，如果存在，记录它的次数，\n一旦发现它的次数&gt;原<code>words</code>中次数，相当于失败。</p>\n<p>如果当遍历了<code>allLen</code>的长度后，说明成功，记录这时候的<code>索引</code>。</p>\n<pre class=\"hljs\"><code><span class=\"hljs-comment\">/**\n * @param {string} s\n * @param {string[]} words\n * @return {number[]}\n */</span>\n<span class=\"hljs-keyword\">var</span> findSubstring = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">s, words</span>) </span>{\n  <span class=\"hljs-keyword\">let</span> hash={},head={}\n  <span class=\"hljs-keyword\">let</span> eachLen=<span class=\"hljs-number\">0</span>,allLen=<span class=\"hljs-number\">0</span>\n  <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> w <span class=\"hljs-keyword\">of</span> words){\n    eachLen=w.length\n    allLen+=w.length\n    head[w[<span class=\"hljs-number\">0</span>]]=<span class=\"hljs-literal\">true</span>\n    <span class=\"hljs-keyword\">if</span>(hash[w]==<span class=\"hljs-literal\">null</span>)hash[w]=<span class=\"hljs-number\">1</span>\n    <span class=\"hljs-keyword\">else</span> hash[w]++\n  }\n  <span class=\"hljs-keyword\">let</span> res=[]\n  <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i=<span class=\"hljs-number\">0</span>;i&lt;=s.length-allLen;i++){\n    <span class=\"hljs-keyword\">let</span> used={}\n    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> j=i;j&lt;allLen+i;j+=eachLen){\n      <span class=\"hljs-keyword\">if</span>(!head[s[j]])<span class=\"hljs-keyword\">break</span>\n      <span class=\"hljs-keyword\">let</span> checkWord=s.substring(j,j+eachLen)\n      <span class=\"hljs-keyword\">if</span>(!hash[checkWord])<span class=\"hljs-keyword\">break</span>\n      <span class=\"hljs-keyword\">if</span>(!used[checkWord])used[checkWord]=<span class=\"hljs-number\">1</span>\n      <span class=\"hljs-keyword\">else</span> used[checkWord]++\n      <span class=\"hljs-keyword\">if</span>(used[checkWord]&gt;hash[checkWord])<span class=\"hljs-keyword\">break</span>\n      <span class=\"hljs-keyword\">if</span>(j===allLen+i-eachLen)res.push(i)\n    }\n  }\n  <span class=\"hljs-keyword\">return</span> res\n};\n</code></pre>\n<p>二：不需要管<code>words</code>内的长度是否相等，我们使用简化的<code>tire</code>记录<code>words</code>内的所有字母，当到一个单词的最后一个字母时，\n使用一个<code>idx</code>属性保存这个单词在<code>words</code>内的索引，同时也用一个<code>hash</code>保存`words·内部单词的重复数量。</p>\n<p>遍历<code>s</code>，不断判断每一个字母是否符合<code>tire</code>，如果发现存在<code>tire.idx</code>说明一个单词判断到最尾部，这时，记录一下这个单词的使用次数，\n如果发现使用次数&gt;原<code>words</code>内的次数，失败。</p>\n<p>如果当遍历了<code>allLen</code>的长度后，说明成功，记录这时候的<code>索引</code>。</p>\n",
  "content": "<p>给定一个字符串&nbsp;<strong>s&nbsp;</strong>和一些长度相同的单词&nbsp;<strong>words。</strong>找出 <strong>s </strong>中恰好可以由&nbsp;<strong>words </strong>中所有单词串联形成的子串的起始位置。</p>\n\n<p>注意子串要与&nbsp;<strong>words </strong>中的单词完全匹配，中间不能有其他字符，但不需要考虑&nbsp;<strong>words&nbsp;</strong>中单词串联的顺序。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：\n  s =</strong> &quot;barfoothefoobarman&quot;,\n<strong>  words = </strong>[&quot;foo&quot;,&quot;bar&quot;]\n<strong>输出：</strong><code>[0,9]</code>\n<strong>解释：</strong>\n从索引 0 和 9 开始的子串分别是 &quot;barfoor&quot; 和 &quot;foobar&quot; 。\n输出的顺序不重要, [9,0] 也是有效答案。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：\n  s =</strong> &quot;wordgoodgoodgoodbestword&quot;,\n<strong>  words = </strong>[&quot;word&quot;,&quot;good&quot;,&quot;best&quot;,&quot;word&quot;]\n<code><span style=\"\"><strong>输出：</strong></span>[]</code>\n</pre>\n"
}
