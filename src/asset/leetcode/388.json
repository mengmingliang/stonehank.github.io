{
  "code": [
    "<pre class=\"hljs\"><code><span class=\"hljs-comment\">/**\n * @param {string} input\n * @return {number}\n */</span>\n<span class=\"hljs-keyword\">var</span> lengthLongestPath = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">input</span>) </span>{\n  <span class=\"hljs-keyword\">let</span> arr=input.split(<span class=\"hljs-string\">'\\n'</span>)\n  <span class=\"hljs-keyword\">let</span> used=<span class=\"hljs-built_in\">Array</span>(arr.length).fill(<span class=\"hljs-literal\">false</span>) \n  <span class=\"hljs-keyword\">let</span> maxLen=<span class=\"hljs-number\">0</span>\n  dfs(<span class=\"hljs-number\">-1</span>,<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">0</span>,<span class=\"hljs-literal\">false</span>)\n  <span class=\"hljs-keyword\">return</span> maxLen\n  \n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">dfs</span>(<span class=\"hljs-params\">len,startIdx,nxtCount,hasFile</span>)</span>{\n    <span class=\"hljs-keyword\">if</span>(hasFile)maxLen=<span class=\"hljs-built_in\">Math</span>.max(maxLen,len)\n    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i=startIdx;i&lt;arr.length;i++){\n      <span class=\"hljs-keyword\">if</span>(used[i])<span class=\"hljs-keyword\">continue</span>\n      <span class=\"hljs-keyword\">let</span> curS=arr[i], curCount=<span class=\"hljs-number\">0</span>, isFile=<span class=\"hljs-literal\">false</span>, s=<span class=\"hljs-string\">''</span>\n      <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> j=<span class=\"hljs-number\">0</span>;j&lt;curS.length;j++){\n        <span class=\"hljs-keyword\">if</span>(curS[j]===<span class=\"hljs-string\">'\\t'</span>){\n          curCount++\n        }<span class=\"hljs-keyword\">else</span>{\n          <span class=\"hljs-keyword\">if</span>(curS[j]===<span class=\"hljs-string\">'.'</span>)isFile=<span class=\"hljs-literal\">true</span>\n          s+=curS[j]\n        }\n      }   \n      <span class=\"hljs-comment\">// 更少的`\\t`说明是一个新的路径，而不是当前路径的继续</span>\n      <span class=\"hljs-keyword\">if</span>(curCount&lt;nxtCount)<span class=\"hljs-keyword\">return</span> \n      <span class=\"hljs-comment\">// 说明有2个文件，不符合路径要求</span>\n      <span class=\"hljs-keyword\">if</span>(hasFile &amp;&amp; isFile)<span class=\"hljs-keyword\">continue</span>\n      <span class=\"hljs-keyword\">if</span>(curCount===nxtCount){\n        used[i]=<span class=\"hljs-literal\">true</span>\n        dfs(len+s.length+<span class=\"hljs-number\">1</span>,i+<span class=\"hljs-number\">1</span>,nxtCount+<span class=\"hljs-number\">1</span>,hasFile || isFile)\n      }\n    }\n  }\n};\n</code></pre>\n"
  ],
  "titleSlug": "longest-absolute-file-path",
  "hasThinking": true,
  "thinking": "<hr>\n<p>思路：</p>\n<p><code>dfs</code>递归遍历，定义几个参数：</p>\n<ul>\n<li><code>len</code>：当前路径的长度</li>\n<li><code>startIdx</code>：从哪个索引开始查找下一个路径</li>\n<li><code>nxtCount</code>：下一个路径中<code>\\t</code>应该有多少才符合要求</li>\n<li><code>hasFile</code>：当前路径是否存在文件</li>\n</ul>\n<p>在递归时，除了从当前<code>arr[i]</code>中找到多少个<code>\\t</code>，并且检查是否和<code>nxtCount</code>匹配外，还要注意，</p>\n<ol>\n<li>\n<p>如果当前<code>\\t</code>的数量小于<code>nxtCount</code>，更少的<code>\\t</code>说明后面将会是一个新的路径，而不是当前路径的继续，直接<code>return</code>；</p>\n</li>\n<li>\n<p>如果当前的路径存在<code>.</code>，说明是一个文件，但如果参数<code>hasFile</code>为<code>true</code>，说明已经存在文件了，两个文件在一起不符合要求，<code>continue</code>；</p>\n</li>\n<li>\n<p>如果<code>nxtCount</code>和当前路径的<code>\\t</code>数量相同，说明下一个路径是有效的，继续<code>dfs</code>递归，注意通过一个<code>hash</code>保存下当前的索引，以避免后续新路径的重复计算。</p>\n</li>\n</ol>\n<hr>\n",
  "content": "<p>假设我们以下述方式将我们的文件系统抽象成一个字符串:</p>\n\n<p>字符串&nbsp;<code>&quot;dir\\n\\tsubdir1\\n\\tsubdir2\\n\\t\\tfile.ext&quot;</code> 表示:</p>\n\n<pre>\ndir\n    subdir1\n    subdir2\n        file.ext\n</pre>\n\n<p>目录&nbsp;<code>dir</code> 包含一个空的子目录&nbsp;<code>subdir1</code> 和一个包含一个文件&nbsp;<code>file.ext</code>&nbsp;的子目录&nbsp;<code>subdir2</code> 。</p>\n\n<p>字符串&nbsp;<code>&quot;dir\\n\\tsubdir1\\n\\t\\tfile1.ext\\n\\t\\tsubsubdir1\\n\\tsubdir2\\n\\t\\tsubsubdir2\\n\\t\\t\\tfile2.ext&quot;</code> 表示:</p>\n\n<pre>\ndir\n    subdir1\n        file1.ext\n        subsubdir1\n    subdir2\n        subsubdir2\n            file2.ext\n</pre>\n\n<p>目录&nbsp;<code>dir</code> 包含两个子目录 <code>subdir1</code> 和&nbsp;<code>subdir2</code>。&nbsp;<code>subdir1</code> 包含一个文件&nbsp;<code>file1.ext</code> 和一个空的二级子目录 <code>subsubdir1</code>。<code>subdir2</code> 包含一个二级子目录&nbsp;<code>subsubdir2</code> ，其中包含一个文件&nbsp;<code>file2.ext</code>。</p>\n\n<p>我们致力于寻找我们文件系统中文件的最长 (按字符的数量统计) 绝对路径。例如，在上述的第二个例子中，最长路径为&nbsp;<code>&quot;dir/subdir2/subsubdir2/file2.ext&quot;</code>，其长度为&nbsp;<code>32</code> (不包含双引号)。</p>\n\n<p>给定一个以上述格式表示文件系统的字符串，返回文件系统中文件的最长绝对路径的长度。 如果系统中没有文件，返回&nbsp;<code>0</code>。</p>\n\n<p><strong>说明:</strong></p>\n\n<ul>\n\t<li>文件名至少存在一个&nbsp;<code>.</code> 和一个扩展名。</li>\n\t<li>目录或者子目录的名字不能包含&nbsp;<code>.</code>。</li>\n</ul>\n\n<p>要求时间复杂度为&nbsp;<code>O(n)</code>&nbsp;，其中&nbsp;<code>n</code> 是输入字符串的大小。</p>\n\n<p>请注意，如果存在路径&nbsp;<code>aaaaaaaaaaaaaaaaaaaaa/sth.png</code>&nbsp;的话，那么&nbsp;&nbsp;<code>a/aa/aaa/file1.txt</code>&nbsp;就不是一个最长的路径。</p>\n"
}
