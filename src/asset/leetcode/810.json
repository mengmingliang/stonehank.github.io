{
  "code": [
    "<pre class=\"hljs\"><code><span class=\"hljs-comment\">/**\n * @param {number[]} nums\n * @return {boolean}\n */</span>\n<span class=\"hljs-keyword\">var</span> xorGame = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">nums</span>) </span>{\n  <span class=\"hljs-comment\">// /*---Recursion with memo---*/</span>\n  <span class=\"hljs-comment\">// let init=nums[0]</span>\n  <span class=\"hljs-comment\">// for(let i=1;i&lt;nums.length;i++){</span>\n  <span class=\"hljs-comment\">//   init=init ^ nums[i]</span>\n  <span class=\"hljs-comment\">// }</span>\n  <span class=\"hljs-comment\">// if(init===0)return true</span>\n  <span class=\"hljs-comment\">// let used=[]</span>\n  <span class=\"hljs-comment\">// let mem1={},mem2={}</span>\n  <span class=\"hljs-comment\">// return choose(true,init,nums.length)</span>\n  <span class=\"hljs-comment\">// function choose(aTurn,XORSum,restLen){</span>\n  <span class=\"hljs-comment\">//   if(aTurn &amp;&amp; mem1[XORSum]!=null)return mem1[XORSum]</span>\n  <span class=\"hljs-comment\">//   else if(!aTurn &amp;&amp; mem2[XORSum]!=null)return mem2[XORSum]</span>\n  <span class=\"hljs-comment\">//   let nxt=false</span>\n  <span class=\"hljs-comment\">//   for(let i=0;i&lt;nums.length;i++){</span>\n  <span class=\"hljs-comment\">//     if(used[i])continue</span>\n  <span class=\"hljs-comment\">//     if((XORSum ^ nums[i])===0)continue</span>\n  <span class=\"hljs-comment\">//     if(aTurn &amp;&amp; mem1[XORSum ^ nums[i]]!=null)return mem1[XORSum ^ nums[i]]</span>\n  <span class=\"hljs-comment\">//     else if(!aTurn &amp;&amp; mem2[XORSum ^ nums[i]]!=null)return mem2[XORSum ^ nums[i]]</span>\n  <span class=\"hljs-comment\">//     used[i]=true</span>\n  <span class=\"hljs-comment\">//     nxt=!choose(!aTurn,XORSum ^ nums[i],restLen-1)</span>\n  <span class=\"hljs-comment\">//     used[i]=false</span>\n  <span class=\"hljs-comment\">//     if(nxt)break</span>\n  <span class=\"hljs-comment\">//   }</span>\n  <span class=\"hljs-comment\">//   if(aTurn)mem1[XORSum]=nxt</span>\n  <span class=\"hljs-comment\">//   else mem2[XORSum]=nxt</span>\n  <span class=\"hljs-comment\">//   return nxt</span>\n  <span class=\"hljs-comment\">// }</span>\n  \n  <span class=\"hljs-comment\">// /*---Greedy-每次找出当前不会输的那一个选项---*/</span>\n  <span class=\"hljs-comment\">// let XOR = nums.reduce((val, n) =&gt; val^n, 0);</span>\n  <span class=\"hljs-comment\">// if (XOR === 0) return true;</span>\n  <span class=\"hljs-comment\">// let isAlice = true;</span>\n  <span class=\"hljs-comment\">// while(XOR !== 0) {</span>\n  <span class=\"hljs-comment\">//   let idx=nums.findIndex(n =&gt; n!==XOR);</span>\n  <span class=\"hljs-comment\">//   if(idx ===-1) break;</span>\n  <span class=\"hljs-comment\">//   XOR^=nums[idx]</span>\n  <span class=\"hljs-comment\">//   nums.splice(idx, 1);</span>\n  <span class=\"hljs-comment\">//   isAlice = !isAlice;</span>\n  <span class=\"hljs-comment\">// }</span>\n  <span class=\"hljs-comment\">// return !isAlice;</span>\n  \n  <span class=\"hljs-comment\">/*---Mathematical---*/</span>\n  <span class=\"hljs-keyword\">let</span> xor = <span class=\"hljs-number\">0</span>;\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i <span class=\"hljs-keyword\">of</span> nums) xor ^= i;\n  <span class=\"hljs-keyword\">return</span> xor == <span class=\"hljs-number\">0</span> || nums.length % <span class=\"hljs-number\">2</span> == <span class=\"hljs-number\">0</span>;\n};\n</code></pre>\n"
  ],
  "titleSlug": "chalkboard-xor-game",
  "hasThinking": true,
  "thinking": "<hr>\n<p>思路：</p>\n<p>这道题用了3种解法，</p>\n<p>解法一：<code>Recursion With Memo</code></p>\n<p>对<code>小红</code>和<code>小明</code>他们各自每一轮面对的<code>XOR</code>值进行储存，分别储存在<code>memA</code>和<code>memB</code>内(这里必须分开储存，否则会有冲突)。</p>\n<p>函数内部遍历<code>nums</code>，使用<code>used</code>记录已经判断过的索引，对其余的每一个进行判断。</p>\n<p>虽然能<code>Accept</code>，但也是<code>2000+ms</code>，不算一个太好的解决方案。</p>\n<p>解法二：<code>Greedy</code></p>\n<p>每一轮只找到当前这一轮不会输的<strong>第一个</strong>选项，接着更新<code>XOR</code>值，更新<code>nums</code>数组(删除这一次的选项)。</p>\n<p>直到最后<code>XOR===0</code>，当前轮的玩家就是胜利者。</p>\n<p>解法三：<code>Mathematical</code></p>\n<h2>只要满足初始<code>XOR</code>为0，或者<code>nums</code>的长度为偶数，直接<code>return true</code>。</h2>\n",
  "content": "<p>一个黑板上写着一个非负整数数组 nums[i] 。小红和小明轮流从黑板上擦掉一个数字，小红先手。如果擦除一个数字后，剩余的所有数字按位异或运算得出的结果等于 0 的话，当前玩家游戏失败。&nbsp;(另外，如果只剩一个数字，按位异或运算得到它本身；如果无数字剩余，按位异或运算结果为&nbsp;0。）</p>\n\n<p>换种说法就是，轮到某个玩家时，如果当前黑板上所有数字按位异或运算结果等于 0，这个玩家获胜。</p>\n\n<p>假设两个玩家每步都使用最优解，当且仅当小红获胜时返回 <code>true</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre><strong>输入:</strong> nums = [1, 1, 2]\n<strong>输出:</strong> false\n<strong>解释:</strong> \n小红有两个选择: 擦掉数字 1 或 2。\n如果擦掉 1, 数组变成 [1, 2]。剩余数字按位异或得到 1 XOR 2 = 3。那么小明可以擦掉任意数字，因为小红会成为擦掉最后一个数字的人，她总是会输。\n如果小红擦掉 2，那么数组变成[1, 1]。剩余数字按位异或得到 1 XOR 1 = 0。小红仍然会输掉游戏。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= N &lt;= 1000</code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 2^16</code></li>\n</ul>\n"
}
