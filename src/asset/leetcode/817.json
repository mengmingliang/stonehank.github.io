{
  "code": [
    "/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number[]} G\n * @return {number}\n */\n// var numComponents = function(head, G) {\n//     let count=0;\n//     let headArr=[]\n//     function swap(a,i,j){\n//         let temp=a[i]\n//         a[i]=a[j]\n//         a[j]=temp\n//     }    \n//     while(head.val!=undefined){\n//         headArr[head.val]=count++\n//         if(head.next) head=head.next\n//         else break;\n//     }\n//     let newIdxArr=[]\n//     for(let i=0;i<G.length;i++){\n//         newIdxArr[i]=headArr[G[i]]\n//         // if(i>0){\n//         //     let cur=i\n//         //     while(newIdxArr[cur]<newIdxArr[cur-1]){\n//         //         swap(newIdxArr,cur,cur-1)\n//         //         cur--\n//         //     }\n//         // }\n//     }\n\n//     let quick = function (array, lo, hi) {\n//       let index;\n//       if (array.length > 1) {\n//         if(hi<=lo)return\n//         index = partition(array, lo, hi);\n//           quick(array, lo, index - 1);\n//           quick(array, index, hi);\n//       }\n//     };\n\n//     let partition = function (array, l, r) {\n//       let pivot = array[Math.floor((r + l) / 2)],\n//         i = l,\n//         j = r;\n//       while (i <= j) {\n//         while (array[i] < pivot) {i++}\n//         while (array[j] > pivot) {j--}\n//         if (i <= j) swap(array, i++, j--);\n//       }\n//       return i\n//     }\n    \n//     quick(newIdxArr,0,newIdxArr.length-1)\n    \n//     // newIdxArr.sort((a,b)=>a-b)\n//     let res=1\n//     for(let i=1;i<newIdxArr.length;i++){\n//         let gap=newIdxArr[i]-newIdxArr[i-1]\n//         if(gap===1 || gap===0){\n//             continue;\n//         }\n//         res++\n//     }\n//     return res\nconst numComponents = (head, G) => {\n  const wanted = new Int8Array(10000)\n  G.forEach(v => { wanted[v] = 1 })\n  let ans = 0\n  let connected = false\n  for (let cur = head; cur; cur = cur.next) {\n    if (wanted[cur.val]) {\n      connected = true\n    } else {\n      // break connection\n      if (connected) {\n        ++ans, connected = false\n      }\n    }\n  }\n  if (connected) {\n    ++ans, connected = false\n  }\n  return ans\n}\n    "
  ],
  "titleSlug": "linked-list-components",
  "content": "<p>We are given&nbsp;<code>head</code>,&nbsp;the head node of a linked list containing&nbsp;<strong>unique integer values</strong>.</p>\r\n\r\n<p>We are also given the list&nbsp;<code>G</code>, a subset of the values in the linked list.</p>\r\n\r\n<p>Return the number of connected components in <code>G</code>, where two values are connected if they appear consecutively in the linked list.</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> \r\nhead: 0-&gt;1-&gt;2-&gt;3\r\nG = [0, 1, 3]\r\n<strong>Output:</strong> 2\r\n<strong>Explanation:</strong> \r\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> \r\nhead: 0-&gt;1-&gt;2-&gt;3-&gt;4\r\nG = [0, 3, 1, 4]\r\n<strong>Output:</strong> 2\r\n<strong>Explanation:</strong> \r\n0 and 1 are connected, 3 and 4 are connected, so [0, 1] and [3, 4] are the two connected components.\r\n</pre>\r\n\r\n<p><strong>Note: </strong></p>\r\n\r\n<ul>\r\n\t<li>If&nbsp;<code>N</code>&nbsp;is the&nbsp;length of the linked list given by&nbsp;<code>head</code>,&nbsp;<code>1 &lt;= N &lt;= 10000</code>.</li>\r\n\t<li>The value of each node in the linked list will be in the range<code> [0, N - 1]</code>.</li>\r\n\t<li><code>1 &lt;= G.length &lt;= 10000</code>.</li>\r\n\t<li><code>G</code> is a subset of all values in the linked list.</li>\r\n</ul>\r\n",
  "translatedContent": "<p>给定一个链表（链表结点包含一个整型值）的头结点&nbsp;<code>head</code>。</p>\n\n<p>同时给定列表&nbsp;<code>G</code>，该列表是上述链表中整型值的一个子集。</p>\n\n<p>返回列表&nbsp;<code>G</code>&nbsp;中组件的个数，这里对组件的定义为：链表中一段最长连续结点的值（该值必须在列表&nbsp;<code>G</code>&nbsp;中）构成的集合。</p>\n\n<p><strong>示例&nbsp;1：</strong></p>\n\n<pre>\n<strong>输入:</strong> \nhead: 0-&gt;1-&gt;2-&gt;3\nG = [0, 1, 3]\n<strong>输出:</strong> 2\n<strong>解释:</strong> \n链表中,0 和 1 是相连接的，且 G 中不包含 2，所以 [0, 1] 是 G 的一个组件，同理 [3] 也是一个组件，故返回 2。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入:</strong> \nhead: 0-&gt;1-&gt;2-&gt;3-&gt;4\nG = [0, 3, 1, 4]\n<strong>输出:</strong> 2\n<strong>解释:</strong> \n链表中，0 和 1 是相连接的，3 和 4 是相连接的，所以 [0, 1] 和 [3, 4] 是两个组件，故返回 2。</pre>\n\n<p><strong>注意:</strong></p>\n\n<ul>\n\t<li>如果&nbsp;<code>N</code>&nbsp;是给定链表&nbsp;<code>head</code>&nbsp;的长度，<code>1 &lt;= N &lt;= 10000</code>。</li>\n\t<li>链表中每个结点的值所在范围为&nbsp;<code>[0, N - 1]</code>。</li>\n\t<li><code>1 &lt;= G.length &lt;= 10000</code></li>\n\t<li><code>G</code> 是链表中所有结点的值的一个子集.</li>\n</ul>\n"
}
