{
  "code": [
    "<pre class=\"hljs\"><code><span class=\"hljs-comment\">/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */</span>\n<span class=\"hljs-keyword\">var</span> findKthLargest = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">arr, k</span>) </span>{\n  <span class=\"hljs-comment\">// // O(nlgn)</span>\n  <span class=\"hljs-comment\">// nums.sort((a,b)=&gt;b-a)</span>\n  <span class=\"hljs-comment\">// return nums[k-1]</span>\n  \n  <span class=\"hljs-comment\">// // O(nlgn)</span>\n  <span class=\"hljs-comment\">// k=nums.length-k+1</span>\n  <span class=\"hljs-comment\">// let lo=Infinity,hi=-Infinity</span>\n  <span class=\"hljs-comment\">// for(let i=0;i&lt;nums.length;i++){</span>\n  <span class=\"hljs-comment\">//   if(nums[i]&lt;lo)lo=nums[i]</span>\n  <span class=\"hljs-comment\">//   if(nums[i]&gt;hi)hi=nums[i]</span>\n  <span class=\"hljs-comment\">// }      </span>\n  <span class=\"hljs-comment\">// while(lo&lt;hi){</span>\n  <span class=\"hljs-comment\">//   let mid=Math.floor((lo+hi)/2)</span>\n  <span class=\"hljs-comment\">//   let count=0</span>\n  <span class=\"hljs-comment\">//   for(let i=0;i&lt;nums.length;i++){</span>\n  <span class=\"hljs-comment\">//     if(nums[i]&lt;=mid)count++</span>\n  <span class=\"hljs-comment\">//   }</span>\n  <span class=\"hljs-comment\">//   if(count&gt;=k)hi=mid</span>\n  <span class=\"hljs-comment\">//   else lo=mid+1</span>\n  <span class=\"hljs-comment\">//   }</span>\n  <span class=\"hljs-comment\">// return lo</span>\n  \n  <span class=\"hljs-comment\">// O(n)</span>\n  <span class=\"hljs-keyword\">let</span> idx=_qs(arr,<span class=\"hljs-number\">0</span>,arr.length<span class=\"hljs-number\">-1</span>,k)\n  <span class=\"hljs-keyword\">return</span> arr[idx]\n \n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">_qs</span>(<span class=\"hljs-params\">arr,lo,hi,target</span>)</span>{\n    <span class=\"hljs-keyword\">let</span> i=lo,j=hi,pivot=arr[hi]\n    <span class=\"hljs-keyword\">while</span>(i&lt;j){\n      <span class=\"hljs-keyword\">if</span>(arr[i]&lt;pivot)i++\n      <span class=\"hljs-keyword\">else</span> swap(arr,i,--j)\n    }\n    swap(arr,i,hi)\n    <span class=\"hljs-comment\">// 数一下当前比 i 位置大的数量</span>\n    <span class=\"hljs-keyword\">let</span> curCount=hi-i+<span class=\"hljs-number\">1</span>\n    <span class=\"hljs-comment\">// 当前数量和目标一致，返回</span>\n    <span class=\"hljs-keyword\">if</span>(curCount===target)<span class=\"hljs-keyword\">return</span> i\n    <span class=\"hljs-comment\">// 当前数量更多，说明这个值偏小，需要在右边找</span>\n    <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(curCount&gt;target)<span class=\"hljs-keyword\">return</span> _qs(arr,i+<span class=\"hljs-number\">1</span>,hi,target)\n    <span class=\"hljs-comment\">// 当前数量更少，说明这个值偏大，需要在左边找，同时要减去已经找到的数量</span>\n    <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">return</span> _qs(arr,lo,i<span class=\"hljs-number\">-1</span>,target-curCount)\n  }\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">swap</span>(<span class=\"hljs-params\">arr,i,j</span>)</span>{\n    <span class=\"hljs-keyword\">let</span> t=arr[i]\n    arr[i]=arr[j]\n    arr[j]=t\n  }\n};\n</code></pre>\n"
  ],
  "titleSlug": "kth-largest-element-in-an-array",
  "thinking": "<hr>\n<p>思路：</p>\n<p>使用快速选择。</p>\n<ol>\n<li>快速排序我们都很清楚，每一次选中一个<code>pivot</code>，将小于它的放左边，大于它的放右边，执行<code>lgN</code>次。</li>\n<li>快速选择同理，唯一的区别是当每次左右排序后，检查我们要找的值是在左边还是在右边，然后继续执行<code>左</code>或者<code>右</code>，另一边丢弃。</li>\n</ol>\n",
  "content": "<p>在未排序的数组中找到第 <strong>k</strong> 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre><strong>输入:</strong> <code>[3,2,1,5,6,4] 和</code> k = 2\n<strong>输出:</strong> 5\n</pre>\n\n<p><strong>示例&nbsp;2:</strong></p>\n\n<pre><strong>输入:</strong> <code>[3,2,3,1,2,4,5,5,6] 和</code> k = 4\n<strong>输出:</strong> 4</pre>\n\n<p><strong>说明: </strong></p>\n\n<p>你可以假设 k 总是有效的，且 1 &le; k &le; 数组的长度。</p>\n",
  "hasThinking": true
}
