{
  "code": [
    "<pre class=\"hljs\"><code><span class=\"hljs-comment\">/**\n * @param {number} n\n * @return {number}\n */</span>\n<span class=\"hljs-keyword\">var</span> numTrees = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">n</span>) </span>{\n  <span class=\"hljs-keyword\">let</span> dp=<span class=\"hljs-built_in\">Array</span>(n+<span class=\"hljs-number\">1</span>).fill(<span class=\"hljs-number\">0</span>)\n  dp[<span class=\"hljs-number\">0</span>]=<span class=\"hljs-number\">1</span>\n  <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i=<span class=\"hljs-number\">1</span>;i&lt;=n;i++){\n    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> j=<span class=\"hljs-number\">0</span>;j&lt;i;j++){\n      dp[i]+=dp[j]*dp[i-j<span class=\"hljs-number\">-1</span>]\n    }\n  }\n  <span class=\"hljs-keyword\">return</span> dp[n]\n};\n</code></pre>\n"
  ],
  "titleSlug": "unique-binary-search-trees",
  "hasThinking": true,
  "thinking": "<hr>\n<p>思路：</p>\n<p>与<code>NO.95</code>不同在于，这题不需要找出划分后具体的树，只需要保留结果，因此使用<code>DP</code>。</p>\n<p><code>dp[i]</code>表示从数量为<code>i</code>有多少种划分，初始<code>dp[0]=1</code>，即<code>root</code>为<code>null</code>就是1种划分。</p>\n<p><code>dp[i]=dp[j]*dp[i-j-1]</code>，<code>j</code>的范围为<code>0&lt;=j&lt;i</code>，其中<code>j</code>表示左子树的数量，<code>i-j-1</code>表示右子树的数量。</p>\n",
  "content": "<p>给定一个整数 <em>n</em>，求以&nbsp;1 ...&nbsp;<em>n</em>&nbsp;为节点组成的二叉搜索树有多少种？</p>\n\n<p><strong>示例:</strong></p>\n\n<pre><strong>输入:</strong> 3\n<strong>输出:</strong> 5\n<strong>解释:\n</strong>给定 <em>n</em> = 3, 一共有 5 种不同结构的二叉搜索树:\n\n   1         3     3      2      1\n    \\       /     /      / \\      \\\n     3     2     1      1   3      2\n    /     /       \\                 \\\n   2     1         2                 3</pre>\n"
}
