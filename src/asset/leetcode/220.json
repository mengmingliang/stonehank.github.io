{
  "code": [
    "<pre class=\"hljs\"><code><span class=\"hljs-comment\">/**\n * @param {number[]} nums\n * @param {number} k\n * @param {number} t\n * @return {boolean}\n */</span>\n<span class=\"hljs-keyword\">var</span> containsNearbyAlmostDuplicate = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">nums, k, t</span>) </span>{\n  <span class=\"hljs-keyword\">let</span> aux=[]\n  <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i=<span class=\"hljs-number\">0</span>;i&lt;nums.length;i++){\n    aux.push([nums[i],i])\n  }\n  aux.sort(<span class=\"hljs-function\">(<span class=\"hljs-params\">a,b</span>)=&gt;</span>a[<span class=\"hljs-number\">0</span>]-b[<span class=\"hljs-number\">0</span>])\n  \n  <span class=\"hljs-keyword\">let</span> left=<span class=\"hljs-number\">0</span>,right=<span class=\"hljs-number\">1</span>\n\n  <span class=\"hljs-keyword\">while</span>(right&lt;aux.length){\n    <span class=\"hljs-keyword\">let</span> diff=<span class=\"hljs-built_in\">Math</span>.abs(aux[right][<span class=\"hljs-number\">0</span>]-aux[left][<span class=\"hljs-number\">0</span>])\n    <span class=\"hljs-keyword\">let</span> idxDiff=<span class=\"hljs-built_in\">Math</span>.abs(aux[right][<span class=\"hljs-number\">1</span>]-aux[left][<span class=\"hljs-number\">1</span>])\n    <span class=\"hljs-keyword\">if</span>(diff&lt;=t &amp;&amp; idxDiff&lt;=k){\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>\n    }<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(diff&gt;t){\n      left++\n      <span class=\"hljs-keyword\">if</span>(left===right)right++\n    }<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(idxDiff&gt;k){\n      right++\n    }\n  }\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>\n  \n  <span class=\"hljs-comment\">// 仿二叉搜索树(比较好理解)</span>\n  <span class=\"hljs-comment\">// 112ms</span>\n  <span class=\"hljs-comment\">// if(k&lt;=0)return false</span>\n  <span class=\"hljs-comment\">// function bsEnd(arr,n){</span>\n  <span class=\"hljs-comment\">//   let lo=0,hi=arr.length-1</span>\n  <span class=\"hljs-comment\">//   while(lo&lt;hi){</span>\n  <span class=\"hljs-comment\">//     let mid=Math.floor((lo+hi)/2)</span>\n  <span class=\"hljs-comment\">//     if(arr[mid][0]&lt;n)lo=mid+1</span>\n  <span class=\"hljs-comment\">//     else hi=mid</span>\n  <span class=\"hljs-comment\">//   }</span>\n  <span class=\"hljs-comment\">//   return hi</span>\n  <span class=\"hljs-comment\">// }</span>\n  <span class=\"hljs-comment\">// function bsFront(arr,n){</span>\n  <span class=\"hljs-comment\">//   let lo=0,hi=arr.length-1</span>\n  <span class=\"hljs-comment\">//   while(lo&lt;hi){</span>\n  <span class=\"hljs-comment\">//     let mid=Math.ceil((lo+hi)/2)</span>\n  <span class=\"hljs-comment\">//     if(arr[mid][0]&gt;n)hi=mid-1</span>\n  <span class=\"hljs-comment\">//     else lo=mid</span>\n  <span class=\"hljs-comment\">//   }</span>\n  <span class=\"hljs-comment\">//   return lo</span>\n  <span class=\"hljs-comment\">// }</span>\n  <span class=\"hljs-comment\">// let aux=[]</span>\n  <span class=\"hljs-comment\">// for(let i=0;i&lt;nums.length;i++){</span>\n  <span class=\"hljs-comment\">//   aux.push([nums[i],i])</span>\n  <span class=\"hljs-comment\">// }</span>\n  <span class=\"hljs-comment\">// // 排序后才能进行二分搜索</span>\n  <span class=\"hljs-comment\">// aux.sort((a,b)=&gt;a[0]-b[0])  </span>\n  <span class=\"hljs-comment\">// for(let i=0;i&lt;aux.length;i++){</span>\n  <span class=\"hljs-comment\">//   let [v,idx]=aux[i]</span>\n  <span class=\"hljs-comment\">//   let floor=bsFront(aux,v+t),</span>\n  <span class=\"hljs-comment\">//       ceil=bsEnd(aux,v-t)</span>\n  <span class=\"hljs-comment\">//   // floor指的是小于等于v+t的所有的数字中最大的</span>\n  <span class=\"hljs-comment\">//   if(floor!==i &amp;&amp;</span>\n  <span class=\"hljs-comment\">//      aux[floor][0]&gt;=v &amp;&amp;</span>\n  <span class=\"hljs-comment\">//      aux[floor][0]&lt;=v+t &amp;&amp;</span>\n  <span class=\"hljs-comment\">//      Math.abs(aux[floor][1]-idx)&lt;=k)</span>\n  <span class=\"hljs-comment\">//     return true</span>\n  <span class=\"hljs-comment\">//   // ceil指的是大于等于v-t的所有数字中最小的</span>\n  <span class=\"hljs-comment\">//   if(ceil!==i &amp;&amp;</span>\n  <span class=\"hljs-comment\">//      aux[ceil][0]&lt;=v &amp;&amp;</span>\n  <span class=\"hljs-comment\">//      aux[ceil][0]&gt;=v-t &amp;&amp;</span>\n  <span class=\"hljs-comment\">//      Math.abs(aux[ceil][1]-idx)&lt;=k)</span>\n  <span class=\"hljs-comment\">//     return true</span>\n  <span class=\"hljs-comment\">// }</span>\n  <span class=\"hljs-comment\">// return false</span>\n};\n</code></pre>\n"
  ],
  "titleSlug": "contains-duplicate-iii",
  "hasThinking": true,
  "thinking": "<hr>\n<p>思路：</p>\n<ol>\n<li><code>Brute Force</code>，按照题意逐个检查。</li>\n</ol>\n<pre class=\"hljs\"><code><span class=\"hljs-comment\">/**\n * @param {number[]} nums\n * @param {number} k\n * @param {number} t\n * @return {boolean}\n */</span>\n<span class=\"hljs-keyword\">var</span> containsNearbyAlmostDuplicate = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">nums, k, t</span>) </span>{\n  <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i=<span class=\"hljs-number\">0</span>;i&lt;nums.length;i++){\n    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> j=i+<span class=\"hljs-number\">1</span>;j&lt;=i+k;j++){\n      <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-built_in\">Math</span>.abs(nums[i]-nums[j])&lt;=t)<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>\n    }\n  }\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>\n};\n</code></pre>\n<ol start=\"2\">\n<li><code>window slide</code>，先按照数字大小排序，排序时保留原索引，定义一个符合<code>t</code>的有效区间<code>[left,right]</code>，一旦发现不符合<code>nums[right]-nums[left]&lt;=t</code>，\n说明需要<code>left++</code>来减小当前区间；</li>\n</ol>\n<p>对当前有效区间，检查<code>left</code>和<code>right</code>的差值，如果符合<code>k</code>以内，返回<code>true</code>，如果不符合，通过<code>right++</code>来扩大区间，继续上面的检查区间。</p>\n<p>这里是需要检查头和尾，对于数值，因为是有序的，检查头和尾即可；对于索引，因为窗口是不断滑动的，因此在数值符合条件的情况下，都会被检查到。</p>\n<pre class=\"hljs\"><code><span class=\"hljs-comment\">/**\n * @param {number[]} nums\n * @param {number} k\n * @param {number} t\n * @return {boolean}\n */</span>\n<span class=\"hljs-keyword\">var</span> containsNearbyAlmostDuplicate = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">nums, k, t</span>) </span>{\n  <span class=\"hljs-keyword\">let</span> aux=[]\n  <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i=<span class=\"hljs-number\">0</span>;i&lt;nums.length;i++){\n    aux.push([nums[i],i])\n  }\n  aux.sort(<span class=\"hljs-function\">(<span class=\"hljs-params\">a,b</span>)=&gt;</span>a[<span class=\"hljs-number\">0</span>]-b[<span class=\"hljs-number\">0</span>])\n  \n  <span class=\"hljs-keyword\">let</span> left=<span class=\"hljs-number\">0</span>,right=<span class=\"hljs-number\">1</span>\n\n  <span class=\"hljs-keyword\">while</span>(right&lt;aux.length){\n    <span class=\"hljs-keyword\">let</span> diff=<span class=\"hljs-built_in\">Math</span>.abs(aux[right][<span class=\"hljs-number\">0</span>]-aux[left][<span class=\"hljs-number\">0</span>])\n    <span class=\"hljs-keyword\">let</span> idxDiff=<span class=\"hljs-built_in\">Math</span>.abs(aux[right][<span class=\"hljs-number\">1</span>]-aux[left][<span class=\"hljs-number\">1</span>])\n    <span class=\"hljs-keyword\">if</span>(diff&lt;=t &amp;&amp; idxDiff&lt;=k){\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>\n    }<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(diff&gt;t){\n      left++\n      <span class=\"hljs-keyword\">if</span>(left===right)right++\n    }<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(idxDiff&gt;k){\n      right++\n    }\n  }\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>\n};\n</code></pre>\n<ol start=\"3\">\n<li>仿二叉搜索树，通过<code>floor</code>和<code>ceil</code>检测每一个值的有效性。</li>\n</ol>\n",
  "content": "<p>给定一个整数数组，判断数组中是否有两个不同的索引 <em>i</em> 和 <em>j</em>，使得&nbsp;<strong>nums [i]</strong> 和&nbsp;<strong>nums [j]</strong>&nbsp;的差的绝对值最大为 <em>t</em>，并且 <em>i</em> 和 <em>j</em> 之间的差的绝对值最大为 <em>ķ</em>。</p>\n\n<p><strong>示例&nbsp;1:</strong></p>\n\n<pre><strong>输入:</strong> nums = [1,2,3,1], k<em> </em>= 3, t = 0\n<strong>输出:</strong> true</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre><strong>输入: </strong>nums = [1,0,1,1], k<em> </em>=<em> </em>1, t = 2\n<strong>输出:</strong> true</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre><strong>输入: </strong>nums = [1,5,9,1,5,9], k = 2, t = 3\n<strong>输出:</strong> false</pre>\n"
}
