{
  "code": [
    "<pre class=\"hljs\"><code><span class=\"hljs-comment\">/**\n * @param {number[]} nums\n * @return {void} Do not return anything, modify nums in-place instead.\n */</span>\n<span class=\"hljs-keyword\">var</span> wiggleSort = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">nums</span>) </span>{\n  <span class=\"hljs-keyword\">let</span> arr=nums.slice()\n  arr.sort(<span class=\"hljs-function\">(<span class=\"hljs-params\">a,b</span>)=&gt;</span>a-b)\n  <span class=\"hljs-keyword\">var</span> len = nums.length\n  <span class=\"hljs-keyword\">var</span> left = <span class=\"hljs-built_in\">Math</span>.ceil(len/<span class=\"hljs-number\">2</span>)<span class=\"hljs-number\">-1</span>\n  <span class=\"hljs-keyword\">var</span> right = len<span class=\"hljs-number\">-1</span>\n  <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">0</span>; i&lt;nums.length; i++) {\n    <span class=\"hljs-keyword\">if</span>(i%<span class=\"hljs-number\">2</span>==<span class=\"hljs-number\">1</span>) {\n      nums[i] = arr[right--]\n    }<span class=\"hljs-keyword\">else</span> {\n      nums[i] = arr[left--]\n    }\n  }\n};\n</code></pre>\n"
  ],
  "titleSlug": "wiggle-sort-ii",
  "hasThinking": true,
  "thinking": "<hr>\n<p>思路：</p>\n<p>对<code>nums</code>从小到大排序，之后2个指针，指针1<code>left</code>初始在中间，指针2<code>right</code>初始在末尾，向左移动并且逐个配对。</p>\n",
  "content": "<p>给定一个无序的数组&nbsp;<code>nums</code>，将它重新排列成&nbsp;<code>nums[0] &lt; nums[1] &gt; nums[2] &lt; nums[3]...</code>&nbsp;的顺序。</p>\n\n<p><strong>示例&nbsp;1:</strong></p>\n\n<pre><strong>输入: </strong><code>nums = [1, 5, 1, 1, 6, 4]</code>\n<strong>输出: </strong>一个可能的答案是 <code>[1, 4, 1, 5, 1, 6]</code></pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre><strong>输入: </strong><code>nums = [1, 3, 2, 2, 3, 1]</code>\n<strong>输出:</strong> 一个可能的答案是 <code>[2, 3, 1, 3, 1, 2]</code></pre>\n\n<p><strong>说明:</strong><br>\n你可以假设所有输入都会得到有效的结果。</p>\n\n<p><strong>进阶:</strong><br>\n你能用&nbsp;O(n) 时间复杂度和 / 或原地 O(1) 额外空间来实现吗？</p>\n"
}
