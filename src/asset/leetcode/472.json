{
  "code": [
    "<pre class=\"hljs\"><code><span class=\"hljs-comment\">/**\n * @param {string[]} words\n * @return {string[]}\n */</span>\n<span class=\"hljs-keyword\">var</span> findAllConcatenatedWordsInADict = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">words</span>) </span>{\n  <span class=\"hljs-comment\">// trie+dfs</span>\n  <span class=\"hljs-comment\">// let tree={}</span>\n  <span class=\"hljs-comment\">// for(let i=0;i&lt;words.length;i++){</span>\n  <span class=\"hljs-comment\">//   let node=tree</span>\n  <span class=\"hljs-comment\">//   for(let j=0;j&lt;words[i].length;j++){</span>\n  <span class=\"hljs-comment\">//     let cur=words[i][j]</span>\n  <span class=\"hljs-comment\">//     if(node[cur]==null)node[cur]={exact:false,child:{}}</span>\n  <span class=\"hljs-comment\">//     if(j===words[i].length-1)node[cur].exact=true</span>\n  <span class=\"hljs-comment\">//     node=node[cur].child</span>\n  <span class=\"hljs-comment\">//   }</span>\n  <span class=\"hljs-comment\">// }</span>\n  <span class=\"hljs-comment\">// let result=[]</span>\n  <span class=\"hljs-comment\">// let find=false</span>\n  <span class=\"hljs-comment\">// function dfs(str,node,count){</span>\n  <span class=\"hljs-comment\">//   if(str==='' &amp;&amp; count&gt;1)return find=true</span>\n  <span class=\"hljs-comment\">//   for(let i=0;i&lt;str.length;i++){</span>\n  <span class=\"hljs-comment\">//     let cur=str[i]</span>\n  <span class=\"hljs-comment\">//     if(node[cur]==null)return</span>\n  <span class=\"hljs-comment\">//     if(node[cur].exact){</span>\n  <span class=\"hljs-comment\">//       dfs(str.substring(i+1),tree,count+1)</span>\n  <span class=\"hljs-comment\">//       if(find)return</span>\n  <span class=\"hljs-comment\">//     }</span>\n  <span class=\"hljs-comment\">//     node=node[cur].child</span>\n  <span class=\"hljs-comment\">//   }</span>\n  <span class=\"hljs-comment\">// }</span>\n  <span class=\"hljs-comment\">// for(let n of words){</span>\n  <span class=\"hljs-comment\">//   find=false</span>\n  <span class=\"hljs-comment\">//   let node=tree</span>\n  <span class=\"hljs-comment\">//   dfs(n,node,0)</span>\n  <span class=\"hljs-comment\">//   if(find)result.push(n)</span>\n  <span class=\"hljs-comment\">// }</span>\n  <span class=\"hljs-comment\">// return result</span>\n  \n  <span class=\"hljs-comment\">// problem 139的升级版</span>\n  <span class=\"hljs-keyword\">let</span> wordDict=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Map</span>(),\n      result=[]\n  words.sort(<span class=\"hljs-function\">(<span class=\"hljs-params\">a,b</span>)=&gt;</span>a.length-b.length)\n  <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> word <span class=\"hljs-keyword\">of</span> words){\n    <span class=\"hljs-keyword\">if</span>(canCombine(word,wordDict)){\n      result.push(word)\n    }\n    wordDict.set(word,<span class=\"hljs-literal\">true</span>)\n  }\n  <span class=\"hljs-keyword\">return</span> result\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">canCombine</span>(<span class=\"hljs-params\">s,wordDict</span>)</span>{\n    <span class=\"hljs-keyword\">if</span>(wordDict.size===<span class=\"hljs-number\">0</span>)<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>\n    <span class=\"hljs-keyword\">let</span> dp=<span class=\"hljs-built_in\">Array</span>(s.length + <span class=\"hljs-number\">1</span>).fill(<span class=\"hljs-literal\">false</span>)\n    dp[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-literal\">true</span>;\n    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i=<span class=\"hljs-number\">1</span>; i &lt;= s.length; i++){\n      <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> j=<span class=\"hljs-number\">0</span>; j &lt; i; j++){\n        <span class=\"hljs-keyword\">if</span>(dp[j] &amp;&amp; wordDict.has(s.substring(j, i))){\n          dp[i] = <span class=\"hljs-literal\">true</span>;\n          <span class=\"hljs-keyword\">break</span>;\n        }\n      }\n    }\n    <span class=\"hljs-keyword\">return</span> dp[s.length];    \n  }\n\n};\n</code></pre>\n"
  ],
  "titleSlug": "concatenated-words",
  "content": "<p>给定一个<strong>不含重复</strong>单词的列表，编写一个程序，返回给定单词列表中所有的连接词。</p>\n\n<p>连接词的定义为：一个字符串完全是由至少两个给定数组中的单词组成的。</p>\n\n<p><strong>示例:</strong></p>\n\n<pre>\n<strong>输入:</strong> [&quot;cat&quot;,&quot;cats&quot;,&quot;catsdogcats&quot;,&quot;dog&quot;,&quot;dogcatsdog&quot;,&quot;hippopotamuses&quot;,&quot;rat&quot;,&quot;ratcatdogcat&quot;]\n\n<strong>输出:</strong> [&quot;catsdogcats&quot;,&quot;dogcatsdog&quot;,&quot;ratcatdogcat&quot;]\n\n<strong>解释:</strong> &quot;catsdogcats&quot;由&quot;cats&quot;, &quot;dog&quot; 和 &quot;cats&quot;组成; \n     &quot;dogcatsdog&quot;由&quot;dog&quot;, &quot;cats&quot;和&quot;dog&quot;组成; \n     &quot;ratcatdogcat&quot;由&quot;rat&quot;, &quot;cat&quot;, &quot;dog&quot;和&quot;cat&quot;组成。\n</pre>\n\n<p><strong>说明:</strong></p>\n\n<ol>\n\t<li>给定数组的元素总数不超过 <code>10000</code>。</li>\n\t<li>给定数组中元素的长度总和不超过 <code>600000</code>。</li>\n\t<li>所有输入字符串只包含小写字母。</li>\n\t<li>不需要考虑答案输出的顺序。</li>\n</ol>\n"
}
