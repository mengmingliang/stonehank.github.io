{
  "code": [
    "<pre class=\"hljs\"><code><span class=\"hljs-comment\">/**\n * @param {number} capacity\n */</span>\n<span class=\"hljs-comment\">// 另：直接使用Map()，默认最新加入会在最后，每次冲突只需删除第一个即可</span>\n\n<span class=\"hljs-keyword\">var</span> DLink = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">key,val</span>)</span>{\n  <span class=\"hljs-keyword\">this</span>.val=val\n  <span class=\"hljs-keyword\">this</span>.key=key\n  <span class=\"hljs-keyword\">this</span>.pre=<span class=\"hljs-literal\">null</span>\n  <span class=\"hljs-keyword\">this</span>.next=<span class=\"hljs-literal\">null</span>\n}\n<span class=\"hljs-keyword\">var</span> LRUCache = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">capacity</span>) </span>{\n  <span class=\"hljs-keyword\">let</span> mockHead=<span class=\"hljs-keyword\">new</span> DLink(<span class=\"hljs-literal\">null</span>,<span class=\"hljs-literal\">null</span>),\n      mockTail=<span class=\"hljs-keyword\">new</span> DLink(<span class=\"hljs-literal\">null</span>,<span class=\"hljs-literal\">null</span>)\n  \n  mockHead.next=mockTail\n  mockTail.pre=mockHead\n  \n  <span class=\"hljs-keyword\">this</span>.removeSelf=<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">node</span>)</span>{\n    node.pre.next=node.next\n    node.next.pre=node.pre\n    <span class=\"hljs-keyword\">return</span> node\n  }\n  <span class=\"hljs-keyword\">this</span>.addToHead=<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">node</span>)</span>{\n    node.next=mockHead.next\n    mockHead.next.pre=node\n  \n    mockHead.next=node\n    node.pre=mockHead\n    <span class=\"hljs-keyword\">return</span> node\n  }\n  <span class=\"hljs-keyword\">this</span>.moveToHead=<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">node</span>)</span>{\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.addToHead(<span class=\"hljs-keyword\">this</span>.removeSelf(node))\n  }\n  <span class=\"hljs-keyword\">this</span>.removeTail=<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>{\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.removeSelf(mockTail.pre)\n  }\n\n  <span class=\"hljs-keyword\">this</span>.map=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Map</span>()\n  <span class=\"hljs-keyword\">this</span>.capacity=capacity\n  <span class=\"hljs-keyword\">this</span>.curLen=<span class=\"hljs-number\">0</span>\n};\n\n<span class=\"hljs-comment\">/** \n * @param {number} key\n * @return {number}\n */</span>\nLRUCache.prototype.get = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">key</span>) </span>{\n  <span class=\"hljs-keyword\">if</span>(!<span class=\"hljs-keyword\">this</span>.map.has(key))<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>\n  <span class=\"hljs-keyword\">let</span> node=<span class=\"hljs-keyword\">this</span>.moveToHead(<span class=\"hljs-keyword\">this</span>.map.get(key))\n  <span class=\"hljs-keyword\">this</span>.map.set(key,node)\n  <span class=\"hljs-keyword\">return</span> node.val\n};\n\n<span class=\"hljs-comment\">/** \n * @param {number} key \n * @param {number} value\n * @return {void}\n */</span>\nLRUCache.prototype.put = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">key, value</span>) </span>{\n  <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-keyword\">this</span>.map.has(key)){\n    <span class=\"hljs-keyword\">let</span> oldN=<span class=\"hljs-keyword\">this</span>.map.get(key)\n    <span class=\"hljs-keyword\">let</span> newN=<span class=\"hljs-keyword\">this</span>.moveToHead(oldN)\n    newN.val=value\n    <span class=\"hljs-keyword\">this</span>.map.set(key,newN)\n  }<span class=\"hljs-keyword\">else</span>{\n    <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-keyword\">this</span>.curLen&gt;=<span class=\"hljs-keyword\">this</span>.capacity){\n      <span class=\"hljs-keyword\">let</span> delNode=<span class=\"hljs-keyword\">this</span>.removeTail()\n      <span class=\"hljs-keyword\">this</span>.map.delete(delNode.key)\n    }\n    <span class=\"hljs-keyword\">let</span> newNode=<span class=\"hljs-keyword\">this</span>.addToHead(<span class=\"hljs-keyword\">new</span> DLink(key,value))\n    <span class=\"hljs-keyword\">this</span>.map.set(key,newNode)\n    <span class=\"hljs-keyword\">this</span>.curLen++\n  }\n};\n\n<span class=\"hljs-comment\">/** \n * Your LRUCache object will be instantiated and called as such:\n * var obj = Object.create(LRUCache).createNew(capacity)\n * var param_1 = obj.get(key)\n * obj.put(key,value)\n */</span>\n</code></pre>\n"
  ],
  "titleSlug": "lru-cache",
  "hasThinking": true,
  "thinking": "<hr>\n<p>思路：</p>\n<p>2种方法可以实现，但只是工具不同，思想基本一致。</p>\n<p>在<code>put</code>内部，先查找当前是否存在<code>key</code>，如果存在，则更新，这时候长度不会发生变化，只是需要将刚刚更新的<code>key-val</code>，放到最新的位置；</p>\n<p>如果不存在，也不能立刻添加，先要查看当前是否满了，如果满了，需要将最早的那个删除。</p>\n<p>最后再添加新的键值对。</p>\n<p>在<code>get</code>内部，首先查找当前<code>key</code>是否存在，不存在返回<code>-1</code>，存在除了返回对应的<code>val</code>，还要更新位置，将当前<code>get</code>的键值对放到最新的位置。</p>\n<p>这里要求<code>查找</code>，<code>增加</code>，<code>删除</code>都要是<code>O(1)</code>。</p>\n<ol>\n<li>使用<code>js</code>的<code>map</code>。</li>\n</ol>\n<p><code>map</code>本身是按照加入的顺序排序的，并且查找和增加删除都是<code>O(1)</code>。</p>\n<p>在<code>put</code>，只需要找到对应的删除是<code>O(1)</code>，如果发现满了，需要删除最早的，那么需要用到<code>map.entries.next().value</code>，就是<code>map</code>的第一个键值对(最早加入的)。</p>\n<pre class=\"hljs\"><code><span class=\"hljs-comment\">/**\n * @param {number} capacity\n */</span>\n<span class=\"hljs-keyword\">var</span> LRUCache = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">capacity</span>) </span>{\n  <span class=\"hljs-keyword\">this</span>.map=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Map</span>()\n  <span class=\"hljs-keyword\">this</span>.capacity=capacity\n};\n\n<span class=\"hljs-comment\">/** \n * @param {number} key\n * @return {number}\n */</span>\nLRUCache.prototype.get = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">key</span>) </span>{\n  <span class=\"hljs-keyword\">if</span>(!<span class=\"hljs-keyword\">this</span>.map.has(key))<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>\n  <span class=\"hljs-keyword\">let</span> val=<span class=\"hljs-keyword\">this</span>.map.get(key)\n  <span class=\"hljs-keyword\">this</span>.map.delete(key)\n  <span class=\"hljs-keyword\">this</span>.map.set(key,val)\n  <span class=\"hljs-keyword\">return</span> val\n};\n\n<span class=\"hljs-comment\">/** \n * @param {number} key \n * @param {number} value\n * @return {void}\n */</span>\nLRUCache.prototype.put = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">key, value</span>) </span>{\n  <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-keyword\">this</span>.map.has(key)){\n    <span class=\"hljs-keyword\">this</span>.map.delete(key)\n  }<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-keyword\">this</span>.capacity===<span class=\"hljs-keyword\">this</span>.map.size){\n    <span class=\"hljs-keyword\">let</span> firstKey=<span class=\"hljs-keyword\">this</span>.map.entries().next().value[<span class=\"hljs-number\">0</span>]\n    <span class=\"hljs-keyword\">this</span>.map.delete(firstKey)\n  }\n  <span class=\"hljs-keyword\">this</span>.map.set(key,value)\n};\n\n<span class=\"hljs-comment\">/** \n * Your LRUCache object will be instantiated and called as such:\n * var obj = Object.create(LRUCache).createNew(capacity)\n * var param_1 = obj.get(key)\n * obj.put(key,value)\n */</span>\n</code></pre>\n<ol start=\"2\">\n<li>使用<code>DoubleLink</code>，双向链表。</li>\n</ol>\n<p>双向链表的查找可以使用<code>hash</code>保存每一截链表的引用，键值就是<code>key</code>。</p>\n<h2>另外双向链表的<code>增加</code>和<code>删除</code>都是<code>O(1)</code>。</h2>\n",
  "content": "<p>运用你所掌握的数据结构，设计和实现一个&nbsp; <a href=\"https://baike.baidu.com/item/LRU\" target=\"_blank\">LRU (最近最少使用) 缓存机制</a>。它应该支持以下操作： 获取数据 <code>get</code> 和 写入数据 <code>put</code> 。</p>\n\n<p>获取数据 <code>get(key)</code> - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。<br>\n写入数据 <code>put(key, value)</code> - 如果密钥不存在，则写入其数据值。当缓存容量达到上限时，它应该在写入新数据之前删除最近最少使用的数据值，从而为新的数据值留出空间。</p>\n\n<p><strong>进阶:</strong></p>\n\n<p>你是否可以在&nbsp;<strong>O(1)</strong> 时间复杂度内完成这两种操作？</p>\n\n<p><strong>示例:</strong></p>\n\n<pre>LRUCache cache = new LRUCache( 2 /* 缓存容量 */ );\n\ncache.put(1, 1);\ncache.put(2, 2);\ncache.get(1);       // 返回  1\ncache.put(3, 3);    // 该操作会使得密钥 2 作废\ncache.get(2);       // 返回 -1 (未找到)\ncache.put(4, 4);    // 该操作会使得密钥 1 作废\ncache.get(1);       // 返回 -1 (未找到)\ncache.get(3);       // 返回  3\ncache.get(4);       // 返回  4\n</pre>\n"
}
