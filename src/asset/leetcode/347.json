{
  "code": [
    "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number[]}\n */\nvar topKFrequent = function(nums, k) {\n    let cache={}, bucket=[],res=[],arr\n    for(let i=0;i<nums.length;i++){\n        let cur=nums[i]\n        if(cache[cur]==undefined)cache[cur]=1\n        cache[cur]++\n    }\n    for(let k in cache){\n        let cur=cache[k]\n        if(bucket[cur]==undefined)bucket[cur]=[]\n        bucket[cur].push(k)\n    }\n\n    for(let i=bucket.length-1;i>=0;i--){\n        if(!bucket[i])continue\n        for(let j=0;j<bucket[i].length;j++){\n            if(k>0)res.push(parseInt(bucket[i][j],10))\n            else break;\n            k--\n        }\n    }\n    return res\n};"
  ],
  "titleSlug": "top-k-frequent-elements",
  "content": "<p>Given a non-empty array of integers, return the <b><i>k</i></b> most frequent elements.</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>nums = <span id=\"example-input-1-1\">[1,1,1,2,2,3]</span>, k = <span id=\"example-input-1-2\">2</span>\r\n<strong>Output: </strong><span id=\"example-output-1\">[1,2]</span>\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>nums = <span id=\"example-input-2-1\">[1]</span>, k = <span id=\"example-input-2-2\">1</span>\r\n<strong>Output: </strong><span id=\"example-output-2\">[1]</span></pre>\r\n</div>\r\n\r\n<p><b>Note: </b></p>\r\n\r\n<ul>\r\n\t<li>You may assume <i>k</i> is always valid, 1 &le; <i>k</i> &le; number of unique elements.</li>\r\n\t<li>Your algorithm&#39;s time complexity <b>must be</b> better than O(<i>n</i> log <i>n</i>), where <i>n</i> is the array&#39;s size.</li>\r\n</ul>\r\n",
  "translatedContent": "<p>给定一个非空的整数数组，返回其中出现频率前&nbsp;<strong><em>k&nbsp;</em></strong>高的元素。</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre><strong>输入: </strong>nums = [1,1,1,2,2,3], k = 2\n<strong>输出: </strong>[1,2]\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre><strong>输入: </strong>nums = [1], k = 1\n<strong>输出: </strong>[1]</pre>\n\n<p><strong>说明：</strong></p>\n\n<ul>\n\t<li>你可以假设给定的&nbsp;<em>k&nbsp;</em>总是合理的，且 1 &le; k &le; 数组中不相同的元素的个数。</li>\n\t<li>你的算法的时间复杂度<strong>必须</strong>优于 O(<em>n</em> log <em>n</em>) ,&nbsp;<em>n&nbsp;</em>是数组的大小。</li>\n</ul>\n"
}
