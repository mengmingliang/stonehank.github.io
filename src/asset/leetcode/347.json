{
  "code": [
    "<pre class=\"hljs\"><code><span class=\"hljs-comment\">/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number[]}\n */</span>\n<span class=\"hljs-keyword\">var</span> topKFrequent = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">nums, k</span>) </span>{\n  <span class=\"hljs-keyword\">let</span> cache={}, bucket=[],res=[],arr\n  <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i=<span class=\"hljs-number\">0</span>;i&lt;nums.length;i++){\n    <span class=\"hljs-keyword\">let</span> cur=nums[i]\n    <span class=\"hljs-keyword\">if</span>(cache[cur]==<span class=\"hljs-literal\">undefined</span>)cache[cur]=<span class=\"hljs-number\">1</span>\n    cache[cur]++\n  }\n  <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> key <span class=\"hljs-keyword\">in</span> cache){\n    <span class=\"hljs-keyword\">let</span> cur=cache[key]\n    <span class=\"hljs-keyword\">if</span>(bucket[cur]==<span class=\"hljs-literal\">undefined</span>)bucket[cur]=[]\n    bucket[cur].push(key)\n  }\n\n  <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i=bucket.length<span class=\"hljs-number\">-1</span>;i&gt;=<span class=\"hljs-number\">0</span>;i--){\n    <span class=\"hljs-keyword\">if</span>(!bucket[i])<span class=\"hljs-keyword\">continue</span>\n    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> j=<span class=\"hljs-number\">0</span>;j&lt;bucket[i].length;j++){\n      <span class=\"hljs-keyword\">if</span>(k&gt;<span class=\"hljs-number\">0</span>)res.push(+bucket[i][j])\n      <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">break</span>;\n      k--\n    }\n  }\n  <span class=\"hljs-keyword\">return</span> res\n};\n</code></pre>\n"
  ],
  "titleSlug": "top-k-frequent-elements",
  "hasThinking": true,
  "thinking": "<hr>\n<p>思路：</p>\n<p><code>O(logN)</code>解法： <code>hash</code>保存每一个数字的频率，然后对该频率排序，最后输出前<code>k</code>位的<code>key</code>。</p>\n<p><code>O(N)</code>解法：<code>桶排序</code>，将每一个数字的频率作为一个数组的索引，这个索引对应的是另一个数组，包含了这些频率的数字。</p>\n<pre class=\"hljs\"><code>[\n  1(频率):[1,4,6,8](数字),\n  3:[5,7],\n  ...\n]\n</code></pre>\n<h2>然后反向遍历，将所有前<code>k</code>个数字添加进结果。</h2>\n",
  "content": "<p>给定一个非空的整数数组，返回其中出现频率前&nbsp;<strong><em>k&nbsp;</em></strong>高的元素。</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre><strong>输入: </strong>nums = [1,1,1,2,2,3], k = 2\n<strong>输出: </strong>[1,2]\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre><strong>输入: </strong>nums = [1], k = 1\n<strong>输出: </strong>[1]</pre>\n\n<p><strong>说明：</strong></p>\n\n<ul>\n\t<li>你可以假设给定的&nbsp;<em>k&nbsp;</em>总是合理的，且 1 &le; k &le; 数组中不相同的元素的个数。</li>\n\t<li>你的算法的时间复杂度<strong>必须</strong>优于 O(<em>n</em> log <em>n</em>) ,&nbsp;<em>n&nbsp;</em>是数组的大小。</li>\n</ul>\n"
}
