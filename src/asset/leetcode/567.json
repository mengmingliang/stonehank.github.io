{
  "code": [
    "<pre class=\"hljs\"><code><span class=\"hljs-comment\">/**\n * @param {string} s1\n * @param {string} s2\n * @return {boolean}\n */</span>\n<span class=\"hljs-keyword\">var</span> checkInclusion = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">s1, s2</span>) </span>{\n  <span class=\"hljs-keyword\">let</span> len1=s1.length,len2=s2.length\n  <span class=\"hljs-keyword\">let</span> count1=<span class=\"hljs-built_in\">Array</span>(<span class=\"hljs-number\">26</span>).fill(<span class=\"hljs-number\">0</span>)\n  <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i=<span class=\"hljs-number\">0</span>;i&lt;s1.length;i++){\n    <span class=\"hljs-keyword\">let</span> code=s1.charCodeAt(i)<span class=\"hljs-number\">-97</span>\n    count1[code]++\n  }\n  \n  <span class=\"hljs-keyword\">let</span> count2=<span class=\"hljs-built_in\">Array</span>(<span class=\"hljs-number\">26</span>).fill(<span class=\"hljs-number\">0</span>)\n  <span class=\"hljs-keyword\">let</span> i=<span class=\"hljs-number\">0</span>,j=<span class=\"hljs-number\">0</span>\n  <span class=\"hljs-keyword\">for</span>(;j&lt;s2.length;j++){\n    <span class=\"hljs-keyword\">let</span> code=s2.charCodeAt(j)<span class=\"hljs-number\">-97</span>\n    count2[code]++\n    <span class=\"hljs-keyword\">while</span>(count2[code]&gt;count1[code]){\n      --count2[s2.charCodeAt(i++)<span class=\"hljs-number\">-97</span>]\n    }\n    <span class=\"hljs-keyword\">if</span>(j-i+<span class=\"hljs-number\">1</span>===len1)<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>\n  }\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>\n};\n</code></pre>\n"
  ],
  "titleSlug": "permutation-in-string",
  "hasThinking": true,
  "thinking": "<hr>\n<p>思路：</p>\n<p>可以使用<code>window slide</code>解决，首先统计<code>s1</code>的字母频率<code>count1</code>。</p>\n<p>在遍历<code>s2</code>的同时，构建一个开始索引<code>i</code>，一个结束索引<code>j</code>，我们统计在<code>i</code>和<code>j</code>之前的字母频率<code>count2</code>。</p>\n<p>如果发现<code>s2[j]</code>在<code>count2</code>的频率比<code>count1</code>的更大<code>count2[s2[j]]&gt;count1[s2[j]]</code>，说明在<code>i</code>和<code>j</code>之间有<code>s1</code>不存在的字母，需要不断<code>i++</code>，\n同时减少对应的频率<code>--count[s2[i]]</code>，直到<code>count2[s2[j]]</code>不大于<code>count1[s2[j]]</code>。</p>\n<p>最后每次遍历的最后，检查<code>j-i+1</code>的长度，如果为<code>s1.length</code>，则返回<code>true</code>。</p>\n",
  "content": "<p>给定两个字符串&nbsp;<strong>s1</strong>&nbsp;和&nbsp;<strong>s2</strong>，写一个函数来判断 <strong>s2</strong> 是否包含 <strong>s1&nbsp;</strong>的排列。</p>\n\n<p>换句话说，第一个字符串的排列之一是第二个字符串的子串。</p>\n\n<p><strong>示例1:</strong></p>\n\n<pre>\n<strong>输入: </strong>s1 = &quot;ab&quot; s2 = &quot;eidbaooo&quot;\n<strong>输出: </strong>True\n<strong>解释:</strong> s2 包含 s1 的排列之一 (&quot;ba&quot;).\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>示例2:</strong></p>\n\n<pre>\n<strong>输入: </strong>s1= &quot;ab&quot; s2 = &quot;eidboaoo&quot;\n<strong>输出:</strong> False\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>注意：</strong></p>\n\n<ol>\n\t<li>输入的字符串只包含小写字母</li>\n\t<li>两个字符串的长度都在 [1, 10,000] 之间</li>\n</ol>\n"
}
