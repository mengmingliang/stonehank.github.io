{
  "code": [
    "<pre class=\"hljs\"><code><span class=\"hljs-comment\">/**\n * @param {number[]} nums\n * @return {number[]}\n */</span>\n<span class=\"hljs-keyword\">var</span> singleNumber = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">nums</span>) </span>{\n  <span class=\"hljs-keyword\">let</span> xor=<span class=\"hljs-number\">0</span>\n  <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> num <span class=\"hljs-keyword\">of</span> nums)xor ^= num\n  <span class=\"hljs-comment\">// 找出xor的二进制中最后一个1及后面的0代表的数字</span>\n  <span class=\"hljs-comment\">// 这个最后一个1的位置 说明这两个出现1次的数在这个位置的数是1和0</span>\n  <span class=\"hljs-keyword\">let</span> lastOneBit=<span class=\"hljs-number\">1</span>\n  <span class=\"hljs-keyword\">while</span>(xor % <span class=\"hljs-number\">2</span>===<span class=\"hljs-number\">0</span>){\n    xor /= <span class=\"hljs-number\">2</span>\n    lastOneBit*=<span class=\"hljs-number\">2</span>\n  }\n  <span class=\"hljs-keyword\">let</span> res=[<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">0</span>]\n  <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> num <span class=\"hljs-keyword\">of</span> nums){\n    <span class=\"hljs-comment\">// 这个位置是0的所有数</span>\n    <span class=\"hljs-keyword\">if</span>((lastOneBit &amp; num)===<span class=\"hljs-number\">0</span>){\n      res[<span class=\"hljs-number\">0</span>] ^= num\n    }<span class=\"hljs-keyword\">else</span>{\n      <span class=\"hljs-comment\">// 这个位置是1的所有数</span>\n      res[<span class=\"hljs-number\">1</span>] ^= num\n    }\n  }\n  <span class=\"hljs-keyword\">return</span> res\n};\n</code></pre>\n"
  ],
  "titleSlug": "single-number-iii",
  "hasThinking": true,
  "thinking": "<hr>\n<p>思路：</p>\n<p>2次遍历，第一次遍历计算所有数的<code>xor</code>，计算<code>xor</code>的原因是因为只要找到<code>xor</code>二进制中最后一位<code>1</code>的位置，\n那么说明那<code>2</code>个独立的数这个位置上的数字是不同的(这样它们才有可能异或<code>1</code>)。</p>\n<p>第二次遍历，如果当前数的那个位置是<code>1</code>，单独计算异或值；如果是<code>0</code>，也单独计算异或值，最终得到2个不同的独立值。</p>\n",
  "content": "<p>给定一个整数数组&nbsp;<code>nums</code>，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。</p>\n\n<p><strong>示例 :</strong></p>\n\n<pre><strong>输入:</strong> <code>[1,2,1,3,2,5]</code>\n<strong>输出:</strong> <code>[3,5]</code></pre>\n\n<p><strong>注意：</strong></p>\n\n<ol>\n\t<li>结果输出的顺序并不重要，对于上面的例子，&nbsp;<code>[5, 3]</code>&nbsp;也是正确答案。</li>\n\t<li>你的算法应该具有线性时间复杂度。你能否仅使用常数空间复杂度来实现？</li>\n</ol>\n"
}
