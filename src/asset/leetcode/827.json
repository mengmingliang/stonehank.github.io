{
  "code": [
    "<pre class=\"hljs\"><code><span class=\"hljs-comment\">/**\n * @param {number[][]} grid\n * @return {number}\n */</span>\n<span class=\"hljs-comment\">/*\n例如 :[1,1,0]\n      [1,0,1]\n      [0,1,0]\n1. 先使用dfs找出所有的岛，并且将其放置到一个Map(islands)中，并且改写grid\n\n==&gt; [2,2,0]\n    [2,0,3]\n    [0,4,0]\n\n2. 检查islands，如果length为0，说明一个岛都没有，返回1；如果为1，说明只有1个岛，返回这个岛的length+1或者r*r(length+1&gt;r*r的情况)\n\n3. 遍历islands，使用bfs走2步，走完2步后，如果存在不为0并且不是当前岛的，添加到dest\n\n4. 检查dest\n\n    如果dest.size===0，说明没有能相互连接的2个岛，选择一个大的岛的length+1\n    \n    如果dest.size&gt;=1，说明至少有一个能相互连接的2个岛，选择最大的所有能连接的岛的length+1\n              \n\n\n\n*/</span>\n<span class=\"hljs-keyword\">var</span> largestIsland = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">grid</span>) </span>{\n  <span class=\"hljs-keyword\">let</span> r=grid.length,c=r\n  <span class=\"hljs-keyword\">let</span> group=<span class=\"hljs-number\">2</span>\n  <span class=\"hljs-keyword\">let</span> marked=[]\n  <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i=<span class=\"hljs-number\">0</span>;i&lt;r;i++)marked[i]=[]\n  <span class=\"hljs-keyword\">let</span> islands={}\n  <span class=\"hljs-keyword\">let</span> moves=[[<span class=\"hljs-number\">-1</span>,<span class=\"hljs-number\">0</span>],[<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">0</span>],[<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">-1</span>],[<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">1</span>]]\n  <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i=<span class=\"hljs-number\">0</span>;i&lt;r;i++){\n    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> j=<span class=\"hljs-number\">0</span>;j&lt;c;j++){\n      <span class=\"hljs-keyword\">if</span>(grid[i][j]===<span class=\"hljs-number\">1</span>){\n        islands[group]=[]\n        dfs(grid,i,j,marked)\n        group++\n      }\n    }\n  }\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">dfs</span>(<span class=\"hljs-params\">grid,x,y,marked</span>)</span>{\n    <span class=\"hljs-keyword\">if</span>(marked[x][y])<span class=\"hljs-keyword\">return</span>\n    <span class=\"hljs-keyword\">if</span>(grid[x][y]!==<span class=\"hljs-number\">1</span>) <span class=\"hljs-keyword\">return</span>\n    islands[group].push([x,y])\n    marked[x][y]=<span class=\"hljs-literal\">true</span>\n    grid[x][y]=group\n    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i=<span class=\"hljs-number\">0</span>;i&lt;moves.length;i++){\n      <span class=\"hljs-keyword\">let</span> nx=x+moves[i][<span class=\"hljs-number\">0</span>],ny=y+moves[i][<span class=\"hljs-number\">1</span>]\n      <span class=\"hljs-keyword\">if</span>(nx&gt;=<span class=\"hljs-number\">0</span> &amp;&amp; nx&lt;r &amp;&amp; ny&gt;=<span class=\"hljs-number\">0</span> &amp;&amp; ny&lt;r) dfs(grid,nx,ny,marked)\n    }\n  }\n\n  <span class=\"hljs-keyword\">let</span> vals=<span class=\"hljs-built_in\">Object</span>.values(islands)\n  <span class=\"hljs-keyword\">if</span>(vals.length===<span class=\"hljs-number\">0</span>)<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>\n  <span class=\"hljs-keyword\">if</span>(vals.length===<span class=\"hljs-number\">1</span>)<span class=\"hljs-keyword\">return</span> vals[<span class=\"hljs-number\">0</span>].length+<span class=\"hljs-number\">1</span>&gt;r*r?r*r:vals[<span class=\"hljs-number\">0</span>].length+<span class=\"hljs-number\">1</span>\n  \n  <span class=\"hljs-keyword\">let</span> connected=<span class=\"hljs-number\">0</span>\n  <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> k <span class=\"hljs-keyword\">in</span> islands){\n    <span class=\"hljs-keyword\">let</span> path=<span class=\"hljs-number\">0</span>\n    <span class=\"hljs-keyword\">let</span> bfs=islands[k].slice()\n    <span class=\"hljs-keyword\">while</span>(bfs.length&gt;<span class=\"hljs-number\">0</span>){\n      <span class=\"hljs-keyword\">let</span> len=bfs.length\n      <span class=\"hljs-keyword\">if</span>(path&gt;=<span class=\"hljs-number\">2</span>)<span class=\"hljs-keyword\">break</span>\n      <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i=<span class=\"hljs-number\">0</span>;i&lt;len;i++){\n        <span class=\"hljs-keyword\">let</span> cur=bfs.shift()\n        <span class=\"hljs-keyword\">let</span> x=cur[<span class=\"hljs-number\">0</span>],y=cur[<span class=\"hljs-number\">1</span>]\n        <span class=\"hljs-keyword\">let</span> dest=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Set</span>()\n        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> j=<span class=\"hljs-number\">0</span>;j&lt;moves.length;j++){\n          <span class=\"hljs-keyword\">let</span> nX=x+moves[j][<span class=\"hljs-number\">0</span>],nY=y+moves[j][<span class=\"hljs-number\">1</span>]\n          <span class=\"hljs-keyword\">if</span>(nX&lt;<span class=\"hljs-number\">0</span> || nX&gt;=r|| nY&lt;<span class=\"hljs-number\">0</span> || nY&gt;=r)<span class=\"hljs-keyword\">continue</span>\n          <span class=\"hljs-keyword\">if</span>(grid[nX][nY]!==<span class=\"hljs-number\">0</span> &amp;&amp; grid[nX][nY]!== +k &amp;&amp; path===<span class=\"hljs-number\">1</span>)dest.add(grid[nX][nY])\n          <span class=\"hljs-keyword\">if</span>(grid[nX][nY]===<span class=\"hljs-number\">0</span>)bfs.push([nX,nY])\n        }\n        <span class=\"hljs-comment\">// if(dest.size===0)connected=Math.max(connected,islands[k].length+1)</span>\n        <span class=\"hljs-keyword\">if</span>(dest.size&gt;=<span class=\"hljs-number\">1</span>){\n          <span class=\"hljs-keyword\">let</span> curCount=islands[k].length,sum=<span class=\"hljs-number\">0</span>\n          <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> n <span class=\"hljs-keyword\">of</span> dest)sum+=islands[n].length\n          connected=<span class=\"hljs-built_in\">Math</span>.max(connected,sum+<span class=\"hljs-number\">1</span>+curCount)\n        }\n      }\n      path++\n    }\n  }\n  <span class=\"hljs-keyword\">return</span> connected \n};\n</code></pre>\n"
  ],
  "titleSlug": "making-a-large-island",
  "translatedContent": "<p>在二维地图上，&nbsp;<code>0</code>代表海洋，&nbsp;<code>1</code>代表陆地，我们最多只能将一格&nbsp;<code>0</code> 海洋变成&nbsp;<code>1</code>变成陆地。</p>\n\n<p>进行填海之后，地图上最大的岛屿面积是多少？（上、下、左、右四个方向相连的&nbsp;<code>1</code>&nbsp;可形成岛屿）</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入: </strong>[[1, 0], [0, 1]]\n<strong>输出:</strong> 3\n<strong>解释:</strong> 将一格0变成1，最终连通两个小岛得到面积为 3 的岛屿。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入: </strong>[[1, 1], [1, 0]]\n<strong>输出:</strong> 4\n<strong>解释:</strong> 将一格0变成1，岛屿的面积扩大为 4。</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre>\n<strong>输入: </strong>[[1, 1], [1, 1]]\n<strong>输出:</strong> 4\n<strong>解释:</strong> 没有0可以让我们变成1，面积依然为 4。</pre>\n\n<p><strong>说明:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= grid.length = grid[0].length &lt;= 50</code></li>\n\t<li><code>0 &lt;= grid[i][j] &lt;= 1</code></li>\n</ul>\n"
}
