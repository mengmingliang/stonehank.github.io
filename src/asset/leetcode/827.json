{
  "code": [
    "/**\n * @param {number[][]} grid\n * @return {number}\n */\n/*\n例如 :[1,1,0]\n      [1,0,1]\n      [0,1,0]\n1. 先使用dfs找出所有的岛，并且将其放置到一个Map(islands)中，并且改写grid\n\n==> [2,2,0]\n    [2,0,3]\n    [0,4,0]\n\n2. 检查islands，如果length为0，说明一个岛都没有，返回1；如果为1，说明只有1个岛，返回这个岛的length+1或者r*r(length+1>r*r的情况)\n\n3. 遍历islands，使用bfs走2步，走完2步后，如果存在不为0并且不是当前岛的，添加到dest\n\n4. 检查dest\n\n    如果dest.size===0，说明没有能相互连接的2个岛，选择一个大的岛的length+1\n    \n    如果dest.size>=1，说明至少有一个能相互连接的2个岛，选择最大的所有能连接的岛的length+1\n              \n\n\n\n*/\nvar largestIsland = function(grid) {\n  let r=grid.length,c=r\n  let group=2\n  let marked=[]\n  for(let i=0;i<r;i++)marked[i]=[]\n  let islands={}\n  let moves=[[-1,0],[1,0],[0,-1],[0,1]]\n  for(let i=0;i<r;i++){\n    for(let j=0;j<c;j++){\n      if(grid[i][j]===1){\n        islands[group]=[]\n        dfs(grid,i,j,marked)\n        group++\n      }\n    }\n  }\n  function dfs(grid,x,y,marked){\n    if(marked[x][y])return\n    if(grid[x][y]!==1) return\n    islands[group].push([x,y])\n    marked[x][y]=true\n    grid[x][y]=group\n    for(let i=0;i<moves.length;i++){\n      let nx=x+moves[i][0],ny=y+moves[i][1]\n      if(nx>=0 && nx<r && ny>=0 && ny<r) dfs(grid,nx,ny,marked)\n    }\n  }\n\n  let vals=Object.values(islands)\n  if(vals.length===0)return 1\n  if(vals.length===1)return vals[0].length+1>r*r?r*r:vals[0].length+1\n  \n  let connected=0\n  for(let k in islands){\n    let path=0\n    let bfs=islands[k].slice()\n    while(bfs.length>0){\n      let len=bfs.length\n      if(path>=2)break\n      for(let i=0;i<len;i++){\n        let cur=bfs.shift()\n        let x=cur[0],y=cur[1]\n        let dest=new Set()\n        for(let j=0;j<moves.length;j++){\n          let nX=x+moves[j][0],nY=y+moves[j][1]\n          if(nX<0 || nX>=r|| nY<0 || nY>=r)continue\n          if(grid[nX][nY]!==0 && grid[nX][nY]!== +k && path===1)dest.add(grid[nX][nY])\n          if(grid[nX][nY]===0)bfs.push([nX,nY])\n        }\n        // if(dest.size===0)connected=Math.max(connected,islands[k].length+1)\n        if(dest.size>=1){\n          let curCount=islands[k].length,sum=0\n          for(let n of dest)sum+=islands[n].length\n          connected=Math.max(connected,sum+1+curCount)\n        }\n      }\n      path++\n    }\n  }\n  return connected \n};"
  ],
  "titleSlug": "making-a-large-island",
  "content": "<p>In a 2D grid of <code>0</code>s and <code>1</code>s, we change at most one <code>0</code> to a <code>1</code>.</p>\r\n\r\n<p>After, what is the size of the largest island?&nbsp;(An island is a 4-directionally connected group of <code>1</code>s).</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>[[1, 0], [0, 1]]\r\n<strong>Output:</strong> 3\r\n<strong>Explanation:</strong> Change one 0 to 1 and connect two 1s, then we get an island with area = 3.\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>[[1, 1], [1, 0]]\r\n<strong>Output:</strong> 4\r\n<strong>Explanation: </strong>Change the 0 to 1 and make the island bigger, only one island with area = 4.</pre>\r\n\r\n<p><strong>Example 3:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>[[1, 1], [1, 1]]\r\n<strong>Output:</strong> 4\r\n<strong>Explanation:</strong> Can&#39;t change any 0 to 1, only one island with area = 4.</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>Notes:</p>\r\n\r\n<ul>\r\n\t<li><code>1 &lt;= grid.length = grid[0].length &lt;= 50</code>.</li>\r\n\t<li><code>0 &lt;= grid[i][j] &lt;= 1</code>.</li>\r\n</ul>\r\n\r\n<p>&nbsp;</p>\r\n",
  "translatedContent": "<p>在二维地图上，&nbsp;<code>0</code>代表海洋，&nbsp;<code>1</code>代表陆地，我们最多只能将一格&nbsp;<code>0</code> 海洋变成&nbsp;<code>1</code>变成陆地。</p>\n\n<p>进行填海之后，地图上最大的岛屿面积是多少？（上、下、左、右四个方向相连的&nbsp;<code>1</code>&nbsp;可形成岛屿）</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入: </strong>[[1, 0], [0, 1]]\n<strong>输出:</strong> 3\n<strong>解释:</strong> 将一格0变成1，最终连通两个小岛得到面积为 3 的岛屿。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入: </strong>[[1, 1], [1, 0]]\n<strong>输出:</strong> 4\n<strong>解释:</strong> 将一格0变成1，岛屿的面积扩大为 4。</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre>\n<strong>输入: </strong>[[1, 1], [1, 1]]\n<strong>输出:</strong> 4\n<strong>解释:</strong> 没有0可以让我们变成1，面积依然为 4。</pre>\n\n<p><strong>说明:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= grid.length = grid[0].length &lt;= 50</code></li>\n\t<li><code>0 &lt;= grid[i][j] &lt;= 1</code></li>\n</ul>\n"
}
