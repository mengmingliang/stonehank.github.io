{
  "code": [
    "<pre class=\"hljs\"><code><span class=\"hljs-comment\">/**\n * @param {number[][]} edges\n * @param {number} M\n * @param {number} N\n * @return {number}\n */</span>\n<span class=\"hljs-keyword\">var</span> reachableNodes = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">edges, M, N</span>) </span>{\n  <span class=\"hljs-comment\">// let graph=[]</span>\n  <span class=\"hljs-comment\">// for(let i=0;i&lt;N;i++){</span>\n  <span class=\"hljs-comment\">//   graph[i]=[]</span>\n  <span class=\"hljs-comment\">//   for(let j=0;j&lt;N;j++){</span>\n  <span class=\"hljs-comment\">//     graph[i][j]=-1</span>\n  <span class=\"hljs-comment\">//   }</span>\n  <span class=\"hljs-comment\">// }</span>\n  <span class=\"hljs-comment\">// for(let i=0;i&lt;edges.length;i++){</span>\n  <span class=\"hljs-comment\">//   let [v,w,dis]=edges[i]</span>\n  <span class=\"hljs-comment\">//   graph[v][w]=dis</span>\n  <span class=\"hljs-comment\">//   graph[w][v]=dis</span>\n  <span class=\"hljs-comment\">// }</span>\n  <span class=\"hljs-comment\">// let pq=[]</span>\n  <span class=\"hljs-comment\">// function bsEnd(arr,n){</span>\n  <span class=\"hljs-comment\">//   let lo=0,hi=arr.length-1</span>\n  <span class=\"hljs-comment\">//   while(lo&lt;hi){</span>\n  <span class=\"hljs-comment\">//     let mid=Math.floor((lo+hi)/2)</span>\n  <span class=\"hljs-comment\">//     if(arr[mid][1]&lt;n)lo=mid+1</span>\n  <span class=\"hljs-comment\">//     else hi=mid</span>\n  <span class=\"hljs-comment\">//   }</span>\n  <span class=\"hljs-comment\">//   return hi</span>\n  <span class=\"hljs-comment\">// }</span>\n  <span class=\"hljs-comment\">// function insert([idx,restSteps]){</span>\n  <span class=\"hljs-comment\">//   if(pq.length===0 || pq[pq.length-1][1]&lt;=restSteps){</span>\n  <span class=\"hljs-comment\">//     pq.push([idx,restSteps])</span>\n  <span class=\"hljs-comment\">//   }else{</span>\n  <span class=\"hljs-comment\">//     let id=bsEnd(pq,restSteps)</span>\n  <span class=\"hljs-comment\">//     pq.splice(id,0,[idx,restSteps])</span>\n  <span class=\"hljs-comment\">//   }</span>\n  <span class=\"hljs-comment\">// }</span>\n  <span class=\"hljs-comment\">// function delMax(){</span>\n  <span class=\"hljs-comment\">//   return pq.pop()</span>\n  <span class=\"hljs-comment\">// }</span>\n  <span class=\"hljs-comment\">// insert([0,M])</span>\n  <span class=\"hljs-comment\">// let visited=[],res=0</span>\n  <span class=\"hljs-comment\">// while(pq.length&gt;0){</span>\n  <span class=\"hljs-comment\">//   let [curID,restSteps]=delMax()</span>\n  <span class=\"hljs-comment\">//   if(visited[curID])continue</span>\n  <span class=\"hljs-comment\">//   visited[curID]=true</span>\n  <span class=\"hljs-comment\">//   res++</span>\n  <span class=\"hljs-comment\">//   for(let i=0;i&lt;N;i++){</span>\n  <span class=\"hljs-comment\">//     if(graph[curID][i]&gt;-1){</span>\n  <span class=\"hljs-comment\">//       if(restSteps&gt;graph[curID][i] &amp;&amp; !visited[i]){</span>\n  <span class=\"hljs-comment\">//         insert([i,restSteps-graph[curID][i]-1])</span>\n  <span class=\"hljs-comment\">//       }</span>\n  <span class=\"hljs-comment\">//       graph[i][curID]-=Math.min(restSteps,graph[curID][i])</span>\n  <span class=\"hljs-comment\">//       res+=Math.min(restSteps,graph[curID][i])</span>\n  <span class=\"hljs-comment\">//     }</span>\n  <span class=\"hljs-comment\">//   }</span>\n  <span class=\"hljs-comment\">// }</span>\n  <span class=\"hljs-comment\">// return res</span>\n  \n  <span class=\"hljs-keyword\">let</span> vetex=[]\n  <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i=<span class=\"hljs-number\">0</span>;i&lt;N;i++){\n    vetex[i]={<span class=\"hljs-attr\">edges</span>:[],<span class=\"hljs-attr\">dist</span>:<span class=\"hljs-literal\">Infinity</span>}\n  }\n  <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i=<span class=\"hljs-number\">0</span>;i&lt;edges.length;i++){\n    <span class=\"hljs-keyword\">let</span> [v,w,dis]=edges[i]\n    vetex[v].edges.push({<span class=\"hljs-attr\">len</span>:dis+<span class=\"hljs-number\">1</span>,<span class=\"hljs-attr\">to</span>:vetex[w]})\n    vetex[w].edges.push({<span class=\"hljs-attr\">len</span>:dis+<span class=\"hljs-number\">1</span>,<span class=\"hljs-attr\">to</span>:vetex[v]})\n  }\n  \n  vetex[<span class=\"hljs-number\">0</span>].dist=<span class=\"hljs-number\">0</span>\n  <span class=\"hljs-keyword\">let</span> queue=[vetex[<span class=\"hljs-number\">0</span>]]\n  <span class=\"hljs-keyword\">while</span>(queue.length&gt;<span class=\"hljs-number\">0</span>){\n    <span class=\"hljs-keyword\">let</span> node=queue.shift()\n    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> adj <span class=\"hljs-keyword\">of</span> node.edges){\n      <span class=\"hljs-keyword\">if</span>(adj.to.dist&gt;node.dist+adj.len){\n        adj.to.dist=node.dist+adj.len\n        queue.push(adj.to)\n      }\n    }\n  }\n\n  <span class=\"hljs-keyword\">let</span> result=<span class=\"hljs-number\">0</span>\n  <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> [v,w,dis] <span class=\"hljs-keyword\">of</span> edges){\n    <span class=\"hljs-keyword\">let</span> left=<span class=\"hljs-built_in\">Math</span>.min(<span class=\"hljs-built_in\">Math</span>.max(M-vetex[v].dist,<span class=\"hljs-number\">0</span>),dis),\n        right=<span class=\"hljs-built_in\">Math</span>.min(<span class=\"hljs-built_in\">Math</span>.max(M-vetex[w].dist,<span class=\"hljs-number\">0</span>),dis)\n    result+=<span class=\"hljs-built_in\">Math</span>.min(left+right,dis)\n  }\n  <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> node <span class=\"hljs-keyword\">of</span> vetex){\n    <span class=\"hljs-keyword\">if</span>(M&gt;=node.dist)result++\n  }\n  <span class=\"hljs-keyword\">return</span> result \n};\n</code></pre>\n"
  ],
  "titleSlug": "reachable-nodes-in-subdivided-graph",
  "content": "<p>从具有&nbsp;<code>0</code> 到 <code>N-1</code> 的结点的<strong>无向</strong>图（&ldquo;原始图&rdquo;）开始，对一些边进行细分。</p>\n\n<p>该图给出如下：<code>edges[k]</code>&nbsp;是整数对&nbsp;<code>(i, j, n)</code>&nbsp;组成的列表，使&nbsp;<code>(i, j)</code> 是原始图的边。</p>\n\n<p><code>n</code> 是该边上<strong>新</strong>结点的总数</p>\n\n<p>然后，将边&nbsp;<code>(i, j)</code>&nbsp;从原始图中删除，将&nbsp;<code>n</code>&nbsp;个新结点&nbsp;<code>(x_1, x_2, ..., x_n)</code>&nbsp;添加到原始图中，</p>\n\n<p>将&nbsp;<code>n+1</code>&nbsp;条新边&nbsp;<code>(i, x_1), (x_1, x_2), (x_2, x_3), ..., (x_{n-1}, x_n), (x_n, j)</code>&nbsp;添加到原始图中。</p>\n\n<p>现在，你将从原始图中的结点&nbsp;<code>0</code>&nbsp;处出发，并且每次移动，你都将沿着一条边行进。</p>\n\n<p>返回最多 <code>M</code> 次移动可以达到的结点数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong><code>edges </code>= [[0,1,10],[0,2,1],[1,2,2]], M = 6, N = 3\n<strong>输出：</strong>13\n<strong>解释：</strong>\n在 M = 6 次移动之后在最终图中可到达的结点如下所示。\n<img alt=\"\" src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/08/01/origfinal.png\" style=\"height: 200px; width: 487px;\">\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong><code>edges </code>= [[0,1,4],[1,2,6],[0,2,8],[1,3,1]], M = 10, N = 4\n<strong>输出：</strong>23</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ol>\n\t<li><code>0 &lt;= edges.length &lt;= 10000</code></li>\n\t<li><code>0 &lt;= edges[i][0] &lt;&nbsp;edges[i][1] &lt; N</code></li>\n\t<li>不存在任何&nbsp;<code>i != j</code>&nbsp;情况下&nbsp;<code>edges[i][0] == edges[j][0]</code>&nbsp;且&nbsp;<code>edges[i][1] == edges[j][1]</code>.</li>\n\t<li>原始图没有平行的边。</li>\n\t<li><code>0 &lt;= edges[i][2] &lt;= 10000</code></li>\n\t<li><code>0 &lt;= M &lt;= 10^9</code></li>\n\t<li><code>1 &lt;= N &lt;= 3000</code></li>\n</ol>\n\n<p>&nbsp;</p>\n"
}
