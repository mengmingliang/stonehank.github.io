{
  "code": [
    "<pre class=\"hljs\"><code><span class=\"hljs-comment\">/**\n * @param {number[][]} edges\n * @param {number} M\n * @param {number} N\n * @return {number}\n */</span>\n<span class=\"hljs-keyword\">var</span> reachableNodes = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">edges, M, N</span>) </span>{\n  <span class=\"hljs-keyword\">let</span> graph=<span class=\"hljs-built_in\">Array</span>(N).fill().map(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span>=&gt;</span>[])\n  <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> [v,w,dis] <span class=\"hljs-keyword\">of</span> edges){\n    graph[v].push([w,dis+<span class=\"hljs-number\">1</span>])\n    graph[w].push([v,dis+<span class=\"hljs-number\">1</span>])\n  }\n  <span class=\"hljs-keyword\">let</span> minDist=<span class=\"hljs-built_in\">Array</span>(N).fill(<span class=\"hljs-literal\">Infinity</span>)\n  minDist[<span class=\"hljs-number\">0</span>]=<span class=\"hljs-number\">0</span>\n  <span class=\"hljs-keyword\">let</span> arr=[<span class=\"hljs-number\">0</span>]\n  <span class=\"hljs-keyword\">while</span>(arr.length&gt;<span class=\"hljs-number\">0</span>){\n    <span class=\"hljs-keyword\">let</span> len=arr.length\n    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i=<span class=\"hljs-number\">0</span>;i&lt;len;i++){\n      <span class=\"hljs-keyword\">let</span> v=arr.shift()\n      <span class=\"hljs-keyword\">let</span> adj=graph[v]\n      <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> [w,dis] <span class=\"hljs-keyword\">of</span> adj){\n        <span class=\"hljs-keyword\">if</span>(minDist[w]&gt;minDist[v]+dis){\n          minDist[w]=minDist[v]+dis\n          arr.push(w)\n        }\n      }\n    }\n  }\n  <span class=\"hljs-keyword\">let</span> result=<span class=\"hljs-number\">0</span>\n  <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> [v,w,dis] <span class=\"hljs-keyword\">of</span> edges){\n    <span class=\"hljs-keyword\">let</span> left=<span class=\"hljs-built_in\">Math</span>.min(<span class=\"hljs-built_in\">Math</span>.max(M-minDist[v],<span class=\"hljs-number\">0</span>),dis),\n        right=<span class=\"hljs-built_in\">Math</span>.min(<span class=\"hljs-built_in\">Math</span>.max(M-minDist[w],<span class=\"hljs-number\">0</span>),dis)\n    result+=<span class=\"hljs-built_in\">Math</span>.min(left+right,dis)\n  }\n  <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> dis <span class=\"hljs-keyword\">of</span> minDist){\n    <span class=\"hljs-keyword\">if</span>(M&gt;=dis)result++\n  }\n  <span class=\"hljs-keyword\">return</span> result \n};\n</code></pre>\n"
  ],
  "titleSlug": "reachable-nodes-in-subdivided-graph",
  "hasThinking": true,
  "thinking": "<hr>\n<p>思路：</p>\n<p>首先构建<code>graph</code>，然后构建<code>minDis</code>，指的是从<code>0</code>到其他所有点的<strong>最短</strong>距离，计算<code>minDis</code>可以使用<code>Dijkstra</code>算法。</p>\n<p>当算出所有最短距离后，要计算某一条边上的点哪些能通过，而一条边有两个顶点<code>v</code>和<code>w</code>；</p>\n<p>因此可以计算出这条边被走过的距离就是<code>到v的最短距离后还剩下的步数 + 到w最短距离后还剩下的步数</code>，当然这个数不能超过这条边的长度。</p>\n<h2>最后，在计算哪些顶点是可以通过的，只要<code>到当前顶点的最短距离&lt;=M</code>，就是可以通过。</h2>\n",
  "content": "<p>从具有&nbsp;<code>0</code> 到 <code>N-1</code> 的结点的<strong>无向</strong>图（&ldquo;原始图&rdquo;）开始，对一些边进行细分。</p>\n\n<p>该图给出如下：<code>edges[k]</code>&nbsp;是整数对&nbsp;<code>(i, j, n)</code>&nbsp;组成的列表，使&nbsp;<code>(i, j)</code> 是原始图的边。</p>\n\n<p><code>n</code> 是该边上<strong>新</strong>结点的总数</p>\n\n<p>然后，将边&nbsp;<code>(i, j)</code>&nbsp;从原始图中删除，将&nbsp;<code>n</code>&nbsp;个新结点&nbsp;<code>(x_1, x_2, ..., x_n)</code>&nbsp;添加到原始图中，</p>\n\n<p>将&nbsp;<code>n+1</code>&nbsp;条新边&nbsp;<code>(i, x_1), (x_1, x_2), (x_2, x_3), ..., (x_{n-1}, x_n), (x_n, j)</code>&nbsp;添加到原始图中。</p>\n\n<p>现在，你将从原始图中的结点&nbsp;<code>0</code>&nbsp;处出发，并且每次移动，你都将沿着一条边行进。</p>\n\n<p>返回最多 <code>M</code> 次移动可以达到的结点数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong><code>edges </code>= [[0,1,10],[0,2,1],[1,2,2]], M = 6, N = 3\n<strong>输出：</strong>13\n<strong>解释：</strong>\n在 M = 6 次移动之后在最终图中可到达的结点如下所示。\n<img alt=\"\" src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/08/01/origfinal.png\" style=\"height: 200px; width: 487px;\">\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong><code>edges </code>= [[0,1,4],[1,2,6],[0,2,8],[1,3,1]], M = 10, N = 4\n<strong>输出：</strong>23</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ol>\n\t<li><code>0 &lt;= edges.length &lt;= 10000</code></li>\n\t<li><code>0 &lt;= edges[i][0] &lt;&nbsp;edges[i][1] &lt; N</code></li>\n\t<li>不存在任何&nbsp;<code>i != j</code>&nbsp;情况下&nbsp;<code>edges[i][0] == edges[j][0]</code>&nbsp;且&nbsp;<code>edges[i][1] == edges[j][1]</code>.</li>\n\t<li>原始图没有平行的边。</li>\n\t<li><code>0 &lt;= edges[i][2] &lt;= 10000</code></li>\n\t<li><code>0 &lt;= M &lt;= 10^9</code></li>\n\t<li><code>1 &lt;= N &lt;= 3000</code></li>\n\t<li>可到达结点是可以从结点 <code>0</code> 开始使用最多 <code>M</code> 次移动到达的结点。</li>\n</ol>\n\n<p>&nbsp;</p>\n"
}
