{
  "content": "今天在LeetCode看到一篇非常有价值的讨论，列举了一系列列数组的`回溯算法`，自己动手一个个完成后，\n感觉对理解回溯算法的原理有很大帮助。\n\n就用一篇文章记录下解析过程。\n\n[原文地址](https://leetcode.com/problems/combination-sum/discuss/16502/A-general-approach-to-backtracking-questions-in-Java-(Subsets-Permutations-Combination-Sum-Palindrome-Partitioning))\n\n其实回溯就是按顺序的一种穷举，但是它会设定`停止条件`和`达成条件`\n\n一旦符合`停止条件`，直接整体跳过，包括它后面的子集全部跳过\n\n一旦符合`达成条件`，便是所需要的数据，添加到结果集合里\n\n一个简单的例子：\n\n```\n列举数组arr的所有的长度相同的组合，字符不重复\n例如：[1,2,3]\n输出：\n[\n  [1,2,3],\n  [1,3,2],\n  [2,1,3],\n  [2,3,1],\n  [3,1,2],\n  [3,2,1]\n]\n```\n\n代码：\n```js\nfunction subSet(nums){\n  let result=[],temp=[]\n  backtrack(result,temp,nums)\n  return result\n  function backtrack(result,temp,nums){\n    // 达成条件\n    if(temp.length===nums.length)result.push(temp.slice())\n    for(let i=0;i<nums.length;i++){\n      // 停止条件\n      if(temp.includes(nums[i]))continue\n      temp.push(nums[i])\n      backtrack(result,temp,nums)\n      temp.pop()\n    }\n  }\n}\n```\n\n它的运行轨迹：\n```\n1\n1 1   ×\n1 2\n1 2 1 ×\n1 2 2 ×\n1 2 3 √\n1 3\n1 3 1 ×\n1 3 2 √\n1 3 3 ×\n2\n2 1\n2 1 1 ×\n2 1 2 ×\n2 1 3 √\n2 2   ×\n2 3\n2 3 1 √\n2 3 2 ×\n2 3 3 ×\n3\n3 1\n3 1 1 ×\n3 1 2 √\n3 1 3 ×\n3 2\n3 2 1 √\n3 2 2 ×\n3 2 3 ×\n3 3   ×\n```\n\n一旦父级达到`停止条件`，例如`2 2`，像后面的子集`2 2 1`，`2 2 2`都不会进行\n\n当通过的`停止条件`并且符合`达成条件`的，就是结果。"
}
