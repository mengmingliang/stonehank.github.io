{
	"content": "先上源码：\n```js\nexport default function applyMiddleware(...middlewares) {\n  // ...\n  \n  let dispatch = () => {\n    throw new Error(\n    `Dispatching while constructing your middleware is not allowed. ` +\n    `Other middleware would not be applied to this dispatch.`\n    )\n  }\n\n  const middlewareAPI = {\n    getState: store.getState,\n    dispatch: (...args) => dispatch(...args)\n  }\n\n  const chain = middlewares.map(middleware => middleware(middlewareAPI))\n  dispatch = compose(...chain)(store.dispatch)\n  \n  // ...\n```\n1. 这里定义了一个直接报错的dispatch方法\n2. 然后设定了API中的dispatch就是会报错的dispatch方法，因此在这个阶段任何使用dispatch都会得到错误提示\n3. 最后构造结束后重新赋值dispatch\n\n当时第一眼看到觉得API那个对象都已经设定了dispatch是个提示错误的函数，后面重新赋值dispatch又没有引用关系，怎么能影响到API内的dispatch呢？\n\n后来再仔细一看，原来API中是这么设置的`dispatch:()=>dispatch()`，用了函数包裹，是动态的；\n\n当调用这个API时，则会执行当前最新的dispatch函数。\n\n"
}
