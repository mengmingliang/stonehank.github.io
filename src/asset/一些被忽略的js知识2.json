{
	"content": "#### Object对象的key\n\n一般来说，obj的key属性会自动转换成字符串（调用默认toString方法），然后再读取\n\n例如：\n\n```js\nvar myObject = { };\nmyObject[true] = \"foo\";\nmyObject[3] = \"bar\";\n\nmyObject[\"true\"]; // \"foo\"\nmyObject[\"3\"]; // \"bar\"\n```\n对于object也是如此：\n```js\nvar myObject = { };\nvar a={x:1};\nvar b={x:2}\n\nmyObject[a]=1;\nmyObject[b]=2;\n\nmyObject[\"[object Object]\"]; // 2\nmyObject; // {[object Object]: 2}\n```\n\n但如果使用Symbol，则会破坏这个规则，只有唯一值：\n```js\nvar myObject = { };\nvar a={x:1};\nvar b={x:2};\n\na=Symbol(a);\nb=Symbol(b);\n\nmyObject[a]=1;\nmyObject[b]=2;\n\nmyObject[\"Symbol([object Object])\"]; // undefined\nmyObject; // {Symbol([object Object]): 1, Symbol([object Object]): 2}\nmyObject[a]; // 1\nmyObject[b]; // 2\n```\n\n#### 一些限制对象的方法\n\n* 限制扩展 `Object.preventExtensions`\n\n```js\nvar myObject = {\n  a:2\n};\nObject.preventExtensions( myObject );\nmyObject.b = 3;\nmyObject.b; // undefined\n```\n* 密封（限制扩展的基础上，添加`configurable:false `)\n\n* 冻结（密封的基础上，添加`wirtable:false`）\n\n    note:对象内部为引用，即使对象冻结，引用变化，也会变化：\n```js\nvar obj={}\nvar a=[1,2]\nobj.x=a;\nObject.freeze(obj);\n\na.push(3)\nobj.x; // [1,2,3]\n```\n* 完全冻结（冻结的基础行，遍历内部引用对象也进行冻结）"
}
