{
  "content": "岛屿问题比较通用的算法\n\n大概思路：\n\n1. 先用dfs求出岛屿\n\n2. 再用bfs根据要求算出连通量\n\n以`827. Making A Large Island`为例\n\n题目给出一个二维数组，只有`0`和`1`，`1`代表陆地，\n当`1`周围4个方向(上下左右)有另一个`1`的时候，可以连接。\n\n问题是，只能走1步，求出能连接的岛屿的最大值\n\n例如 :\n```\n[1,1,0]\n[1,0,1]\n[0,1,0]\n```\n结果是 6.\n      \n详细思路：\n\n1. 先使用dfs找出所有的岛，并且将其放置到一个Map(islands)中，并且改写grid\n\n    ```\n                [2,2,0]\n       grid ==> [2,0,3]\n                [0,4,0]\n    ```\n\n2. 检查islands，\n\n   如果length为0，说明一个岛都没有，返回1；\n   \n   如果length为1，说明只有1个岛，返回这个岛的`length+1`或者`r*r`(`length+1>r*r`的情况)\n\n3. 遍历islands，使用bfs走2步，走完2步后，如果存在不为0并且不是当前岛的，添加到dest\n\n4. 检查dest\n\n    如果`dest.size===0`，说明没有能相互连接的2个岛，选择一个大的岛的`length+1`\n    \n    如果`dest.size>=1`，说明至少有一个能相互连接的2个岛，选择最大的所有能连接的岛的`length+1`\n\n代码：\n```js\nvar largestIsland = function(grid) {\n  let r=grid.length,c=r\n  let group=2\n  let marked=[]\n  for(let i=0;i<r;i++)marked[i]=[]\n  let islands={}\n  let moves=[[-1,0],[1,0],[0,-1],[0,1]]\n  // 对应第1步\n  for(let i=0;i<r;i++){\n    for(let j=0;j<c;j++){\n      if(grid[i][j]===1){\n        islands[group]=[]\n        dfs(grid,i,j,marked)\n        group++\n      }\n    }\n  }\n  function dfs(grid,x,y,marked){\n    if(marked[x][y])return\n    if(grid[x][y]!==1) return\n    islands[group].push([x,y])\n    marked[x][y]=true\n    grid[x][y]=group\n    for(let i=0;i<moves.length;i++){\n      let nx=x+moves[i][0],ny=y+moves[i][1]\n      if(nx>=0 && nx<r && ny>=0 && ny<r) dfs(grid,nx,ny,marked)\n    }\n  }\n  // 对应第2步\n  let vals=Object.values(islands)\n  if(vals.length===0)return 1\n  if(vals.length===1)return vals[0].length+1>r*r?r*r:vals[0].length+1\n  \n  let connected=0\n  // 对应第3步\n  for(let k in islands){\n    let path=0\n    let bfs=islands[k].slice()\n    while(bfs.length>0){\n      let len=bfs.length\n      if(path>=2)break\n      for(let i=0;i<len;i++){\n        let cur=bfs.shift()\n        let x=cur[0],y=cur[1]\n        let dest=new Set()\n        for(let j=0;j<moves.length;j++){\n          let nX=x+moves[j][0],nY=y+moves[j][1]\n          if(nX<0 || nX>=r|| nY<0 || nY>=r)continue\n          if(grid[nX][nY]!==0 && grid[nX][nY]!== +k && path===1)dest.add(grid[nX][nY])\n          if(grid[nX][nY]===0)bfs.push([nX,nY])\n        }\n        // 对应第4步\n        if(dest.size===0)connected=Math.max(connected,islands[k].length+1)\n        if(dest.size>=1){\n          let curCount=islands[k].length,sum=0\n          for(let n of dest)sum+=islands[n].length\n          connected=Math.max(connected,sum+1+curCount)\n        }\n      }\n      path++\n    }\n  }\n  return connected \n};\n```"
}
