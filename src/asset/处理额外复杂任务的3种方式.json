{
	"content": "## web worker VS idleRequestCallback VS setTimeout\n\n***测试平台：FireFox***(Chrome嵌套worker会有[bug](https://bugs.chromium.org/p/chromium/issues/detail?id=31666))\n\n|*方法*             |从0自加至100亿（相同环境）|  \n|-------------------|:--------------:|\n|web worker(10线程) |7s              |\n|web worker(单线程) |29s             |\n|idleRequestCallback|45s             |\n|setTimeout         |61s             |\n\n[项目地址](https://github.com/stonehank/handleHugeTask)\n\n一些注意点：\n\n1. web worker执行不受主线程执行影响。\n2. idle执行收到主线程影响,主线程繁忙会暂停(因为没有空闲帧),setTimeout也会受影响。\n3. worker可以嵌套，充分发挥多核cpu的性能（个人的电脑数据，worker能让浏览器进程迅速到90%，idle和setTimeout在35%徘徊，最多40%)。\n4. worker任务结束必须手动关闭，否则线程会一直占用资源。\n5. idle和setTimeout应该将任务分割成合适的小任务，否则单个任务过大会影响主线程流畅度。\n\n-----\n### web worker开启方式：\n```js\n// 开启\nlet worker=new Worker(\"workers-run.js\")\n// 传递数据，对象会序列化然后再传过去\nworker.postMessage({target,threadNum:threadNum.value})\n// 接受数据\nworker.onmessage=function (e) {\n    if(e.data===\"done\"){\n        workerRunning=false\n        // 结束线程\n        worker.terminate()\n    }\n}\n```\n内部还可以嵌套：\n```js\n// workers-run.js\n\n for(let i=0;i<n;i++) {\n    let subWorker\n    // 线程下再分n个子线程\n    subWorker = new Worker('sub-workers-run.js')\n    subWorker.postMessage(target / n)\n    subWorker.onmessage = function (e) {\n        //...\n    }\n}\n```\n-----\n### idleRequestCallback开启方式：\n\n```js\nlet idleID = requestIdleCallback(function createIdle(deadline) {\n    // 当有空闲帧 并且 未完成目标时\n    while (deadline.timeRemaining() > 0 && taskSum < target) {\n      // 调用执行函数\n      smallTask(target/3000);\n    }\n    // 如果未能调用createIdle，didTimeout为true\n    if (deadline.didTimeout) {\n      // 未能调用createIdle\n    }\n    if (taskSum < target) {\n      // 递归请求\n      requestIdleCallback(createIdle)\n    } else {\n      // 完成！\n    }\n    // 未能调用createIdle的超时时间\n}, {timeout: 1000})\n```\n\n-----\n### setTimeout的运行方式：\n```js\nif (taskSum<target) {\n  setTimeout( function(){\n    run( tg-eachTask );\n  }, 0 );\n}\n```\n经常看到使用`Promise.resolve().then`代替`setTimeout(function(){},0)`的，那么这里能不能这么写呢：\n```js\nPromise.resolve().then(function(){\n  run( tg-eachTask );\n})\n```\n\n结果是不行的，使用Promise会造成主线程阻塞，原因是Promise会加入到`任务队列`，而setTimeout会加入到`事件循环队列`\n\n一张图理解：\n\n![](./img/eventloop%20and%20callbackqueue.png)\n\n因此，使用Promise就不会去等下一次队列的渲染，结束后放到任务队列末尾继续调用"
}
