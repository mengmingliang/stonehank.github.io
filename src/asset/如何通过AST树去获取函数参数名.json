{
  "content": "### 写在最前\n\n最近项目有个需求，获取函数参数名，听起来很简单，但有了ES6，参数和函数写法千奇百怪，在github上大概看了几个库，基本上都是正则，\n对通用的写法能够覆盖，稍微越过边界，往往无法正确匹配。\n\n于是就有了使用`AST`去进行覆盖查找的想法。\n\n### 概念\n\n抽象语法树（abstract syntax tree或者缩写为AST），或者语法树（syntax tree），是源代码的抽象语法结构的树状表现形式。\n\n--------\n\n### 为什么要用AST\n\n通过AST，我们可以对代码进行查找，看起来好像正则表达式也可以做到，那么为什么要用AST而不用正则？\n\n就说从函数获取参数名，夸张点，如果有以下表达式：\n\n```js\nfunction x(a=5,b=\"a\",c=function(x=1,y){console.log(x=function(i=8,j){})},d={x:1,y:2,z:'x=6'},e=x=>7,f=['3=5','x.1','y,2',1],g=(x,y)=>{let z=(i,j=6)=>{}},h){}\n````\n\n`参数是[a,b,c,d,e,f,g,h]`\n\n你确定还想用正则去匹配参数名称吗...\n\n>AST是从代码的意义去编辑，而正则只能从代码的字面去编辑。\n\n以上夸张的函数，使用AST去分析，可以很轻松获取它的参数名。\n\n-----\n\n### Esprima\n\n我们使用[esprima](http://esprima.org/demo/parse.html#)，一个可以将Javascript代码解析成抽象树的库。\n\n首先我们需要安装它：\n\n`npm install esprima`\n\n接着调用：\n\n`const esprima=require('require'')`\n\n接下来就是分析的时候了。\n\n----\n\n### 一个简单的AST例子\n\n先来个简单的例子：\n`function a(b){}`\n\n通过esprima解析后，生成结构图如下：\n```\n{\n    \"type\": \"Program\",\n    \"body\": [\n        {   // 这个type表示这是一个函数表达式\n            \"type\": \"FunctionDeclaration\",\n            \"id\": {\n                \"type\": \"Identifier\",\n                \"name\": \"a\"\n            },\n            \"params\": [\n                {\n                    // 参数数组内的Identifier代表参数\n                    \"type\": \"Identifier\",\n                    \"name\": \"b\"\n                }\n            ],\n            \"body\": {\n                \"type\": \"BlockStatement\",\n                \"body\": []\n            },\n            \"generator\": false,\n            \"expression\": false,\n            \"async\": false\n        }\n    ],\n    \"sourceType\": \"script\"\n}\n```\n思路：\n1. `FunctionDeclaration`说明是一个函数表达式，进入`params`属性。\n2. 判断`params`中每一个的type是否为`Identifier`，在`params`属性下的`Identifier`就代表是参数。\n3. 找出name属性的值，结果为`['b']`。\n\n根据以上思路，我们可以写出一个简单的获取参数的方法了。\n```js\nfunction getParams(fn){\n  // 此处分析的代码必须是字符串\n  let astEsprima=esprima.parseScript(fn.toString())\n  let funcParams = []\n  let node = astEsprima.body[0]\n  // 找到type，进入params属性\n  if (node.type === \"FunctionDeclaration\") funcParams = node.params\n  let validParam=[]\n  funcParams.forEach(obj=>{\n    if(obj.type===\"Identifier\")\n      validParam.push(obj.name)\n  })\n  return validParam\n}\n```\n测试一番，获取结果`[\"b\"]`，庆祝收工。\n\n好吧，别高兴太早了，要知道函数的创建方法不下10种，而参数写法又有好几种...\n\n以下是一部分的函数创建方法和参数写法\n```js\nfunction a(x){}\n\n// 注意：第二条和第三条在AST中意义不同\nlet a=function(x=1){}\n\na=function(...x){}\n\nlet a=([x]=[1])=>{}\n\nasync function a(x){}\n\nfunction *a(x){}\n\nclass a{\nconstructor(x){}\n}\n\nnew Function ('x','console.log(x)')\n\n(function(){return function(x){}})()\n\neval(\"(function(){return function(a,b){}})()\")\n```\n\n有什么想法？如果你有发出\"我K\"的想法，那说明我这个装逼还算成功- -...\n\n其实只需要分几种情况(很多写法的type都是一致的)，就可以完全渗入到以上所有的参数对象内部，再进行参数获取就是循环+判断解决的事了。\n\n由于篇幅问题，这里不一一分析，只是将AST分析树所用的type和一些注意点。\n\n\n### 函数结构\n\n\n#### 变量声明语句和表达式语句\n\n上面注释中`let a=function(x=1){}`和`a=function(...x){}`是两种意义。\n\n其中`let a=function(x=1){}`指的是变量声明语句，\n\n对应的type是`VariableDeclaration`，需要进入它的初始值`init`就可以获取到函数所在的语法对象，它的type是`FunctionExpression`函数表达式，再去`params`中查找即可。\n\n变量声明语句：\n```\n├──VariableDeclaration....init\n        ├──FunctionExpression.params\n```\n\n而`a=function(...x){}`是表达式语句，\n\n对应的type是`ExpressionStatement`，需要进入它的表达式`expression`获取到表达式内部，这时我们要进入赋值表达式(`type为AssignmentExpression`)的右边(`right属性`)，\n获取函数所在的语法对象，它的type同样也是`FunctionExpression`函数表达式。\n\n表达式语句：\n```\n├──ExpressionStatement.expression\n        ├──AssignmentExpression.right\n                ├──FunctionExpression.params\n```\n\n#### class声明和Function构造函数\n\nclass声明对应的type有`ClassDeclaration`(class xx{...})或者`ClassExpression`(let x=class{...})，他们一个是声明一个是表达式，处理方式是相同的，\n进入对象内部，找到kind为`constructor`的对象，获取参数数据。\n\nclass声明语句：\n```\n├──ClassDeclaration...body...\n        ├──{kind:constructor}\n                ├──FunctionExpression.params\n```\n\nFunction构造函数对应的type是`NewExpression`或者`ClassExpression`，参数在属性`arguments`内部，但是Function的参数都是字符串，\n而且最后一个参数一定是函数内部语句，因此对于Function构造函数，就是对字符串进行处理。\n\nFunction构造函数\n```\n├──NewExpression.arguments\n        ├──{value:<String>}\n         ---->对字符串进行处理，分割参数\n```\n\n#### 箭头函数\n\n箭头函数type是`ArrowFunctionExpression`，也仅仅是名称不同，内部结构几乎一致。\n\n函数结构的type就到此。\n\n\n### 参数结构\n\n参数的type有以下：\n\n`Identifier`：最终我们需要获取的参数值的type\n\n`Property`：当存在解构参数，例如`[a,b] or {x,y}`\n\n`ArrayPattern`：存在解构参数并且是数组，例如`[a,b]`\n\n`ObjectPattern`：存在解构参数并且是对象，例如`{x,y}`\n\n`RestElement`：存在扩展运算符，例如`(...args)`\n\n我们只需要设置一个递归循环，思路和上面一样，一层进入另一层，在内部进行查找。\n\n### 总结\n\n篇幅有限，就写这么多，接着做一个总结。\n\n这篇讲的主旨只有1个，通过对AST树中每一个对象的type分析，type表示的是对应的代码的意义，也是代码的语义，例如\n\n`VariableDeclaration`内部一定会有`init`，为什么，因为变量声明是有初始值的，如果你不设置，那么就为`undefined`\n\ntype远不止这次说的这么多，官网(或者Google)上有详细介绍。\n\n--------\n### 最后\n\n[`AST获取函数参数`源代码在此](https://github.com/stonehank/get-function-params-with-ast)。\n\n如果本文对你有所帮助，欢迎STAR，或者你对此有什么更好的想法，欢迎留言！\n\n最重要如果发现了BUG或者漏匹配，请一定要告知(Issue/PR/留言)，感激不尽！"
}
