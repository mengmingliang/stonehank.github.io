{
  "content": "本次解析将分为2篇文章，当前是第二篇，第一篇在[这里](./07-20-解析anime核心(1).md)\n\n另外，为了能更好的理解这个库，个人写了一个此库的压缩版，实现了核心的功能(主要也是为了更好理解核心功能)，内容更少方便阅读，\n地址在[这里](https://github.com/stonehank/simplify-anime)\n\n\n-----\n\n继续上一篇，先把结构图拉过来：\n```js\n// anime主体\nfunction anime(params){\n  \n  // 定义instance 也是最终返回值\n  let instance = createNewInstance(params);\n  \n  // 外部API 从当前位置开始执行动画\n  instance.play = function() {}\n  \n  // 配置 startTime 和 engineTime(关键)\n   instance.tick = function(t) {}\n   \n  // 对当前engineTime进行判断，确定动画方案(关键)\n  function setInstanceProgress(engineTime) {}\n  \n  // 计算动画当前位置 并且赋值(关键)\n  function setAnimationsProgress(insTime){}\n\n  // 直接跳到参数time的时间所在的位置\n  instance.seek = function(time) {}\n  // 外部API 暂停\n  instance.pause = function() {}\n  // 外部API 反转\n  instance.reverse = function() {}\n  // 外部API reset\n  instance.reset = function() {}\n  // 外部API 重新开始\n  instance.restart = function() {}\n  /*...*/\n  return instance\n}\n```\n\n* setAnimationsProgress(省略了一些配置的定义)\n\n这个函数接受一个参数，就是当前位置所消耗时间(动画起始点)，然后在里面计算出每一个动画目标的位置，并且赋值\n\n```js\n// 计算动画当前位置 并且赋值\nfunction setAnimationsProgress(insTime) {\n  /* ... */\n  // 这个while逐个计算当前实例中的每个动画的当前位置(通过时间和算法)\n  while (i < animationsLength) {\n      /* ... */\n    // 消耗的时间占总持续时间的比例 在起点终点之间\n    const elapsed = minMaxValue(insTime - tween.start - tween.delay, 0, tween.duration) / tween.duration;\n    // 通过算法计算当前进度\n    const eased = isNaN(elapsed) ? 1 : tween.easing(elapsed, tween.elasticity);\n    /* ... */\n    // 遍历每一个到达点执行\n    for (let n = 0; n < toNumbersLength; n++) {\n      let value;\n      const toNumber = tween.to.numbers[n];\n      const fromNumber = tween.from.numbers[n];\n      if (!tween.isPath) {\n        // 计算当前具体位置\n        value = fromNumber + (eased * (toNumber - fromNumber));\n      } else {\n        // 进行SVG path计算\n        value = getPathProgress(tween.value, eased * toNumber);\n      }\n      /* ... */\n      numbers.push(value);\n    }\n         /* ... */\n        if (!isNaN(n)) {\n          // 组合单位 '135.546'+'px'\n          if (!b) {\n            progress += n + ' ';\n          } else {\n            progress += n + b;\n          }\n        }\n    /* ... */\n    // 组合结果 'translateX('+'135.546px'+')`\n    setTweenProgress[anim.type](animatable.target, anim.property, progress, transforms, animatable.id);\n    anim.currentValue = progress;\n    i++;\n  }\n  // 遍历结果，逐个target赋值\n  const transformsLength = Object.keys(transforms).length;\n  if (transformsLength) {\n    for (let id = 0; id < transformsLength; id++) {\n      if (!transformString) {\n        const t = 'transform';\n        // 配置兼容性\n        transformString = (getCSSValue(document.body, t) ? t : `-webkit-${t}`);\n      }\n      // 设置style\n      instance.animatables[id].target.style[transformString] = transforms[id].join(' ');\n    }\n  }\n  // 记录当前位置所对应的时间\n  instance.currentTime = insTime;\n  // 设置进度\n  instance.progress = (insTime / instance.duration) * 100;\n}\n```\n剩下的就是一些操作函数了：\n\n* instance.seek \n```js\n// 直接跳到参数time的时间所在的位置\ninstance.seek = function(time) {\n  setInstanceProgress(adjustTime(time));\n}\n```\n\n* instance.pause\n```js\n// 外部API 暂停\ninstance.pause = function() {\n  const i = activeInstances.indexOf(instance);\n  // 删除activeInstances 后续engine中找不到便不会执行\n  if (i > -1) activeInstances.splice(i, 1);\n  instance.paused = true;\n}\n```\n\n* instance.reverse\n\n```js\n// 外部API 反转\ninstance.reverse = function() {\n  toggleInstanceDirection();\n  startTime = 0;\n  lastTime = adjustTime(instance.currentTime);\n}\n```\n\n* instance.restart\n\n```js\n// 外部API 重新执行\ninstance.restart = function() {\n  instance.pause();\n  instance.reset();\n  instance.play();\n}\n```\n \n* instance.reset\n```js\n// 外部API reset\ninstance.reset = function() {\n  const direction = instance.direction;\n  const loops = instance.loop;\n  // 当前位置,进度 归零\n  instance.currentTime = 0;\n  instance.progress = 0;\n  instance.paused = true;\n  instance.began = false;\n  instance.completed = false;\n  instance.reversed = direction === 'reverse';\n  instance.remaining = direction === 'alternate' && loops === 1 ? 2 : loops;\n  setAnimationsProgress(0);\n  for (let i = instance.children.length; i--; ){\n    instance.children[i].reset();\n  }\n}\n```\n\n## 总结\n\n1. 使用了`requestAnimateFrame`和`CSS`动画提高流畅度。\n2. 使用了缓动函数，只需要通过`当前动画消耗的时间`，搭配其他定义的配置项，就可以计算出当前动画具体位置。\n\n此次解析就到这里结束，如有错误，敬请指出，感谢！"
}
