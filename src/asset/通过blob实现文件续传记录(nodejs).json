{
  "content": "## 一个可暂停分段上传的例子\n\n[代码位置](https://gist.github.com/stonehank/5d3dea234ac6bc200bdef9c181c0a645)\n_______\n\n要点：\n\n1. 通过`blob.slice()`对文件进行分割，再逐个上传\n\n    `blob.slice(start, end, blob.type)`\n2. 未使用表单，而是通过`FormData`(方便处理二进制)和`xhr`发送\n\n    ```js\n      let fd = new FormData()\n      fd.append('name', blob.name)\n      fd.append('start', start)\n      fd.append('fragments', cur);\n      xhr.open('POST', 'http://localhost:8080/upload.js', true);\n      xhr.send(fd)\n    ```\n3. 使用了`multiparty`，可以解析`FormData`\n4. 通过传递start值和`fs.createWriteStream`对续传文件进行修改\n\n    ```js\n    // r+ 表示修改而不是重写，r+不会自动创建不存在的文件\n    writable=fs.createWriteStream(curFileName,{flags:'r+',start:+start})\n    writable.write(content)\n    ```\n    判断文件是否存在(同步)：\n    ```js\n    try {\n      fs.accessSync(curFileName);\n    } catch (err) {\n      writable=fs.createWriteStream(curFileName)\n    }  \n    ```\n\n遇到的一些问题：\n\n1. php使用环境(本地测试需要架设虚拟服务器)\n2. xhr对二进制数据不能传递键值对(仅能传单个二进制数据)\n    \n    ```js\n    let blob=new Blob([someContent])\n    \n    xhr.send(blob)  \n    // 后台直接写入文件便可，无须转换\n    \n    xhr.send(`name=${blob.name}&content=${blob}`)\n    // 这么传后台就无法解析content，始终是个[object Object]\n    ```\n3. 通过FormData传递，有分隔符`-----`和一些编码，使用`querystring`无法解析，但使用php\n作为后端好像不存在兼容问题。\n\n4. `multiparty`当解析函数使用了`cb`则无法监听它的`part`事件，因为全部说明内容都以键值对形式传递到`cb`里面了\n，但是具体数据内容必须用`part`监听才能获取，数据获取方法和`res.on('data')`&&`res.on('end')`类似\n\n    ```js\n    let form=new Multiparty.Form()\n    \n    // 情况1：数据流入此处，不会再触发底下的监听事件\n    form.parse(req,function(err, fields, files){   \n       /* ... */   \n    });\n\n    // 情况2：数据流入监听事件\n    form.parse(req)\n\n    form.on('part', function(part) {\n         part.on('data', function(chunk){   \n           /* 情况2下，这里的chunk就是传入的分段数据 */\n         })\n         part.on('end', function(){\n           /* ... */\n         })\n    })\n    ```\n5. xhr定义`responseType='json'`，会自动将符合格式的回应值转换成json，\n   但不能使用`responseText`接收，使用`response`读取json\n   \n   另外还有`responseXML`读取document"
}
