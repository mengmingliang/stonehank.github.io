{
  "content": "<h2>阅读lodash中一段长正则理解笔记</h2>\n<p>在lodash源码<code>/.internal/stringToPath.js</code>中：</p>\n<p>这里英文是原注释，中文是简单的翻译下，后面会详细解释：</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">const</span> rePropName = <span class=\"hljs-built_in\">RegExp</span>(\n  <span class=\"hljs-comment\">// Match anything that isn't a dot or bracket.</span>\n  <span class=\"hljs-comment\">// 匹配任意 非.和非[]的任意值(1个以上)</span>\n  <span class=\"hljs-string\">'[^.[\\\\]]+'</span> + <span class=\"hljs-string\">'|'</span> +\n  <span class=\"hljs-comment\">// Or match property names within brackets.</span>\n  <span class=\"hljs-comment\">// 匹配 [</span>\n  <span class=\"hljs-string\">'\\\\[(?:'</span> +\n    <span class=\"hljs-comment\">// Match a non-string expression.</span>\n    <span class=\"hljs-comment\">// 匹配(非\" 或者 ')和后面任意数量值，即非字符串</span>\n    <span class=\"hljs-string\">'([^\"\\'].*)'</span> + <span class=\"hljs-string\">'|'</span> +\n    <span class=\"hljs-comment\">// Or match strings (supports escaping characters).</span>\n    <span class=\"hljs-comment\">// 匹配字符串(支持转义字符)</span>\n    <span class=\"hljs-string\">'([\"\\'])((?:(?!\\\\2)[^\\\\\\\\]|\\\\\\\\.)*?)\\\\2'</span> +\n  <span class=\"hljs-string\">')\\\\]'</span>+ <span class=\"hljs-string\">'|'</span> +\n  <span class=\"hljs-comment\">// Or match \"\" as the space between consecutive dots or empty brackets.</span>\n  <span class=\"hljs-comment\">// 匹配连续的点或者中括号，然后匹配值为\"\"</span>\n  <span class=\"hljs-string\">'(?=(?:\\\\.|\\\\[\\\\])(?:\\\\.|\\\\[\\\\]|$))'</span>\n, <span class=\"hljs-string\">'g'</span>)\n</code></pre>\n<h2>理解</h2>\n<ul>\n<li>第一行</li>\n</ul>\n<p><code>'[^.[\\\\]]+' + '|' +</code></p>\n<p>一个兜底的匹配，意思是匹配除了<code>.</code>和<code>[]</code>的任意值，后面的如果能匹配则会覆盖这个(因为后面的匹配字符更多)；</p>\n<p>例如：</p>\n<pre class=\"hljs\"><code><span class=\"hljs-string\">'abc'</span>.match(<span class=\"hljs-regexp\">/([^a]+|a(.)c)/</span>)\n\n<span class=\"hljs-comment\">// 这里两个都能匹配，前面匹配值为'bc'，后面的匹配值为'abc'，因此后面的优先匹配</span>\n</code></pre>\n<p>这里要注意的就是在字符串中转义需要写两次<code>\\\\</code>，而且这里<code>.</code>是不需要转义，后面那个<code>]</code>需要转义因为构成了歧义。</p>\n<ul>\n<li>第二行</li>\n</ul>\n<p><code>'\\\\[(?:' +</code></p>\n<p>这里有一个<code>?:</code>，意思是在这个括号内，匹配值但不需要储存匹配结果</p>\n<ul>\n<li>第三行</li>\n</ul>\n<p><code>'([^&quot;\\'].*)' + '|' +</code></p>\n<p>没有什么特别的...</p>\n<ul>\n<li>第四行</li>\n</ul>\n<p><code>'([&quot;\\'])((?:(?!\\\\2)[^\\\\\\\\]|\\\\\\\\.)*?)\\\\2' +</code></p>\n<p>先看<code>([&quot;\\'])</code></p>\n<p>也就是匹配双|单引号；</p>\n<p>接着分两种匹配：</p>\n<h5>4-1</h5>\n<p><code>((?:(?!\\\\2)[^\\\\\\\\]</code></p>\n<p>这里首先是<code>?!</code>，正向否定预查，意思是只有(同一个括号内)后面的不满足，才能去匹配前面的值；</p>\n<p>后面是<code>\\\\2</code>，转义后就是<code>\\2</code>，意思就是反向引用第二个括号储存的结果，就是<code>([&quot;\\'])</code>；</p>\n<p>因此<code>(?!\\\\2)</code>这里就是只要不是双|单引号，因为第四行最后有<code>*</code>，因此这里会抓取任意多个不是引号的字符，然后储存到括号匹配内（后面使用时的<a href=\"#%E5%8F%82%E6%95%B0%E5%90%AB%E4%B9%89\">第四个参数</a>)）；</p>\n<p>能抓取到这些值后，就去匹配前面的值，前面的值就是<code>([&quot;\\'])</code>，还是双|单引号，如果不能抓取这些值(例如连续多个引号)，则无法匹配；</p>\n<p><code>\\\\\\\\</code>转义后就是<code>\\\\</code>，意思就是匹配一个斜杠<code>\\</code>，这里就是不匹配<code>\\</code>；</p>\n<p>所以这句的意思就是：匹配单个引号后面的非引号值，并且它后面不能是斜杠<code>\\</code></p>\n<h5>4-2</h5>\n<p><code>|\\\\\\\\.</code></p>\n<p>转义后就是<code>\\\\.</code>，意思就是匹配一个斜杠<code>\\</code>后面可以是任意值（<em>其实就是匹配转义字符</em>，例如\\a）</p>\n<p>最后<code>*?)\\\\2</code></p>\n<p>这里用了非贪婪模式，量词后面加<code>?</code>，再搭配后面的<code>\\\\2</code>（前面说了，也就是引号）。</p>\n<p>整体的意思就是：<em><strong>前面2种匹配(<a href=\"#4-1\">4-1</a>,<a href=\"#4-2\">4-2</a>)，任何一种匹配后，匹配任意位数，直到出现第一个引号</strong></em>。</p>\n<ul>\n<li>第五行</li>\n</ul>\n<p><code>')\\\\]'+ '|' +</code></p>\n<p>这里匹配了<code>]</code>，就是补充了第二行匹配的<code>[</code>；因此我们知道从第二行到第五行的匹配，都是对在中括号<code>[]</code>内匹配类型的处理。</p>\n<ul>\n<li>第六行</li>\n</ul>\n<p><code>'(?=(?:\\\\.|\\\\[\\\\])(?:\\\\.|\\\\[\\\\]|$))'</code></p>\n<p><code>?=</code>是正向肯定预查，即符后面匹配的，去匹配前面的值，但它前面没有值，就会匹配为空<code>&quot;&quot;</code>；</p>\n<p>因此这行含义就是：出现了<code>..</code>或者<code>[][]</code>或者单独的<code>.</code>和单独的<code>[]</code>会转换成<code>&quot;&quot;</code></p>\n<ul>\n<li>第七行</li>\n</ul>\n<p><code>, 'g')</code></p>\n<p>全局匹配</p>\n<h2>使用</h2>\n<pre class=\"hljs\"><code>string.replace(rePropName, (match, expression, quote, subString) =&gt; {\n<span class=\"hljs-keyword\">let</span> key = match\n<span class=\"hljs-keyword\">if</span> (quote) {\n  <span class=\"hljs-comment\">// 将 \\\\ 转换成 \\</span>\n  key = subString.replace(reEscapeChar, <span class=\"hljs-string\">'$1'</span>)\n}\n<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (expression) {\n  <span class=\"hljs-comment\">// 去两端空格</span>\n  key = expression.trim()\n}\nresult.push(key)\n})\n</code></pre>\n<p>这里<code>replace</code>第二个参数是函数，因此函数的参数按以下顺序排列：</p>\n<ol>\n<li>\n<p>匹配值</p>\n</li>\n<li>\n<p>匹配过程中括号内储存(匹配)的值，有多个则占用多个参数位置</p>\n<p>...</p>\n</li>\n<li>\n<p>匹配值对应的索引</p>\n</li>\n<li>\n<p>输入的字符串</p>\n</li>\n</ol>\n<h5>参数含义</h5>\n<p><code>match</code>是整个表达式匹配的值</p>\n<p><code>expression</code>匹配<em>中括号内</em>非字符串</p>\n<p><code>quote</code>匹配<em>中括号内</em>第一个引号(后面不能也是引号，就是不能重复)</p>\n<p><code>subString</code>是<em>中括号内</em>具体字符串的值(无引号)</p>\n<p>因此：</p>\n<p><code>if (quote)</code>说明中括号内是字符串，有可能有转义，要进行处理。</p>\n<p><code>if (expression)</code>说明中括号内是非字符串，是属性值，需要去空格处理。</p>\n<h2>总结</h2>\n<p>通过这个正则，学到了：</p>\n<ol>\n<li>正则匹配以匹配字符多的优先。</li>\n<li><code>\\1</code>, <code>\\2</code>, <code>?!</code>, <code>?=</code>, <code>?:</code>, 在字符串中<code>\\\\\\\\</code>的使用。</li>\n<li>使用 <code>?!</code>，遇到重复值，取消后面部分匹配(从而减少匹配优先权)。</li>\n</ol>\n<pre class=\"hljs\"><code><span class=\"hljs-comment\">// 这里a设定不能为重复值</span>\n\n<span class=\"hljs-string\">\"abc\"</span>.match(<span class=\"hljs-regexp\">/a((?!a).)*/</span>)\n<span class=\"hljs-comment\">// 匹配值：abc</span>\n<span class=\"hljs-string\">\"aabc\"</span>.match(<span class=\"hljs-regexp\">/a((?!a).)*/</span>)\n<span class=\"hljs-comment\">// 匹配值：a</span>\n</code></pre>\n<ol start=\"4\">\n<li>使用<code>?=</code>置空匹配值</li>\n</ol>\n<pre class=\"hljs\"><code><span class=\"hljs-comment\">// 只要连续出现abcd 则匹配为空</span>\n\n<span class=\"hljs-string\">'abced'</span>.match(<span class=\"hljs-regexp\">/(?=.*abcd.*)|.*/</span>)\n<span class=\"hljs-comment\">// 匹配值：abced</span>\n<span class=\"hljs-string\">'eabcdd'</span>.match(<span class=\"hljs-regexp\">/(?=.*abcd.*)|.*/</span>)\n<span class=\"hljs-comment\">// 匹配值：''</span>\n</code></pre>\n<ol start=\"5\">\n<li>replace第二参数函数的使用，括号的匹配有值会增加函数参数的数量。</li>\n</ol>\n"
}
