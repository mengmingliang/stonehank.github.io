{
  "content": "`Leetcode`上有一系列类似的题目，看了几位大神的答案，感觉这类题目都能套用，都是DP(动态规划)的思路。\n\n题目1：\n\n给出一个数组，其中每一个元素表示第`i`天的价格。\n\n你可以多次交易，但同一天只能交易1次，求交易获取最大值。\n\n例如：`[1,6,0,3,4,8,2]`\n\n最大收益为：`6-1 + 8-0`=13\n\n```js\nfunction maxProfit(prices){\n  let prev_sell,prev_buy,prev_rest,\n      sell=0,buy=-prices[0],rest=0\n  for(let i=0;i<prices.length;i++){\n      prev_buy=buy;prev_rest=rest;prev_sell=sell\n      sell=prev_buy+prices[i]\n      buy=Math.max(prev_rest-prices[i],prev_buy,prev_sell-prices[i])\n      rest=Math.max(prev_rest,prev_sell)\n  }\n  return Math.max(sell,rest)\n}\n``` \n虽然对于这道题，有一种解法更简单，就是只要`prices[i]-pries[i-1]`是正数，就算到profit里面。\n\n但上面的是一种模式，对于此种类型的题，都可以套用这套模式。\n\n思路：\n1. 每一天都有可能3种行动，sell, buy, rest(什么都不做)。\n2. 如果第i天是sell，那么它的前面一定已经买了(buy)，`sell=prev_buy+prices[i]`\n3. 如果第i天是buy，那么它的前面有可能刚卖出去，`prev_sell-prices[i]`，\n有可能是休息，`prev_rest-prices[i]`,也有可能是保持买的状态，`prev_buy`，例如`1,2,3`，就是买了1,到了3才卖。\n4. 如果第i天是rest，那么它前面有可能，买、卖、休息，但前面是买一定会小，所以`Math.max(prev_rest,prev_sell)`\n\n最后只要比较最后一天的行动是卖出还是休息，比较哪个更大就是最大收益。\n\n题目2：\n\n给出一个数组，其中每一个元素表示第`i`天的价格。\n\n你可以多次交易，但同一天只能交易1次，并且每次交易完成有手续费，求交易获取最大值。\n\n例如：`[1,6,0,3,4,8,2]`，手续费是`6`\n\n最大收益为：`8-0-6`=2\n\n直接套模板，每次sell要扣去手续费便可\n```js\nfunction maxProfit(prices,fee){\n  let prev_sell,prev_buy,prev_rest,\n      sell=0,buy=-prices[0],rest=0\n  for(let i=0;i<prices.length;i++){\n      prev_buy=buy;prev_rest=rest;prev_sell=sell\n      // 这里加了fee\n      sell=prev_buy+prices[i]-fee\n      buy=Math.max(prev_rest-prices[i],prev_buy,prev_sell-prices[i])\n      rest=Math.max(prev_rest,prev_sell)\n  }\n  return Math.max(sell,rest)\n}\n```\n\n题目3：\n\n给出一个数组，其中每一个元素表示第`i`天的价格。\n\n你可以多次交易，但同一天只能交易1次，并且每次交易完成必须休息一天，求交易获取最大值。\n\n例如：`[1,6,0,3,4,8,2]`\n\n最大收益为：`6-1 + 8-3`=10\n\n套模板，只是买的那一天之前不能是卖出，必须是休息或者保持买的状态。\n\n`buy=Math.max(prev_rest-prices[i],prev_buy,prev_sell-prices[i])`\n\n`--->`\n\n`buy=Math.max(prev_rest-prices[i],prev_buy)`\n\n```js\nfunction maxProfit(prices){\n  let prev_sell,prev_buy,prev_rest,\n      sell=0,buy=-prices[0],rest=0\n  for(let i=0;i<prices.length;i++){\n      prev_buy=buy;prev_rest=rest;prev_sell=sell\n      sell=prev_buy+prices[i]\n      // 此处不能是卖出后立刻买\n      buy=Math.max(prev_rest-prices[i],prev_buy)\n      rest=Math.max(prev_rest,prev_sell)\n  }\n  return Math.max(sell,rest)\n}\n```\n\n题目4：\n\n给出一个数组，其中每一个元素表示第`i`天的价格。\n\n你可以交易1次，同一天只能交易1次，求交易获取最大值。\n\n例如：`[1,6,0,3,4,8,2]`\n\n最大收益为：`0 买 8卖 `=8\n\n因为这里只能交易1次，我们不用定义之前的情况`prev_buy`,`prev_rest`,`prev_sell`\n\n只需要定义一个买入，一个卖出便可。\n\n代码如下：\n```js\nfunction maxProfit(prices){\n    let sell=0,buy=-prices[0]\n    for(let i=0;i<prices.length;i++){\n        sell=Math.max(buy+prices[i],sell)\n        buy=Math.max(-prices[i],buy)\n    }\n    return sell\n}\n```\n\n题目5：\n\n给出一个数组，其中每一个元素表示第`i`天的价格。\n\n你可以最多交易2次，同一天只能交易1次，求交易获取最大值。\n\n例如：`[1,6,0,3,4,8,2]`\n\n最大收益为：`1买 6卖+0买 8卖 `=13\n\n同上一题，这里最多交易2次，因此不需要定义`prev`情况\n\n只需要定义2个买入，2个卖出便可。\n\n代码如下：\n```js\nfunction maxProfit(prices){\n    let sell1=0,buy1=-prices[0],sell2=0,buy2=-prices[0]\n    for(let i=0;i<prices.length;i++){\n        sell1=Math.max(buy1+prices[i],sell1)\n        buy1=Math.max(buy1,-prices[i])\n        sell2=Math.max(buy2+prices[i],sell2)\n        buy2=Math.max(-prices[i]+sell1,buy2)\n    }\n    return sell2\n}\n```"
}
