{
  "content": "## 关于Consumer的补充\n\n官方（英文）：\n>All Consumers that are descendants of a Provider will re-render whenever the Provider’s value prop changes. \nThe propagation from Provider to its descendant Consumers is not subject to the shouldComponentUpdate method, \nso the Consumer is updated even when an ancestor component bails out of the update.\n\n>Changes are determined by comparing the new and old values using the same algorithm as Object.is.\n\n大概翻译：\n\n每当 Provider 的value发生改变时，其内部所有的 Consumers 都将会重新渲染。这种改变不会受到shouldComponentUpdate方法影响，\n因此即使组件取消了更新，但是Consumer还是会继续渲染。\n\nConsumer是通过使用相同的算法如Object.is比较新旧值来确定变化。\n\n---\n\n这个特性在源码中这么体现：\n```\nlet Location = ({ children }) => (\n\n  <LocationContext.Consumer>\n    {context =>\n      context ? (\n      // 后面继续创建时（嵌套），context会动态随着父级的Provider更新，因此直接调用children\n        children(context)\n      ) : (\n      // 第一次创建时 context 无值，创建 LocationProvider\n        <LocationProvider>{children}</LocationProvider>\n      )\n    }\n  </LocationContext.Consumer>\n);\n```\n这个Location组件返回值是一个`createContext(/* 无参数*/)`的`Consumer`，当使用组件时`Router/Link/Redirect/Match`，它都在内部。\n\n因此第一次创建在`Router组件`内部的时候，`context`是undefined，会创建`LocationProvider组件`，\nLocationProvider组件就是对应的`Provider`，并且内部会获取到公共使用的跳转方法`navigate`和当前url的信息`location`作为它的value。\n\n而当`Route Component`内部继续嵌套`Router`的时候，context会获取到`Provider`的value值，因此直接调用`children(context)`\n\n结构如下：\n```\nclass App extends Component{\n    /*...*/\n    return (\n        // 最外层的Location，创建 LocationProvider组件\n        <Router>\n            <Home path=\"...\" />\n            <Details path=\"...\"  />\n        </Router>\n    )\n}\n\nclass Details extends Component{\n    /*...*/\n    return (\n        // 嵌套的Location，直接调用children(context)\n        // 这里children是一个参数是context的函数\n        <Link to=\"...\" >Details-1</Link>\n    )\n}\n```\n## Promise.resolve().then\n\n源码中看到这种语句：\n```\nPromise.resolve().then(() => {\n      navigate(insertParams(to, props), { replace, state });\n    });\n```\n之前并未见过，觉得这不就是个Promise立即完成的异步吗，为什么不使用`setTimeout(()=>{},0)`，有什么区别呢\n\n```js\nsetTimeout(()=>{\n  console.log(1)\n},0);\n\nPromise.resolve().then(() => {\n  console.log(2)\n    });\n// 2\n// 1\n```\n\nPromise的任务会添加到当前任务队列的末尾，而setTimeout中的任务是放到下一个事件循环列表执行\n\n一张图理解：\n![](./img/eventloop%20and%20callbackqueue.png)\n\n简单来说，Promise就是异步，越快越好"
}
