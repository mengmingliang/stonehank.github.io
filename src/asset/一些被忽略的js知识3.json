{
  "content": "一些JS基础(3)\n#### for...of\n\n `for..of`会寻找内置或者自定义的 @@iterator 对象并调用它的 next() 方法来遍历数据值\n \n array默认带有iterator，因此可以直接使用for...of\n ```js\nvar arr=[1,2,3];\nvar it=arr[Symbol.iterator]()\n\nit.next() // {value: 1, done: false}\nit.next() // {value: 2, done: false}\nit.next() // {value: 3, done: false}\nit.next() // {value: undefined, done: true}\n```\nobject默认不带iterator，不可以直接使用for...of，但可以手动添加iterator属性后\n```js\nvar obj={x:1,y:2,z:3}\nfor(let key of obj){console.log(key)} // TypeError:obj is not iterable\n\nObject.defineProperty(obj,Symbol.iterator,{\n  writable:false,\n  enumerable:false,\n  configurable:true,\n  value:function(){\n    var curO=this;\n    var oId=Object.keys(curO);\n    var curIdx=0;\n    return{\n      next:function(){\n        return {\n          value:curO[oId[curIdx++]],\n          done:curIdx>oId.length\n        }\n      }\n    }\n  }\n})\nfor(let key of obj){console.log(key)} \n// 1\n// 2\n// 3\n```\n\n#### for...in和in\n\n`for(let key in obj){...}`查找的属性必须是可枚举的，在整个原型链上查找\n\n`key in obj`查找的属性可以不是可枚举的，在整个原型链上查找\n\n#### 原型链继承\n\n```\n// ES6 之前需要抛弃默认的 Bar.prototype\nBar.ptototype = Object.create( Foo.prototype );\n// ES6 开始可以直接修改现有的 Bar.prototype\nObject.setPrototypeOf( Bar.prototype, Foo.prototype );\n```\n#### setPrototypeOf,getPrototypeOf,isPrototypeOf\n\n```js\nvar a={x:1}\nvar b={y:2}\n\nObject.setPrototypeOf(a,b)\na.__proto__===b // true\nObject.getPrototypeOf(a)===a.__proto__ // true\nb.isPrototypeOf(a) // true\n\n/*           null\n*             | prototype\n*            Object \n*  prototype /\n*           b \n*            \\ prototype \n*             a\n* */\n```\n\n#### class的prototype\n\n先不用class\n```js\nfunction A(n){\n  this.id=n\n}\nA.prototype.show=function(){\n  console.log(this.id)\n}\n\nvar a=new A(5)\na.show() // 5\n```\n接着我们改变prototype，分2种形式\n```js\n// 一：更改prototype上的属性\nA.prototype.show=function(){\n  console.log(\"change\")\n}\na.show() // change 生效\n\n// 二：直接更改整个prototype\nA.prototype={\n  show:function(){\n    console.log(\"change\")\n  }\n}\na.show() // 5 未生效\nvar a2=new A(5)\na2.show() // change 生效\n```\n\n再看class\n```js\nclass A{\n  constructor(n){\n    this.id=n\n  }\n  show(){\n    console.log(this.id)\n  }\n}\nvar a=new A(8)\na.show() // 8\n```\n改变prototype\n```js\n// 一：更改prototype上的属性\nA.prototype.show=function(){\n  console.log(\"change\")\n}\na.show() // change 生效\n\n// 二：直接更改整个prototype\nA.prototype={\n  show:function(){\n    console.log(\"change\")\n  }\n}\na.show() // 8 未生效\nvar a2=new A(5)\na2.show() // 5 未生效\n```\n\n结论：\n1. 非class模式下，直接修改整个prototype并不能影响已经创建的实例，但对后来创建的实例有影响\n2. class模式下，直接修改整个prototype既不能影响已经创建实例，也不能影响后来创建的实例"
}
