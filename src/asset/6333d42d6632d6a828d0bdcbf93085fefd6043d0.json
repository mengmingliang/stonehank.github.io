{
  "content": "#### Hooks\n\n---------\n\n* useState:\n1. 可以在非class使用state\n2. 返回一个数组\n\n    arr[0]是具体的state\n    \n    arr[1]是改变state的方法\n    \n    `const [count, setCount] = useState(initialCount);`\n\n3. 不像this.setState，useState不能合并state，例如\n\n    `state={x:1,y:2}  set({x:3}) ===> state={x:3}`\n    \n    `state={x:1,y:2} this.setState({x:3})===>state={x:3,y:2}`\n\n4. 初始化只会执行一次，因此一些昂贵的操作应该放到初始化执行，例如：\n    ```js\n    const [state, setState] = useState(() => {\n      const initialState = someExpensiveComputation(props);\n      return initialState;\n    });\n    ```\n\n------\n\n* useEffect:\n\n函数式组件主体都是挂载在render，使用副作用操作会有一些意外bug发生。\n\n但可以在useEffect内部执行，这个钩子在render之后才执行。\n\n1. useEffect的返回值会在unmount之前执行\n    ```js\n    useEffect(() => {\n      const subscription = props.source.subscribe();\n      return () => {\n        // Clean up the subscription\n        subscription.unsubscribe();\n      };\n    });\n    ```\n    \n2. useEffect第二个参数(array)，规定的数据发生变化才会执行\n\n    ```js\n    useEffect(\n      () => {\n        const subscription = props.source.subscribe();\n        return () => {\n          subscription.unsubscribe();\n        };\n      },\n      [props.source],\n    );\n    ```\n------\n    \n* useContext:\n\n和`static contextType`很像\n\n`const context = useContext(Context);`\n\n一行代码代替了\n```\n<Context.Provider>\n<Context.Consumer>\n```"
}
