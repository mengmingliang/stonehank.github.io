{
  "content": "## foreignObject\n\nsvg内部标签`<foreignObject>`，可以直接在svg内部插入`xhtml`元素，再通过`blob`和`FileReader`可\n将内部`xhtml`内容转换成*同源*url，再通过`img.src=url`将svg内部的dom元素转化为图片。\n\n```js\nlet  data = `\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"100\" height=\"150\">\n  <foreignObject width=\"100%\" height=\"100%\">\n    <div xmlns=\"http://www.w3.org/1999/xhtml\" style=\"width:100px;\">\n       <span>some text</span>\n    </div>\n  </foreignObject>\n</svg>`;\nlet img = new Image();\nlet svg = new Blob([data], {type: 'image/svg+xml;charset=utf-8'});\nlet fr=new FileReader()\nfr.readAsDataURL(svg)\nlet url\nfr.onload=function(){\n  url=fr.result\n  img.src = url\n  document.body.appendChild(img)\n}\n```\n## getImageData\n\n获取canvas内部的像素点\n\n\n```js\n// 获取整个画布的像素点\nlet imgData=ctx.getImageData(0, 0, canvas.width, canvas.height)\n\nfor (let py = 0; py < canvas.height; py += 1) {\n  for (let px = 0; px < canvas.width; px += 1) {\n    // 检查透明的参数(0-255)，255为完全不透明\n    let i = (px + py * canvas.width) * 4 - 1\n    const pixel = imgData.data[i];\n    if (pixel === 255) {\n      // do something\n    } \n  }   \n}\n```"
}
