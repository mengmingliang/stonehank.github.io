{
	"content": "思路：利用对称思想\n\n1. 先将原字符串转换成转换成 `#x$x$x$` 的形式(一定是奇数)\n2. p为一个数组，储存每一个值的最大回文数量的一半+1，例如：'ababa' 对应的p 就是`[1,2,3,2,1]`\n3. `max`为当前已经计算过得最大回文量`p[id]`+对应的位置`id`，默认为0或者-infinity，可以保证最后的max和id不为0\n4. 遍历变形的字符串，指针为`i`\n\n    `i`在当前`max`所涵盖的范围内，如下图，`i`在`max`范围内，`j`是对称的点\n    ```\n      j        i\n    ------id------\n    ```        \n    分4种情况:\n    1. `j`超出范围，那么`i`只取范围内\n        ```   \n        ---j---      -i-\n          ------id------              \n        ```    \n    2. `j`边界刚好在范围上，不仅将`i`设置，并且还要继续扩展`i`，因为虽然`j`左边不存在，但`i`的右边不确定\n        ``` \n         --j--    --i--\n         ------id------   =>  继续扩展i\n         ```\n    3. `j`边界在范围内，只需要简单赋值给`i`即可，因为此时`j`和`i`的值完全相等\n        ```  \n         -j-      -i-\n        ------id------\n        ```\n      \n    4. `i`不在当前`max`所涵盖的范围内，需要扩展\n        ```\n                      i\n       ------id------     => 需要扩展i\n        ```\n5. 最后扩展完后重新定义`p[i]`和`max`，`id`，最终`2*(max-id)-1`就是最大子回文字符串长度\n   \n         \n代码：\n```js\nfunction  manacher(s){\n  // 这里不论奇偶，都将s转换成 '#x$x$x$' 的形式\n  let str='#'\n  for(let i=0;i<s.length;i++) str+=s[i]+'$'\n  // p为一个数组，储存每一个值的最大回文数量的一半+1，例如：'ababa' 对应的p 就是[1,2,3,2,1]\n  let p=[1]\n  // max为当前已经计算过得最大回文量(p[id])+对应的位置(id)，默认为0或者-infinity，可以保证最后的max和id不为0\n  let max=0,id=0\n  // 暴力计算时，从左右什么位置开始进行对比\n  let temp=1\n  // newCenter是目前需要重新暴力计算的位置\n  let newCenter=0\n  // 从第一个开始遍历，第0个不用管，是'#'\n  for(let i=1;i<str.length;i++){\n    // i在当前max所涵盖的范围内，如下图，i在max范围内，j是对称的点\n    /*\n      *        j        i\n      *      ------id------\n    * */\n    if(max>i){\n      // 在范围内对称的位置\n      let j=id-(i-id)\n      // 通过boundary判断对称位置那个是否会超出范围\n      let boundary=p[j]+i\n      // j超出范围，那么i只取范围内，如下图\n      /*\n      *    ---j---      -i-\n      *      ------id------\n      * */\n      if(boundary>max){\n        p[i]=p[j]-(boundary-max)\n        continue;\n      // j边界刚好在范围上，不仅将i设置，并且还要继续扩展i，即设置newCenter和temp\n        /*\n        *      --j--    --i--\n        *      ------id------   =>  继续扩展i\n        * */\n      }else if(boundary===max){\n        temp=p[j]\n        newCenter=i\n      // j边界在范围内，只需要简单赋值给i即可，因为此时j和i的值完全相等\n        /*\n        *       -j-      -i-\n        *      ------id------\n        * */\n      }else{\n        p[i]=p[j]\n        continue;\n      }\n      // i不在当前max所涵盖的范围内，需要暴力计算，如下图\n      /*\n        *                     i\n        *      ------id------     => 需要扩展i\n      * */\n    }else{\n      temp=1\n      newCenter=i\n    }\n    // 暴力计算\n    while(newCenter-temp>=0 && newCenter+temp <str.length && str[newCenter-temp]===str[newCenter+temp]){\n      temp++\n    }\n    // 暴力计算完后重新定义p[i]和max，id\n    p[i]=temp\n    if(p[i]>max-id){\n      max=p[i]+i\n      id=i\n    }\n  }\n  // 此时2*(max-id)-1就是最大回文字符串的length\n\n  // 去掉# 和 $符号\n  let res=str[id],realRes=''\n  for(let i=1;i<max-id;i++){\n    res=str[id-i]+res+str[id+i]\n  }\n  for(let i=0;i<res.length;i++){\n    if(res[i]==='$' || res[i]==='#')continue\n    realRes+=res[i]\n  }\n  return realRes\n}\n```\n测试：\n```js\nlet test=[\"abb\",\"a\",\"aaaabaaa\",\"bb\",\"ccc\",'abbxz','accbcca','','abaxabaxabybaxabyb']\nlet answer=['bb','a','aaabaaa','bb','ccc','bb','accbcca','','baxabybaxab']\nlet res\nfor(let i=0;i<test.length;i++){\nres=manacher(test[i])\n  console.log(res===answer[i])\n}\n```"
}
