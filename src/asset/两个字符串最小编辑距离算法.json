{
  "content": "#### 学习Levenshtein Distance算法\n \n  任意单个字符变动有3种情况，替换，增加和删除：\n\n**1. 如果对应的字符相同，则从它的左，斜或者上方选取最小值，直接填写**\n**2. 如果对应的字符不相同，则从它的左，斜或者上方选取最小值，+1后填写**\n\n括号内部表示需要进行移动的步数\n\n * 情况一：从ab到ac的变动\n  \n  x位置 字符不相等(b!==c)，但是 i位置变动最小，所以从i位置的数值加1，斜线说明说替换\n\n   ```\n     a     b\n  a i(0) j(1)\n  c l(1)  x\n  // x=1\n  ```\n * 情况二：从acd到ac的变动\n \n  x位置 字符不相等(b!==c)，但是 m位置变动最小，所以从m位置的数值加1，横向说明增加\n  \n  ```\n     a     c     d\n  a i(0)  j(1)  k(2)\n  c l(1)  m(0)  x \n  // x=1\n  ```\n  \n * 情况三：从ab到abc的变动\n \n  x位置 字符不相等(b!==c)，但是 l位置变动最小，所以从l位置的数值加1，竖向说明减少\n\n  ```\n    a      b\n  a i(0)  j(1)\n  b k(1)  l(0)\n  c m(2)  x\n  // x=1\n ```\n \n 每一次的判断所确定的最小变动数，又是下一次判断变动的基础\n\n\n```js\nfunction minED(a,b){\n  // 先创建a和b的二维数组（横竖都额外多一行，作为第一个字符比较的基础）\n  let arr=Array(b.length+1).fill(null);\n  for(let i=0;i<arr.length;i++){\n    arr[i]=Array(a.length+1).fill(null);\n    if(i===0){\n      for(let j=0;j<arr[0].length;j++){arr[0][j]=j;}\n    }\n    arr[i][0]=i;\n  }\n  // 对每一个字符进行比较，利用上一次比较的基础\n  for(let i=1;i<arr.length;i++){\n    for(let j=1;j<arr[i].length;j++){\n      let count=0;\n      if(b[i-1]!==a[j-1]){\n        count++;\n      }\n      arr[i][j]=Math.min(arr[i-1][j-1],arr[i-1][j],arr[i][j-1])+count;\n    }\n  }\n  return arr[b.length][a.length]\n}\n\nlet a='abcd',b=\"adbc\"\nminED(a,b)\n```\n\n```js\nlet a='abcd',b=\"adbc\"\nminED(a,b)\n\n// 输出数据：\n[ [ 0, 1, 2, 3, 4 ],\n  [ 1, 0, 1, 2, 3 ],\n  [ 2, 1, 1, 2, 2 ],\n  [ 3, 2, 1, 2, 3 ],\n  [ 4, 3, 2, 1, 2 ] ]\n```\n因此从'abcd'变动到'adbc'，最小移动步数是2"
}
