{
  "content": "<p>通常海明距离的计算使用 <code>^</code>，再计算1的次数</p>\n<p>但如果遇到大量数据，并且需要计算相互的海明距离，这种方法就不合适了，因为每次计算1的次数相对消耗是巨大的</p>\n<p>另一种计算海明距离的方法：</p>\n<pre class=\"hljs\"><code><span class=\"hljs-comment\">/**\n* @param nums {Array}\n* @returns {number}\n*/</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">calcHam</span>(<span class=\"hljs-params\">nums</span>)</span>{\n  <span class=\"hljs-keyword\">let</span> total=<span class=\"hljs-number\">0</span>,binCount\n  <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i=<span class=\"hljs-number\">0</span>;i&lt;<span class=\"hljs-number\">32</span>;i++){\n    binCount=<span class=\"hljs-number\">0</span>\n    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> j=<span class=\"hljs-number\">0</span>;j&lt;nums.length;j++){\n          binCount+=(nums[j] &gt;&gt; i) &amp; <span class=\"hljs-number\">1</span>\n    }\n    total+=binCount*(nums.length-binCount)\n  }\n  <span class=\"hljs-keyword\">return</span> total\n}\n</code></pre>\n<p>这里主要是 <code>&gt;&gt;</code> 和 <code>&amp;</code>，实现对每一个数据进行位数处理</p>\n<p>思路是：</p>\n<p>1、对每一个数据进行右移 i位<code>nums[j] &gt;&gt; i</code> ，得出 k</p>\n<p>2、对 k 进行 <code>k &amp; 1</code>， 1 的二进制是<code>...00001</code>，因此可以判断出 k 的最后1位是 1 还是 0，所以<code>binCount</code>就是最后一位为1的数量</p>\n<p>3、<code>binCount*(nums.length-binCount)</code> ，其中<code>nums.length-binCount</code>指最后一位是0的数量，因此<code>1的数量*0的数量</code>，也就是它们能组合的海明距离</p>\n"
}
