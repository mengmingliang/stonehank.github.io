{
  "content": "<p>给定一个排序好的数组，两个整数<code>k</code> 和<code>x</code>，从数组中找到最靠近<code>x</code>（两数之差最小）的 <code>k</code>个数。返回的结果必须要是按升序排好的。\n如果有两个数与 <code>x</code> 的差值一样，优先选择数值较小的那个数。</p>\n<pre class=\"hljs\"><code>示例 1:\n输入: [1,2,3,4,5], k=4, x=3\n输出: [1,2,3,4]\n</code></pre>\n<pre class=\"hljs\"><code>示例 2:\n输入: [1,2,3,4,5], k=4, x=-1\n输出: [1,2,3,4]\n</code></pre>\n<p>这道题有多种解法，比较好想的是<code>O(lgN+k)</code></p>\n<p>思路：\n先二分法找出<code>x</code>或者最接近<code>x</code>的位置<code>idx</code>，然后双指针分别处理<code>idx-1</code>和<code>idx+1</code>，最后将结果排序返回。</p>\n<p>代码：</p>\n<pre class=\"hljs\"><code>class Solution(object):\n    def findClosestElements(self, arr, k, x):\n        &quot;&quot;&quot;\n        :type arr: List[int]\n        :type k: int\n        :type x: int\n        :rtype: List[int]\n        &quot;&quot;&quot;\n        N=len(arr)\n        \n        # 求出最接近x的位置lo\n        lo,hi=0,N-1\n        while lo&lt;hi:\n          mid=(lo+hi)//2\n          if arr[mid]&lt;x:lo=mid+1\n          else:hi=mid\n          \n        # 双指针处理left和right\n        ans=[]\n        left,right=lo-1,lo\n        while (left&gt;=0 or right&lt;N) and k&gt;0:\n          k-=1\n          if left&lt;0:\n            ans.append(arr[right])\n            right+=1\n          elif right&gt;=N:\n            ans.append(arr[left])\n            left-=1\n          else:\n            l=x-arr[left]\n            r=arr[right]-x\n            if l&lt;=r:\n              ans.append(arr[left])\n              left-=1\n            elif l&gt;r :\n              ans.append(arr[right])\n              right+=1\n        ans.sort()\n        return ans\n</code></pre>\n<p>另外还有一种<code>O(lg(N-K))</code>的解法，用的是滑动窗口的道理。</p>\n<p>思路：</p>\n<ol>\n<li>因为接近<code>x</code>的<code>k</code>个数一定是连续的，因此我们只需要确定这个连续数组的起始点，就可以返回结果。</li>\n<li>起点的索引一定处于<code>[0,N-k]</code>的范围内，因此我们使用二分法，只要判断出起点与<code>x</code>的差不大于终点(起点+<code>k</code>)与<code>x</code>的差即可。</li>\n</ol>\n<p>代码：</p>\n<pre class=\"hljs\"><code>class Solution(object):\n    def findClosestElements(self, arr, k, x):\n        &quot;&quot;&quot;\n        :type arr: List[int]\n        :type k: int\n        :type x: int\n        :rtype: List[int]\n        &quot;&quot;&quot;\n        N=len(arr)\n        lo,hi=0,N-k\n        while lo&lt;hi:\n          mid=(lo+hi)//2\n          if x-arr[mid]&gt;arr[mid+k]-x:\n            lo=mid+1\n          else:\n            hi=mid\n        return arr[lo:lo+k]\n</code></pre>\n"
}
