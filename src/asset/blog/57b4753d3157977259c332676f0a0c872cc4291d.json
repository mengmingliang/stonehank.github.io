{
  "content": "<p>给出一个数组和一个<code>k</code>值，要求对数组进行处理，使得每个<code>index</code>的值为它和它之后<code>k</code>个数的和。</p>\n<p>很简单的一道题，最直接的思路就是对每一个<code>index</code>，再次循环k次，求和，时间是<code>O(k*n)</code></p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">var</span> k=<span class=\"hljs-number\">2</span>,nums=[<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">6</span>,<span class=\"hljs-number\">7</span>,<span class=\"hljs-number\">5</span>,<span class=\"hljs-number\">1</span>],sums=[]\n<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i=<span class=\"hljs-number\">0</span>;i&lt;nums.length-k+<span class=\"hljs-number\">1</span>;i++){\n  <span class=\"hljs-keyword\">let</span> sum=<span class=\"hljs-number\">0</span>\n  <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> j=i;j&lt;i+k;j++){\n   sum+=nums[j]\n  }\n  sums[i]=sum\n}\n</code></pre>\n<hr>\n<p>另一种使用<code>window slide</code>的方法，时间是<code>O(n)</code></p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">var</span> k=<span class=\"hljs-number\">2</span>,nums=[<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">6</span>,<span class=\"hljs-number\">7</span>,<span class=\"hljs-number\">5</span>,<span class=\"hljs-number\">1</span>],sums=[]\n<span class=\"hljs-keyword\">var</span> sum=<span class=\"hljs-number\">0</span>\n<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i=<span class=\"hljs-number\">0</span>;i&lt;nums.length;i++){\n  sum+=nums[i]\n  <span class=\"hljs-keyword\">if</span>(i&gt;k<span class=\"hljs-number\">-1</span>)sum-=nums[i-k]\n  <span class=\"hljs-keyword\">if</span>(i&gt;=k<span class=\"hljs-number\">-1</span>)sums[i-k+<span class=\"hljs-number\">1</span>]=sum  \n}\n</code></pre>\n<p>当k比较大的时候造成的性能差异显而易见，</p>\n"
}
