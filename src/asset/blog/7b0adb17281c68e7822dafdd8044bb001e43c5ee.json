{
  "content": "<h2>popstate</h2>\n<p>只在浏览器下前进后退和改变hash触发，<code>pushState</code>和<code>replaceState</code>并不会触发</p>\n<p>源码中给<code>popstate</code>和<code>navigate</code>事件绑定了一旦执行就更新当前location(传递到context中的)</p>\n<h2>替代pushState和replaceState</h2>\n<p>源码中对<code>pushState</code>和<code>replaceState</code>操作用<code>try...catch</code>包裹，因为有一个bug，<a href=\"https://forums.developer.apple.com/thread/36650\">iOS Safari limits to 100 pushState calls</a></p>\n<p>因此当出现catch，会执行<code>location.replace</code>或者<code>location.assign</code></p>\n<ul>\n<li><code>location.replace</code> 跳转url，替代当前，不增加历史记录</li>\n<li><code>location.assign</code> 跳转url，增加历史记录</li>\n</ul>\n<h2>createContext(defaultValue)</h2>\n<p>官方(英文)：</p>\n<blockquote>\n<p>If there is no Provider for this context above, the value argument will be equal to the defaultValue that was passed to createContext().</p>\n</blockquote>\n<p>中文文档：</p>\n<blockquote>\n<p>如果上层的组件树没有一个匹配的 Provider，而此时你需要渲染一个 Consumer 组件，那么你可以用到 defaultValue 。这有助于在不封装它们的情况下对组件进行测试。</p>\n</blockquote>\n<p>源码中这么用的</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">const</span> createNamedContext = <span class=\"hljs-function\">(<span class=\"hljs-params\">name, defaultValue</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">const</span> Ctx = createContext(defaultValue);\n  Ctx.Consumer.displayName = <span class=\"hljs-string\">`<span class=\"hljs-subst\">${name}</span>.Consumer`</span>;\n  Ctx.Provider.displayName = <span class=\"hljs-string\">`<span class=\"hljs-subst\">${name}</span>.Provider`</span>;\n  <span class=\"hljs-keyword\">return</span> Ctx;\n};\n\n<span class=\"hljs-keyword\">let</span> BaseContext = createNamedContext(<span class=\"hljs-string\">\"Base\"</span>, { <span class=\"hljs-attr\">baseuri</span>: <span class=\"hljs-string\">\"/\"</span>, <span class=\"hljs-attr\">basepath</span>: <span class=\"hljs-string\">\"/\"</span> });\n\n<span class=\"hljs-keyword\">let</span> Router = <span class=\"hljs-function\"><span class=\"hljs-params\">props</span> =&gt;</span> (\n  &lt;BaseContext.Consumer&gt;\n    {/* 此处baseContext是 { baseuri: \"/\", basepath: \"/\" } */}\n    {baseContext =&gt; (\n      &lt;Location&gt;\n        {locationContext =&gt; (\n          &lt;RouterImpl {...baseContext} {...locationContext} {...props} /&gt;\n        )}\n      &lt;/Location&gt;\n    )}\n  &lt;/BaseContext.Consumer&gt;\n</code></pre>\n<h2>工具介绍 invariant</h2>\n<p><code>invariant(boolean,something)</code> 参数1为false就<code>throw 参数2(something)</code></p>\n<h2>react中element.type</h2>\n<p>用来判断组件的类型</p>\n<p>例如：</p>\n<pre class=\"hljs\"><code><span class=\"hljs-comment\">// 1、高阶组件</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">HOC</span>(<span class=\"hljs-params\">com</span>)</span>{\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span></span>{\n    render(){\n      <span class=\"hljs-keyword\">return</span> &lt;com /&gt;\n    }\n  }\n}\n// 2、自定义组件\nclass MyComponent extends React.Component{\n    render(){\n        return &lt;div&gt;...&lt;/div&gt;\n    }\n}\n// 3、无状态组件\nfunction DumbComponent(props){\n    return &lt;button&gt;show&lt;/button&gt;\n}\n// 4、原生标签（直接写到children里）\n\n// 判断\nfunction checkType(element){\n    let type=element.type\n    if(type.prototype &amp;&amp; type.prototype.isReactComponent){\n        console.log('自定义React组件')\n    }else if(typeof type === 'function'){\n        console.log('是一个函数（高阶函数），继续调用')\n    }else if(typeof type === 'string'){\n        console.log('是一个原生标签')\n    }else{\n        console.log('其他')\n    }\n}\nclass Check extends React.Component{\n  render(){\n    React.Children.map(this.props.children,element=&gt;{\n      checkType(element)\n    })\n    return &lt;div /&gt;\n  }\n}\nReactDOM.render(\n  &lt;Check&gt;\n    &lt;HOC /&gt;      \n    &lt;MyComponent /&gt;\n    &lt;DumbComponent /&gt;\n    &lt;div /&gt;\n  &lt;/Check&gt;,\n  document.getElementById('container')\n);\n/*\n\"是一个函数（高阶函数），继续调用\"\n\"自定义React组件\"\n\"是一个函数（高阶函数），继续调用\"（此处无状态函数组件会被认为函数）\n\"是一个原生标签\"\n*/\n</code></pre>\n<p>源码中用来检测是否重定向组件：</p>\n<pre class=\"hljs\"><code><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">RouterImpl</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">PureComponent</span> </span>{\n    render(){\n        <span class=\"hljs-comment\">/* 其他代码 */</span>\n        <span class=\"hljs-keyword\">let</span> routes = React.Children.map(children, createRoute(basepath));\n        <span class=\"hljs-comment\">/* 其他代码 */</span>\n    }        \n}\n\n<span class=\"hljs-keyword\">let</span> createRoute = <span class=\"hljs-function\"><span class=\"hljs-params\">basepath</span> =&gt;</span> element =&gt; {\n    <span class=\"hljs-comment\">// element.type === Redirect 用于检测是否某个组件</span>\n    invariant(\n        element.props.path || element.props.default || element.type === Redirect,\n        <span class=\"hljs-string\">`&lt;Router&gt;: Children of &lt;Router&gt; must have a \\`path\\` or \\`default\\` prop, or be a \\`&lt;Redirect&gt;\\`. None found on element type \\`<span class=\"hljs-subst\">${\n         element.type\n        }</span>\\``</span>\n     );\n  <span class=\"hljs-comment\">/* 其他代码 */</span>\n}\n\n<span class=\"hljs-comment\">// 这里Redirect是个无状态组件  </span>\n<span class=\"hljs-keyword\">let</span> Redirect = <span class=\"hljs-function\"><span class=\"hljs-params\">props</span> =&gt;</span> (\n  &lt;Location&gt;\n    {locationContext =&gt; &lt;RedirectImpl {...locationContext} {...props} /&gt;}\n  &lt;/Location&gt;\n);\n</code></pre>\n"
}
