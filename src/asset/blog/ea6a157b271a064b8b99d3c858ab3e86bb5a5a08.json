{
  "content": "<p>给定一个由整数数组 A 表示的环形数组 C，求 C 的非空子数组的最大可能和。</p>\n<p>在此处，环形数组意味着数组的末端将会与开头相连呈环状。（形式上，当0 &lt;= i &lt; A.length 时 C[i] = A[i]，而当 i &gt;= 0 时 C[i+A.length] = C[i]）</p>\n<p>此外，子数组最多只能包含固定缓冲区 A 中的每个元素一次。（形式上，对于子数组 C[i], C[i+1], ..., C[j]，不存在 i &lt;= k1, k2 &lt;= j 其中 k1 % A.length = k2 % A.length）</p>\n<pre class=\"hljs\"><code>示例 1：\n\n输入：[1,-2,3,-2]\n输出：3\n解释：从子数组 [3] 得到最大和 3\n示例 2：\n\n输入：[5,-3,5]\n输出：10\n解释：从子数组 [5,5] 得到最大和 5 + 5 = 10\n示例 3：\n\n输入：[3,-1,2,-1]\n输出：4\n解释：从子数组 [2,-1,3] 得到最大和 2 + (-1) + 3 = 4\n示例 4：\n\n输入：[3,-2,2,-3]\n输出：3\n解释：从子数组 [3] 和 [3,-2,2] 都可以得到最大和 3\n示例 5：\n\n输入：[-2,-3,-1]\n输出：-1\n解释：从子数组 [-1] 得到最大和 -1\n</code></pre>\n<p>提示：</p>\n<p>-30000 &lt;= A[i] &lt;= 30000\n1 &lt;= A.length &lt;= 30000</p>\n<hr>\n<p>思路：</p>\n<p>这道题有几种思路。</p>\n<p>思路一：(和<code>862.和至少为K的子数组</code>很相似)</p>\n<ol>\n<li>因为是环形数组，我们创建一个数组<code>P</code>，它的长度为<code>2*N</code>，并且<code>P[i]</code>表示从<code>0-i</code>的和。</li>\n<li>定义一个<code>stack</code>，里面维护了能作为开头的子数组的索引。</li>\n<li>遍历P，我们要执行以下2点条件：\n<ol>\n<li>当长度超过<code>N</code>时，删除<code>stack</code>头部的索引。</li>\n<li>当<code>P[j]&lt;=P[stack[stack.length-1]]</code>时，说明当前<code>j</code>所在的位置是0或者负数，不能作为子数组的开头。</li>\n</ol>\n</li>\n</ol>\n<p>代码：</p>\n<pre class=\"hljs\"><code><span class=\"hljs-comment\">/**\n * @param {number[]} A\n * @return {number}\n */</span>\n<span class=\"hljs-keyword\">var</span> maxSubarraySumCircular = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">A</span>) </span>{\n  <span class=\"hljs-keyword\">let</span> N = A.length;\n  <span class=\"hljs-keyword\">let</span> P = <span class=\"hljs-built_in\">Array</span>(<span class=\"hljs-number\">2</span>*N+<span class=\"hljs-number\">1</span>).fill(<span class=\"hljs-number\">0</span>)\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">2</span>*N; ++i){\n    P[i+<span class=\"hljs-number\">1</span>] = P[i] + A[i % N]\n  }\n  <span class=\"hljs-keyword\">let</span> ans = A[<span class=\"hljs-number\">0</span>];\n  <span class=\"hljs-keyword\">let</span> stack = [<span class=\"hljs-number\">0</span>]\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> j = <span class=\"hljs-number\">1</span>; j &lt;= <span class=\"hljs-number\">2</span>*N; ++j) {\n    <span class=\"hljs-keyword\">if</span> (stack[<span class=\"hljs-number\">0</span>] &lt; j-N)stack.shift()\n    ans = <span class=\"hljs-built_in\">Math</span>.max(ans, P[j] - P[stack[<span class=\"hljs-number\">0</span>]]);\n    <span class=\"hljs-keyword\">while</span> (stack.length&gt;<span class=\"hljs-number\">0</span> &amp;&amp; P[j] &lt;= P[stack[stack.length<span class=\"hljs-number\">-1</span>]]){\n      stack.pop()\n    }\n    stack.push(j)\n  }\n  <span class=\"hljs-keyword\">return</span> ans;\n};\n</code></pre>\n<p>思路二：</p>\n<p>如果不是环形数组，我们可以使用<code>Kadane</code>算法计算出子数组的最大和。</p>\n<p>那么环形数组比非环形数组多了一种情况，那就是<code>部分尾巴+部分头部</code>为最大和的子数组，这种情况我们只需要考虑，和最小的子数组，\n也就是中间那一部分。</p>\n<p>因此我们只需比较<code>最大和的子数组</code>和<code>数组总和-最小和的子数组</code>。</p>\n<p>代码：</p>\n<pre class=\"hljs\"><code><span class=\"hljs-comment\">/**\n * @param {number[]} A\n * @return {number}\n */</span>\n<span class=\"hljs-keyword\">var</span> maxSubarraySumCircular = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">A</span>) </span>{\n  <span class=\"hljs-keyword\">let</span> total = <span class=\"hljs-number\">0</span>, \n      maxSum = -<span class=\"hljs-literal\">Infinity</span>, curMax = <span class=\"hljs-number\">0</span>, \n      minSum = <span class=\"hljs-literal\">Infinity</span>, curMin = <span class=\"hljs-number\">0</span>,\n      maxSingle=-<span class=\"hljs-literal\">Infinity</span>\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> a <span class=\"hljs-keyword\">of</span> A) {\n    total += a;\n    maxSingle=<span class=\"hljs-built_in\">Math</span>.max(maxSingle,a)\n    \n    <span class=\"hljs-keyword\">if</span>(curMax+a&gt;<span class=\"hljs-number\">0</span>){\n      curMax+=a\n      maxSum=<span class=\"hljs-built_in\">Math</span>.max(curMax,maxSum)\n    }<span class=\"hljs-keyword\">else</span> curMax=<span class=\"hljs-number\">0</span>\n\n    <span class=\"hljs-keyword\">if</span>(curMin+a&lt;<span class=\"hljs-number\">0</span>){\n      curMin+=a\n      minSum=<span class=\"hljs-built_in\">Math</span>.min(curMin,minSum)\n    }<span class=\"hljs-keyword\">else</span> curMin=<span class=\"hljs-number\">0</span>   \n  }\n  <span class=\"hljs-keyword\">return</span> maxSum &gt; <span class=\"hljs-number\">0</span> ? <span class=\"hljs-built_in\">Math</span>.max(maxSum, total - minSum) : maxSingle;\n};\n</code></pre>\n"
}
