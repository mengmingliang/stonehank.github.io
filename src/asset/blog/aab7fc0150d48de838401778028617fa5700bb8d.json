{
  "content": "<p>给定一个数组<code>A</code>和一个<code>K</code>，算出和至少为<code>K</code>的子数组。</p>\n<p>刚开始处理这个问题，我使用的是处理和为<code>K</code>的子数组的方法，再通过一个<code>window slide</code>不断处理内部的值，当其大于等于<code>K</code>的时候，\n记录一下<code>slide</code>的长度。</p>\n<p>但这个方法的问题就是一旦需要的子数组在<code>slide</code>中间，则无法获取</p>\n<p>例如：</p>\n<pre class=\"hljs\"><code>A=[-34,37,51,3,-12,-50,51,100,-47,99,34]\nK=151\n</code></pre>\n<p>用上面的办法结果是<code>4</code>，会卡在<code>[51,100,-47,99]</code>这样的子数组中，接着是<code>[100,-47,99]</code>，无法算出<code>51,100</code>这个子数组。</p>\n<p>正确应该是<code>2</code>。</p>\n<p>正确思路：</p>\n<ol>\n<li>第一步相同，需要算出当前数与之前的和的数组。</li>\n<li>定义一个数组<code>d</code>，存放可以作为子数组开始的点。</li>\n<li><code>d</code>中的值遇到以下2种情况，可以删除。\n<ol>\n<li>遇到某个点<code>i</code>与<code>d[0]</code>之间的和已经<code>&gt;=K</code>了，说明<code>d[0]</code>这个点是有效的，需要记录长度，并且删除(尝试右移)。</li>\n<li>遇到某个点<code>i</code>加上它后，当前和比<code>d[d.length-1]</code>这个点的和更小或者相等，说明这个<code>i</code>是负值或者0，\n说明这个<code>d[d.length-1]</code>点是无效的，是不能做为子数组开始的点，需要删除。</li>\n</ol>\n</li>\n</ol>\n<p>代码：</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">var</span> shortestSubarray = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">A, K</span>) </span>{\n  <span class=\"hljs-keyword\">let</span> N = A.length\n  <span class=\"hljs-keyword\">let</span> sum = <span class=\"hljs-built_in\">Array</span>(N+<span class=\"hljs-number\">1</span>).fill(<span class=\"hljs-number\">0</span>)\n  <span class=\"hljs-comment\">// 算和</span>\n  <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i=<span class=\"hljs-number\">0</span>;i&lt;N;i++){\n    sum[i+<span class=\"hljs-number\">1</span>]=sum[i]+A[i]\n  }\n  <span class=\"hljs-comment\">// d存放从哪个点开始计算和</span>\n  <span class=\"hljs-keyword\">let</span> d=[]\n  <span class=\"hljs-keyword\">let</span> res=N+<span class=\"hljs-number\">1</span>\n  <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i=<span class=\"hljs-number\">0</span>;i&lt;N+<span class=\"hljs-number\">1</span>;i++){\n    <span class=\"hljs-comment\">// 如果当前点(i)的和 &gt;= d的第一个点的和</span>\n    <span class=\"hljs-comment\">// 说明在d[0]和i之间这一段数字的和 &gt;= K</span>\n    <span class=\"hljs-comment\">// 需要算出这一段距离，并且可以删除d的第一个点</span>\n    <span class=\"hljs-comment\">// 循环检查</span>\n    <span class=\"hljs-keyword\">while</span>(d.length&gt;<span class=\"hljs-number\">0</span> &amp;&amp; sum[i]-sum[d[<span class=\"hljs-number\">0</span>]]&gt;=K){\n      res=<span class=\"hljs-built_in\">Math</span>.min(res,i-d.shift())\n    }\n    <span class=\"hljs-comment\">// 如果当前点(i) &lt;= d的最后一个点(有可能是上一个点)</span>\n    <span class=\"hljs-comment\">// 那么说明，当前点是一个0或者负值，是绝对不能做为开始点去算和的</span>\n    <span class=\"hljs-comment\">// 因此当前点需要pop掉</span>\n    <span class=\"hljs-comment\">// 循环检查</span>\n    <span class=\"hljs-keyword\">while</span>(d.length&gt;<span class=\"hljs-number\">0</span> &amp;&amp; sum[i]&lt;=sum[d[d.length<span class=\"hljs-number\">-1</span>]]){\n      d.pop()\n    }\n    <span class=\"hljs-comment\">// 每一个点都先放入d，后续会检查这些点是否能作为计算和的开始点</span>\n    d.push(i)\n  }\n  <span class=\"hljs-keyword\">return</span> res&lt;=N ? res : <span class=\"hljs-number\">-1</span>\n};\n</code></pre>\n"
}
