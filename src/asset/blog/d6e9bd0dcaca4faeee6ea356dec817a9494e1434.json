{
  "content": "<p>给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p>\n<p>此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p>\n<p>注意:\n不能使用代码库中的排序函数来解决这道题。</p>\n<pre class=\"hljs\"><code>示例:\n输入: [2,0,2,1,1,0]\n输出: [0,0,1,1,2,2]\n</code></pre>\n<p>进阶：</p>\n<ul>\n<li>\n<p>一个直观的解决方案是使用计数排序的两趟扫描算法。</p>\n<p>首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。</p>\n</li>\n<li>\n<p>你能想出一个仅使用常数空间的一趟扫描算法吗</p>\n</li>\n</ul>\n<hr>\n<p>思路：直接来看一趟扫描法，要使用一趟扫描法，每个数字遍历的同时，就要将它放到正确的位置。</p>\n<p>可以将数组划分为3块，用3个指针表示他们的边界，<code>lo</code>表示0，<code>hi</code>表示2，<code>c</code>表示扫描的指针。</p>\n<p>例如：<code>001122</code>，这里<code>lo</code>为2,表示<code>索引0~1</code>一定都是0，<code>hi</code>为3，表示<code>索引4~5</code>一定为2.</p>\n<p>因此每当<code>nums[c]</code>对应的一个数字，便和那个数字对应的指针进行交换，并且指针需要前进一步。</p>\n<p>(代码见最后)</p>\n<p>这种方法稍加改变，同样也可以处理大量不同的重复值的排序，例如<code>[1,1,2,2,3,3,4,4,4,4]</code>这种，比起一般的排序方法效率高出不少。</p>\n<p>quick3way排序：</p>\n<pre class=\"hljs\"><code><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">quick3way</span>(<span class=\"hljs-params\">arr</span>)</span>{\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">sort</span>(<span class=\"hljs-params\">arr,lo,hi</span>)</span>{\n    <span class=\"hljs-keyword\">if</span>(arr.length&gt;<span class=\"hljs-number\">1</span>){\n      <span class=\"hljs-keyword\">if</span>(hi&lt;=lo)<span class=\"hljs-keyword\">return</span>\n      <span class=\"hljs-keyword\">let</span> start=lo,cur=lo,end=hi;\n      <span class=\"hljs-keyword\">let</span> pivot=arr[lo]\n      <span class=\"hljs-keyword\">while</span>(cur&lt;=end){\n        <span class=\"hljs-keyword\">if</span>(arr[cur]&lt;pivot)swap(arr,cur++,start++)\n        <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(arr[cur]&gt;pivot)swap(arr,cur,end--)\n        <span class=\"hljs-keyword\">else</span> cur++\n      }\n      sort(arr,lo,start<span class=\"hljs-number\">-1</span>)\n      sort(arr,cur,hi)\n    }\n  }\n  sort(arr,<span class=\"hljs-number\">0</span>,arr.length<span class=\"hljs-number\">-1</span>)\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">swap</span>(<span class=\"hljs-params\">a, i, j</span>) </span>{\n  <span class=\"hljs-keyword\">let</span> t = a[i];\n  a[i] = a[j];\n  a[j] = t;\n};\n</code></pre>\n<hr>\n<p>代码：</p>\n<pre class=\"hljs\"><code><span class=\"hljs-comment\">/**\n * @param {number[]} nums\n * @return {void} Do not return anything, modify nums in-place instead.\n */</span>\n<span class=\"hljs-keyword\">var</span> sortColors = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">nums</span>) </span>{\n  <span class=\"hljs-keyword\">let</span> lo=<span class=\"hljs-number\">0</span>,hi=nums.length<span class=\"hljs-number\">-1</span>,c=<span class=\"hljs-number\">0</span>\n  <span class=\"hljs-keyword\">let</span> p=<span class=\"hljs-number\">1</span>\n  <span class=\"hljs-keyword\">while</span>(c&lt;=hi){\n    <span class=\"hljs-keyword\">if</span>(nums[c]&lt;p)swap(nums,lo++,c++)\n    <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(nums[c]&gt;p)swap(nums,c,hi--)\n    <span class=\"hljs-keyword\">else</span> c++\n  }\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">swap</span>(<span class=\"hljs-params\">a,i,j</span>)</span>{\n    <span class=\"hljs-keyword\">let</span> t=a[i]\n    a[i]=a[j]\n    a[j]=t\n  }\n};\n</code></pre>\n"
}
