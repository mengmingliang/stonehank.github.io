{
  "content": "<p>给定一个无序的整数数组，找到其中最长上升子序列的长度。</p>\n<p>示例:</p>\n<pre class=\"hljs\"><code>输入: [10,9,2,5,3,7,101,18]\n输出: 4 \n解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。\n</code></pre>\n<p>这道题用<code>DP</code>解就是<code>O(n^2)</code>时间复杂度。</p>\n<p>思路：\n创建一个<code>dp数组</code>，用来储存每个<code>index</code>及它之前的最长子序列，<code>dp[j]</code>会去检查前面的每一个<code>dp[i]</code>，如果<code>nums[i]&lt;nums[j]</code>，\n那么<code>dp[j]=Math.max(dp[j],dp[i]+1)</code>。</p>\n<p>代码：</p>\n<pre class=\"hljs\"><code>class Solution(object):\n    def lengthOfLIS(self, nums):\n        &quot;&quot;&quot;\n        :type nums: List[int]\n        :rtype: int\n        &quot;&quot;&quot;\n        maxLen=0\n        n=len(nums)\n        dp=[1]*n\n        for i in range(n):\n          cur=nums[i]\n          for j in range(0,i):\n            if nums[j]&lt;cur:\n              dp[i]=max(dp[i],dp[j]+1)\n          maxLen=max(dp[i],maxLen)\n        return maxLen\n</code></pre>\n<p>另外一个<code>O(nlgn)</code>的方法不太容易想到，需要搭建一个<code>单调递增数组</code>。</p>\n<p>思路：\n维护一个数组<code>stack</code>，当<code>stack[-1]</code>比当前<code>nums[i]</code>小的时候，直接<code>append</code>，如果更大，需要二分搜索到<code>nums[i]</code>应该存在的位置，\n并且替换，最终<code>stack</code>的长度就是最长结果。</p>\n<p>例如<code>[1,3,6,7,9,4,10,5,6]</code></p>\n<p>当<code>nums[i]</code>为<code>4</code>时，<code>stack</code>为<code>[1,3,6,7,9]</code>\n当<code>nums[i]</code>为<code>10</code>时，<code>stack</code>为<code>[1,3,4,7,9]</code></p>\n<p>代码：</p>\n<pre class=\"hljs\"><code>class Solution(object):\n    def lengthOfLIS(self, nums):\n        &quot;&quot;&quot;\n        :type nums: List[int]\n        :rtype: int\n        &quot;&quot;&quot;\n        stack=[]\n        for num in nums:\n          if not stack or stack[-1]&lt;num:\n            stack.append(num)\n          elif stack[-1]&gt;num:\n            lo,hi=0,len(stack)-1\n            while lo&lt;hi:\n              mid=(lo+hi)//2\n              if stack[mid]&lt;num:\n                lo=mid+1\n              else:\n                hi=mid\n            stack[lo]=num\n        return len(stack)\n</code></pre>\n"
}
