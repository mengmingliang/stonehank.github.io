{
  "content": "<p>给定长度为 n 的整数数组 nums，其中 n &gt; 1，返回输出数组 output ，其中 output[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。</p>\n<pre class=\"hljs\"><code>示例:\n\n输入: [1,2,3,4]\n输出: [24,12,8,6]\n说明: 请不要使用除法，且在 O(n) 时间复杂度内完成此题。\n</code></pre>\n<p>进阶：\n你可以在常数空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组不被视为额外空间。）</p>\n<hr>\n<p>思路：</p>\n<ol>\n<li>\n<p>题目要求不能使用除法，最直接的想法是对每一项，除了它本身，其他重新乘一遍，但时间复杂度达不到要求。</p>\n</li>\n<li>\n<p>仔细观察一下，除了本身的乘积，其实就是<code>左侧乘积</code>和<code>右侧乘积</code>的乘积。</p>\n</li>\n<li>\n<p>我们只需要分别求出左侧乘积和右侧乘积即可。</p>\n</li>\n</ol>\n<p>例如：</p>\n<p><code>index[3]</code>，它的左侧乘积是<code>product[0,1,2]</code>，右侧乘积是<code>produce[4,5...]</code></p>\n<p><code>index[4]</code>，它的左侧乘积是<code>product[0,1,2,3]</code>，右侧乘积是<code>product[5...]</code></p>\n<p>通过上例比较清楚的看到，<code>leftProduct[i]=leftProduct[i-1]*nums[i]</code>，</p>\n<p>右侧同理，逆序遍历即与左侧一模一样。</p>\n<hr>\n<p>代码：</p>\n<pre class=\"hljs\"><code><span class=\"hljs-comment\">/**\n* @param {number[]} nums\n* @return {number[]}\n*/</span>\n<span class=\"hljs-keyword\">var</span> productExceptSelf = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">nums</span>) </span>{\n <span class=\"hljs-keyword\">let</span> res=[]\n <span class=\"hljs-keyword\">let</span> l=<span class=\"hljs-number\">1</span>,r=<span class=\"hljs-number\">1</span>\n <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i=<span class=\"hljs-number\">0</span>;i&lt;nums.length;i++){\n   res[i]=l\n   l*=nums[i]\n }\n <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i=nums.length<span class=\"hljs-number\">-1</span>;i&gt;=<span class=\"hljs-number\">0</span>;i--){\n   res[i]*=r\n   r*=nums[i]\n }\n <span class=\"hljs-keyword\">return</span> res\n};\n</code></pre>\n"
}
