{
  "content": "<h2>阅读<a href=\"https://github.com/chenglou/react-motion\">react-motion</a>的源码时候，其中有一个组件<code>TransitionMotion</code>\n，它负责元素的新增和移除动画，内部有2个概念：<code>old</code>和<code>new</code></h2>\n<p>这就先说到排序，</p>\n<p>当动画队列出现如下状态时，该如何处理：</p>\n<p>旧的序列： <code>a -&gt; b -&gt; x</code></p>\n<p>新的序列： <code>c -&gt; b -&gt; d</code></p>\n<p>这里涉及到<code>拓扑排序</code>的思想</p>\n<ol>\n<li>\n<p><code>a</code>和<code>c</code>的入口点为0，因此 <code>a</code>和<code>c</code> 在<code>b</code>的前面执行，</p>\n</li>\n<li>\n<p>执行完<code>a</code>和<code>c</code>后，<code>b</code>的入口点为0，因此<code>b</code>在 <code>x</code>和<code>d</code>的前面执行，</p>\n</li>\n<li>\n<p>那么<code>a</code>和<code>c</code>的顺序，<code>x</code>和<code>d</code>的顺序怎么判断</p>\n</li>\n</ol>\n<p>实际操作是使用原生<code>sort</code>方法，<code>sort</code>对比参数分4种情况：</p>\n<ol>\n<li>两者都在旧序列，那么就按旧的排序</li>\n<li>两者都在新序列，那么就按新的排序</li>\n<li>x在旧，y在新，那么找x和y的中间值，例如<code>a</code>和<code>d</code>的中间值就是<code>b</code>，然后根据中间值排序</li>\n<li>x在旧，y在新，无中间值，那么按照旧序列优先，即<code>a-&gt;c</code>，<code>x-&gt;d</code></li>\n</ol>\n<hr>\n<p>通过排序也定义了内部的new和old的区别：</p>\n<pre class=\"hljs\"><code>* old代表未排序的动画列表或者数据\n例如：oldMergedPropsStyles就是未排序的mergedPropsStyles\noldMergedPropsStyles\noldCurrentStyles\noldCurrentVelocities\noldLastIdealStyles\noldLastIdealVelocities\n----------------------------\n* new代表已经排序的动画列表或者数据\n例如：newMergedPropsStyles就是已经排好序的mergedPropsStyles\nnewMergedPropsStyles, \nnewCurrentStyles, \nnewCurrentVelocities, \nnewLastIdealStyles, \nnewLastIdealVelocities\n</code></pre>\n<p>更详细查看[react-motion源码阅读]</p>\n"
}
