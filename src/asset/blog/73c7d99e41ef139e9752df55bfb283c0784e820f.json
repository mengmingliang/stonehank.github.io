{
  "content": "<p>数组 A 是 [0, 1, ..., N - 1] 的一种排列，N 是数组 A 的长度。全局倒置指的是 i,j 满足 0 &lt;= i &lt; j &lt; N 并且 A[i] &gt; A[j] ，局部倒置指的是 i 满足 0 &lt;= i &lt; N 并且 A[i] &gt; A[i+1] 。</p>\n<p>当数组 A 中全局倒置的数量等于局部倒置的数量时，返回 true 。</p>\n<pre class=\"hljs\"><code>示例 1:\n输入: A = [1,0,2]\n输出: true\n解释: 有 1 个全局倒置，和 1 个局部倒置。\n\n示例 2:\n输入: A = [1,2,0]\n输出: false\n解释: 有 2 个全局倒置，和 1 个局部倒置。\n</code></pre>\n<p>注意:</p>\n<ul>\n<li>A 是 <code>[0, 1, ..., A.length - 1]</code> 的一种排列</li>\n<li>A 的长度在<code>[1, 5000]</code>之间</li>\n<li>这个问题的时间限制已经减少了。</li>\n</ul>\n<hr>\n<p>思路：</p>\n<ol>\n<li>\n<p>最初看到问题的想法是将全局倒置数量和局部倒置数量都计算出来，最后对比，但是<code>TLE</code>了，这么做时间复杂度是<code>O(N^2)</code>。</p>\n</li>\n<li>\n<p>其实仔细一思考，一旦发现存在全局倒置，就可以立刻返回<code>false</code>了，因此有局部倒置必然有全局倒置，而有全局倒置不一定有局部倒置。</p>\n</li>\n<li>\n<p>遍历的时候将遍历过的最大值保存，一旦发现当前值小于这个最大值，说明存在额外的全局倒置，最终时间复杂度是<code>O(N)</code></p>\n</li>\n</ol>\n<hr>\n<p>代码：</p>\n<pre class=\"hljs\"><code><span class=\"hljs-comment\">/**\n * @param {number[]} A\n * @return {boolean}\n */</span>\n<span class=\"hljs-keyword\">var</span> isIdealPermutation = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">A</span>) </span>{\n  <span class=\"hljs-keyword\">let</span> max=-<span class=\"hljs-literal\">Infinity</span>\n  <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i=<span class=\"hljs-number\">1</span>;i&lt;A.length;i++){\n    <span class=\"hljs-keyword\">if</span>(A[i]&lt;max)<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>\n    max=<span class=\"hljs-built_in\">Math</span>.max(max,A[i<span class=\"hljs-number\">-1</span>])\n  }\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>\n};\n</code></pre>\n"
}
