{
  "content": "<p>核心思想：使用<code>优先队列</code>，每次找<strong>最容易漏水</strong>的位置，</p>\n<hr>\n<h4>线的雨水收集算法</h4>\n<p><img src=\"https://stonehank.github.io/articles/img/rainwatertrap.png\" alt=\"\"></p>\n<p>Example:</p>\n<pre class=\"hljs\"><code>Input: [0,1,0,2,1,0,1,3,2,1,2,1]\nOutput: 6\n</code></pre>\n<p>线的雨水收集可以不用<code>优先队列</code>，因为只需要比较当前两端的位置即可。</p>\n<p>思路：</p>\n<ol>\n<li>比较两端，如果<code>a&lt;b</code>(如果<code>b&lt;a</code>，下面则从<code>b</code>开始)</li>\n<li>从<code>a</code>开始继续遍历\n<ul>\n<li>发现有比它高的墙<code>x</code>，说明这个<code>a</code>点的漏水被堵住了，将这个墙<code>x</code>继续更另一端的值对比<code>x ? b</code></li>\n<li>发现有比它矮的凹口<code>y</code>，说明这个凹口<code>y</code>最多水位能升到<code>a</code>的位置，记录<code>a.height-y.height</code>，继续往下检测</li>\n<li>发现和它一样高的，同上</li>\n</ul>\n</li>\n<li>继续两端对比，递归1</li>\n</ol>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">var</span> trap = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">height</span>) </span>{\n  <span class=\"hljs-keyword\">let</span> leftIdx=<span class=\"hljs-number\">0</span>,rightIdx=height.length<span class=\"hljs-number\">-1</span>\n  <span class=\"hljs-keyword\">let</span> result=<span class=\"hljs-number\">0</span>\n  <span class=\"hljs-keyword\">while</span>(leftIdx&lt;rightIdx){\n    <span class=\"hljs-keyword\">let</span> leftV=height[leftIdx],rightV=height[rightIdx]\n    <span class=\"hljs-keyword\">if</span>(leftV&lt;rightV){\n      <span class=\"hljs-comment\">// 左边遍历执行思路2</span>\n      <span class=\"hljs-keyword\">while</span>(leftIdx&lt;rightIdx &amp;&amp; height[++leftIdx]&lt;=leftV){\n        result+=leftV-height[leftIdx]\n      }\n      leftV=height[leftIdx]\n    }<span class=\"hljs-keyword\">else</span>{\n      <span class=\"hljs-comment\">// 右边遍历执行思路2</span>\n      <span class=\"hljs-keyword\">while</span>(leftIdx&lt;rightIdx &amp;&amp; height[--rightIdx]&lt;=rightV){\n        result+=rightV-height[rightIdx]\n      }\n      rightV=height[rightIdx]      \n    }\n  }\n  <span class=\"hljs-keyword\">return</span> result\n};\n</code></pre>\n<hr>\n<h4>面的雨水收集算法</h4>\n<p>Example:</p>\n<pre class=\"hljs\"><code>Given the following 3x6 height map:\n[\n  [1,4,3,1,3,2],\n  [3,2,1,3,2,4],\n  [2,3,3,2,3,1]\n]\n\nReturn 4.\n</code></pre>\n<p>接水之前：</p>\n<p><img src=\"https://stonehank.github.io/articles/img/rainwater_empty.png\" alt=\"\"></p>\n<p>接水之后：\n<img src=\"https://stonehank.github.io/articles/img/rainwater_fill.png\" alt=\"\"></p>\n<p>面的问题因为涉及4个方向的边，建议使用<code>优先队列</code>，每次取出边上的最小值处理(最容易漏水的位置)。</p>\n<p>思路：</p>\n<ol>\n<li>\n<p>将4条最外边的值加入<code>优先队列</code>，建立一个<code>visited</code>，表示已经探索过的区域，不重复执行</p>\n</li>\n<li>\n<p>取出最小值<code>a</code>，从<code>a</code>开始遍历，不过要遍历4个方向，<code>visited</code>为true的跳过，同时设置一个<code>max</code>，\n用于保存当前最矮的墙中最高的...(因为使用<code>优先队列</code>每次取出最小值)</p>\n</li>\n<li>\n<p>遇到比<code>max</code>高的墙，则加入到<code>优先队列</code>中，因为这个墙已经可以作为一个新的边，</p>\n<p>遇到不比<code>max</code>高的平面或者凹口，记录增加的水位<code>max - 当前凹口的高度</code>，继续遍历直到遇到比<code>a</code>高的。</p>\n</li>\n<li>\n<p>直到<code>优先队列</code>的数据全部处理完</p>\n</li>\n</ol>\n<p>思路视频，非常<code>easy</code></p>\n<p><a href=\"https://www.youtube.com/watch?v=cJayBq38VYw\">Visualization of priority queue algorithm.</a></p>\n<pre class=\"hljs\"><code><span class=\"hljs-comment\">/**\n * @param {number[][]} heightMap\n * @return {number}\n */</span>\n<span class=\"hljs-keyword\">var</span> trapRainWater = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">heightMap</span>) </span>{\n\n  <span class=\"hljs-keyword\">let</span> pq=<span class=\"hljs-keyword\">new</span> PriorityQueueMin()\n  <span class=\"hljs-keyword\">let</span> visited=[]\n  <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i=<span class=\"hljs-number\">0</span>;i&lt;heightMap.length;i++){\n    visited[i]=[]\n    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> j=<span class=\"hljs-number\">0</span>;j&lt;heightMap[<span class=\"hljs-number\">0</span>].length;j++){\n      <span class=\"hljs-keyword\">if</span>((i&gt;<span class=\"hljs-number\">0</span> &amp;&amp; i&lt;heightMap.length<span class=\"hljs-number\">-1</span>) &amp;&amp; (j&gt;<span class=\"hljs-number\">0</span> &amp;&amp; j&lt;heightMap[<span class=\"hljs-number\">0</span>].length<span class=\"hljs-number\">-1</span>))<span class=\"hljs-keyword\">continue</span>\n      <span class=\"hljs-comment\">// 添加入优先队列的是一个数组，内部根据 heightMap[i][j] 比较</span>\n      pq.insert([i,j,heightMap[i][j]])\n      visited[i][j]=<span class=\"hljs-literal\">true</span>\n    }\n  }\n  <span class=\"hljs-keyword\">let</span> max=-<span class=\"hljs-literal\">Infinity</span>,count=<span class=\"hljs-number\">0</span>\n  <span class=\"hljs-keyword\">while</span>(!pq.isEmpty()){\n    <span class=\"hljs-keyword\">let</span> cur=pq.delMin()\n    <span class=\"hljs-comment\">// 现在最矮的边(墙)已经比之前最矮的边(墙)要高</span>\n    <span class=\"hljs-keyword\">if</span>(cur[<span class=\"hljs-number\">2</span>]&gt;max)max=cur[<span class=\"hljs-number\">2</span>]\n    check(cur[<span class=\"hljs-number\">0</span>],cur[<span class=\"hljs-number\">1</span>])\n  }\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">check</span>(<span class=\"hljs-params\">row,col</span>)</span>{\n    <span class=\"hljs-keyword\">let</span> step=[[<span class=\"hljs-number\">-1</span>,<span class=\"hljs-number\">0</span>],[<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">0</span>],[<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">-1</span>],[<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">1</span>]]\n    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i=<span class=\"hljs-number\">0</span>;i&lt;step.length;i++){\n      <span class=\"hljs-keyword\">let</span> newR=row+step[i][<span class=\"hljs-number\">0</span>],newC=col+step[i][<span class=\"hljs-number\">1</span>]\n      <span class=\"hljs-keyword\">if</span>((newR&lt;<span class=\"hljs-number\">0</span> || newR&gt;=heightMap.length) || (newC&lt;<span class=\"hljs-number\">0</span> || newC&gt;=heightMap[<span class=\"hljs-number\">0</span>].length))<span class=\"hljs-keyword\">continue</span>\n      <span class=\"hljs-keyword\">if</span>(visited[newR][newC])<span class=\"hljs-keyword\">continue</span>\n      visited[newR][newC]=<span class=\"hljs-literal\">true</span>\n      <span class=\"hljs-keyword\">let</span> newVal=heightMap[newR][newC]\n      <span class=\"hljs-keyword\">if</span>(newVal&lt;max){\n        <span class=\"hljs-comment\">// 发现凹口，记录增加的水位，继续遍历</span>\n        count+=max-newVal\n        check(newR,newC)\n      }<span class=\"hljs-keyword\">else</span>{\n        <span class=\"hljs-comment\">// 遇到更高的墙，添加到优先队列</span>\n        pq.insert([newR,newC,newVal])\n      }\n    }\n  }\n\n  <span class=\"hljs-comment\">// 优先队列</span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">PriorityQueueMin</span>(<span class=\"hljs-params\"></span>)</span>{\n    <span class=\"hljs-comment\">/* ... */</span>\n  }\n  <span class=\"hljs-keyword\">return</span> count\n};\n</code></pre>\n"
}
