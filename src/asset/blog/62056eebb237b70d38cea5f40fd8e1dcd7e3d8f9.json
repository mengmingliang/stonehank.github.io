{
  "content": "<p>给出一个无重叠的 ，按照区间起始端点排序的区间列表。</p>\n<p>在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。</p>\n<pre class=\"hljs\"><code>示例 1:\n输入: intervals = [[1,3],[6,9]], newInterval = [2,5]\n输出: [[1,5],[6,9]]\n\n示例 2:\n输入: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]\n输出: [[1,2],[3,10],[12,16]]\n解释: 这是因为新的区间 [4,8] 与 [3,5],[6,7],[8,10] 重叠。\n</code></pre>\n<hr>\n<p>思路：\n一种最简单的想法就是，先添加<code>newIntervals</code>，然后重新按照起始端点排序，最后再处理重叠区间，就相当于<code>Leetcode 56</code>一模一样。</p>\n<p>时间复杂度是<code>O(nlgn)</code>。</p>\n<p>另外是时间复杂度<code>O(n)</code>的方法。</p>\n<p>思路比较简洁的是重新构建区间，</p>\n<p>检查每一段区间，如果<code>当前区间.end &lt; 新区间.start</code>，那么当前区间肯定是在新区间前面且不重叠的，直接添加当前区间进结果就好。</p>\n<p>如果<code>当前区间.start &gt; 新区间.end</code>，那么当前区间肯定是在新区间后面且不重叠的，并且说明新区间已经处理完毕，直接添加新区间到结果。</p>\n<p>其他情况，说明存在重叠区域，更新新区间的开始点和结束点。</p>\n<hr>\n<p>代码：<code>O(nlgn)</code>：</p>\n<pre class=\"hljs\"><code><span class=\"hljs-comment\">/**\n * Definition for an interval.\n * function Interval(start, end) {\n *     this.start = start;\n *     this.end = end;\n * }\n */</span>\n<span class=\"hljs-keyword\">var</span> insert = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">intervals, newInterval</span>) </span>{\n  intervals.push(newInterval)\n  intervals.sort(<span class=\"hljs-function\">(<span class=\"hljs-params\">a,b</span>)=&gt;</span>a.start-b.start)\n  <span class=\"hljs-keyword\">let</span> res=[intervals[<span class=\"hljs-number\">0</span>]]\n  <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i=<span class=\"hljs-number\">1</span>;i&lt;intervals.length;i++){\n    <span class=\"hljs-keyword\">let</span> cur=intervals[i],pre=res[res.length<span class=\"hljs-number\">-1</span>]\n    <span class=\"hljs-keyword\">if</span>(cur.start&lt;=pre.end){\n      pre.start=<span class=\"hljs-built_in\">Math</span>.min(pre.start,cur.start)\n      pre.end=<span class=\"hljs-built_in\">Math</span>.max(pre.end,cur.end)\n    }<span class=\"hljs-keyword\">else</span>{\n      res.push(cur)\n    }\n  }\n  <span class=\"hljs-keyword\">return</span> res\n};\n</code></pre>\n<p>代码<code>O(n)</code>：</p>\n<pre class=\"hljs\"><code><span class=\"hljs-comment\">/**\n * Definition for an interval.\n * function Interval(start, end) {\n *     this.start = start;\n *     this.end = end;\n * }\n */</span>\n<span class=\"hljs-keyword\">var</span> insert = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">intervals, newInterval</span>) </span>{\n  <span class=\"hljs-keyword\">let</span> result = [];\n  <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> interval <span class=\"hljs-keyword\">of</span> intervals){\n    <span class=\"hljs-keyword\">if</span>(interval.end &lt; newInterval.start){\n      result.push(interval);\n    }<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(interval.start &gt; newInterval.end){\n      result.push(newInterval);\n      newInterval = interval;\n    }<span class=\"hljs-keyword\">else</span>{\n      newInterval.start=<span class=\"hljs-built_in\">Math</span>.min(newInterval.start, interval.start)\n      newInterval.end=<span class=\"hljs-built_in\">Math</span>.max(newInterval.end, interval.end)\n    }\n  }\n  result.push(newInterval);\n  <span class=\"hljs-keyword\">return</span> result\n};\n</code></pre>\n"
}
