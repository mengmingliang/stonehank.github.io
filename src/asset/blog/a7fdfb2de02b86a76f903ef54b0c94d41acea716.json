{
  "content": "<p>首先是子数组和为某个值的计算。</p>\n<p>当计算子数组和为某一个值的数量，我们需要使用一个<code>hash</code>保存当前的和。</p>\n<p>这样当下一次计算<code>hash[sum-target]</code>的时候，可以快速找出以前保存过的子数组的数量，</p>\n<p>例如<code>[1,2,3,4,5]</code></p>\n<p>遍历一遍后<code>hash</code>为<code>{1:1, 3:1, 6:1, 10:1, 15:1}</code></p>\n<p>当我们计算到<code>index为2（数值为3）</code>的时候，这时<code>sum</code>为6，并且由于存在<code>hash[6-5]</code>，说明<code>123</code>这个子数组中是存在和为<code>5</code>的。</p>\n<p>代码：</p>\n<pre class=\"hljs\"><code><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">calcSumCount</span>(<span class=\"hljs-params\">arr,target</span>)</span>{\n  <span class=\"hljs-keyword\">let</span> hash={},sum=<span class=\"hljs-number\">0</span>,res=<span class=\"hljs-number\">0</span>\n  hash[<span class=\"hljs-number\">0</span>]=<span class=\"hljs-number\">1</span>\n  <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i=<span class=\"hljs-number\">0</span>;i&lt;arr.length;i++){\n    sum+=arr[i]\n    res+=hash[sum-target] || <span class=\"hljs-number\">0</span>\n    <span class=\"hljs-keyword\">if</span>(!hash[sum])hash[sum]=<span class=\"hljs-number\">1</span>\n    <span class=\"hljs-keyword\">else</span> hash[sum]++\n  }\n  <span class=\"hljs-keyword\">return</span> res\n}\n</code></pre>\n<hr>\n<p>接着是来自<code>leetcode：974. Subarray Sums Divisible by K</code>，这道题是关于子数组和的一个变形。</p>\n<p>题目要求计算出子数组和能被K整除的数量。</p>\n<p>例如：<code>A=[4,5,0,-2,-3,1], K=5</code>，结果是<code>7</code>，存在以下子数组</p>\n<pre class=\"hljs\"><code>[4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3]\n</code></pre>\n<p>思路：</p>\n<p>和上面一样，题目都是要求计算子数组的和，但这次要额外计算是否能被整除，而不是等于某个数</p>\n<p>被整除也就是用<code>%</code>处理，我们需要保存每一次的<code>%</code>，因为如果当前算出的模，在<code>hash</code>中已经存在，那么说明已经找到了能被K整除的子数组。</p>\n<p>例如<code>a % K =4 &amp;&amp; (a+b+c) % K =4</code>条件成立，那么可以确保<code>b,c</code>这个子数组是能被<code>K</code>整除的子数组。</p>\n<p>但是，还需要额外考虑一个因素，那就是负数，如果不对负数的模进行处理，当同时出现正负数，会错过一些正确的值。</p>\n<p>例如考虑<code>[4,-2,-3]</code> <code>K</code>为5,，如果我们按照上面的办法，那么当计算到<code>index为2(值为-3)</code>的时候，<code>hash</code>为<code>{4:1, 2:1}</code>，\n这时的<code>sum</code>是<code>4+ -2</code>，现在再加<code>-3</code>，sum为<code>-1</code>，模为<code>-1 % 5 =-1</code>，我们发现，hash中并没有模为 <code>-1</code>的值，但其实<code>-1</code>是一个\n需要收集的答案，因为<code>-2 + -3</code>能被<code>5</code>整除。</p>\n<p>因此当<code>sum</code>为负数时，我们需要转换为正数，再去从<code>hash</code>中获取。</p>\n<p>代码：</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">var</span> subarraysDivByK = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">A, K</span>) </span>{\n  <span class=\"hljs-keyword\">let</span> hash={},sum=<span class=\"hljs-number\">0</span>,res=<span class=\"hljs-number\">0</span>\n  hash[<span class=\"hljs-number\">0</span>]=<span class=\"hljs-number\">1</span>\n  <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i=<span class=\"hljs-number\">0</span>;i&lt;A.length;i++){\n    sum+=A[i]\n    <span class=\"hljs-keyword\">if</span>(sum&lt;<span class=\"hljs-number\">0</span>) sum+=K*<span class=\"hljs-built_in\">Math</span>.ceil(-sum/K)\n    <span class=\"hljs-keyword\">let</span> m=sum % K\n    <span class=\"hljs-keyword\">if</span>(hash[m]==<span class=\"hljs-literal\">null</span>)hash[m]=<span class=\"hljs-number\">0</span>\n    res+=hash[m]\n    hash[m]++\n  }\n  <span class=\"hljs-keyword\">return</span> res\n};\n</code></pre>\n"
}
