{
  "content": "## popstate\n\n只在浏览器下前进后退和改变hash触发，`pushState`和`replaceState`并不会触发\n\n源码中给`popstate`和`navigate`事件绑定了一旦执行就更新当前location(传递到context中的)\n\n\n## 替代pushState和replaceState\n源码中对`pushState`和`replaceState`操作用`try...catch`包裹，因为有一个bug，[iOS Safari limits to 100 pushState calls](https://forums.developer.apple.com/thread/36650)\n\n因此当出现catch，会执行`location.replace`或者`location.assign`\n\n* `location.replace` 跳转url，替代当前，不增加历史记录\n* `location.assign` 跳转url，增加历史记录\n\n## createContext(defaultValue)\n\n官方(英文)：\n> If there is no Provider for this context above, the value argument will be equal to the defaultValue that was passed to createContext().\n\n中文文档：\n>如果上层的组件树没有一个匹配的 Provider，而此时你需要渲染一个 Consumer 组件，那么你可以用到 defaultValue 。这有助于在不封装它们的情况下对组件进行测试。\n\n源码中这么用的\n```jsx\nconst createNamedContext = (name, defaultValue) => {\n  const Ctx = createContext(defaultValue);\n  Ctx.Consumer.displayName = `${name}.Consumer`;\n  Ctx.Provider.displayName = `${name}.Provider`;\n  return Ctx;\n};\n\nlet BaseContext = createNamedContext(\"Base\", { baseuri: \"/\", basepath: \"/\" });\n\nlet Router = props => (\n  <BaseContext.Consumer>\n    {/* 此处baseContext是 { baseuri: \"/\", basepath: \"/\" } */}\n    {baseContext => (\n      <Location>\n        {locationContext => (\n          <RouterImpl {...baseContext} {...locationContext} {...props} />\n        )}\n      </Location>\n    )}\n  </BaseContext.Consumer>\n```\n\n## 工具介绍 invariant\n\n`invariant(boolean,something)` 参数1为false就`throw 参数2(something)`\n \n## react中element.type\n用来判断组件的类型\n\n例如：\n```jsx\n// 1、高阶组件\nfunction HOC(com){\n  return class extends React.Component{\n    render(){\n      return <com />\n    }\n  }\n}\n// 2、自定义组件\nclass MyComponent extends React.Component{\n    render(){\n        return <div>...</div>\n    }\n}\n// 3、无状态组件\nfunction DumbComponent(props){\n    return <button>show</button>\n}\n// 4、原生标签（直接写到children里）\n\n// 判断\nfunction checkType(element){\n    let type=element.type\n    if(type.prototype && type.prototype.isReactComponent){\n        console.log('自定义React组件')\n    }else if(typeof type === 'function'){\n        console.log('是一个函数（高阶函数），继续调用')\n    }else if(typeof type === 'string'){\n        console.log('是一个原生标签')\n    }else{\n        console.log('其他')\n    }\n}\nclass Check extends React.Component{\n  render(){\n    React.Children.map(this.props.children,element=>{\n      checkType(element)\n    })\n    return <div />\n  }\n}\nReactDOM.render(\n  <Check>\n    <HOC />      \n    <MyComponent />\n    <DumbComponent />\n    <div />\n  </Check>,\n  document.getElementById('container')\n);\n/*\n\"是一个函数（高阶函数），继续调用\"\n\"自定义React组件\"\n\"是一个函数（高阶函数），继续调用\"（此处无状态函数组件会被认为函数）\n\"是一个原生标签\"\n*/\n```\n\n源码中用来检测是否重定向组件：\n```jsx\nclass RouterImpl extends React.PureComponent {\n    render(){\n        /* 其他代码 */\n        let routes = React.Children.map(children, createRoute(basepath));\n        /* 其他代码 */\n    }        \n}\n\nlet createRoute = basepath => element => {\n    // element.type === Redirect 用于检测是否某个组件\n    invariant(\n        element.props.path || element.props.default || element.type === Redirect,\n        `<Router>: Children of <Router> must have a \\`path\\` or \\`default\\` prop, or be a \\`<Redirect>\\`. None found on element type \\`${\n         element.type\n        }\\``\n     );\n  /* 其他代码 */\n}\n\n// 这里Redirect是个无状态组件  \nlet Redirect = props => (\n  <Location>\n    {locationContext => <RedirectImpl {...locationContext} {...props} />}\n  </Location>\n);\n```"
}
