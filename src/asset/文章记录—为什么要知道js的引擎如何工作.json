{
	"content": "\n原文：[https://medium.freecodecamp.org/javascript-essentials-why-you-should-know-how-the-engine-works-c2cc0d321553](https://medium.freecodecamp.org/javascript-essentials-why-you-should-know-how-the-engine-works-c2cc0d321553)\n\n-----------\n\n#### 现象\n\n文章首先就抛出了两段代码，它们的不同之处仅仅在于后者的数据结构多了一个属性而已\n\n\n例一：\n```\n(() => { \n  const han = {firstname: \"Han\", lastname: \"Solo\"};\n  const luke = {firstname: \"Luke\", lastname: \"Skywalker\"};\n  const leia = {firstname: \"Leia\", lastname: \"Organa\"};\n  const obi = {firstname: \"Obi\", lastname: \"Wan\"};\n  const yoda = {firstname: \"\", lastname: \"Yoda\"};\n  const people = [\n    han, luke, leia, obi, \n    yoda, luke, leia, obi \n  ];\n  const getName = (person) => person.lastname;\n  console.time(\"engine\");\n  for(var i = 0; i < 1000 * 1000 * 1000; i++) { \n    getName(people[i & 7]); \n  }\n  console.timeEnd(\"engine\"); \n})();\n```\n\n例二：\n```\n(() => {\n  const han = {firstname: \"Han\", lastname: \"Solo\", spacecraft: \"Falcon\"};\n  const luke = {firstname: \"Luke\", lastname: \"Skywalker\", job: \"Jedi\"};\n  const leia = {firstname: \"Leia\", lastname: \"Organa\", gender: \"female\"};\n  const obi = {firstname: \"Obi\", lastname: \"Wan\", retired: true};\n  const yoda = {lastname: \"Yoda\"};\n  const people = [\n    han, luke, leia, obi, \n    yoda, luke, leia, obi\n  ];\n  const getName = (person) => person.lastname;\n  console.time(\"engine\");\n  for(var i = 0; i < 1000 * 1000 * 1000; i++) {\n    getName(people[i & 7]);\n  }\n  console.timeEnd(\"engine\");\n})();\n```\n结果执行后，第一个耗时约1.2s,第二个耗时约8.5s\n\n仅仅加了一个属性，为什么会有这么大的差距？\n\n-------------\n\n#### 原因\n\n这就要提到JS的`Interpreter`(解释器)和`Compiler`编译器。\n\n当创建一个对象后，解释器会对这个对象进行检索，这个检索操作是消耗很大的。\n\n因此，又要提出一个概念`Inline Caching`内联缓存，它会在运行时，将对象按照属性的key名称和顺序完全一致的分类，例如`{firstname: \"Han\", lastname: \"Solo\"} `和` {lastname: \"Solo\", firstname: \"Han\"}`会被分为2类。\n\n如果对象都属于同一类，也就是它们的`shape`形状一致，那么内联缓存就会让编译器执行相同的处理，从而提升性能。\n\n在第一个例子中，由于所有数据结构的\"形状\"都是一样的，因此称为`单态内联缓存`；\n\n当\"形状\"超过1个，第二个例子，即缓存了多个数据结构的\"形状\"，那么编译器每次都会在几个\"形状之间\"进行判断；\n\n当缓存的\"形状\"继续增加，超过一个上限值后，就不存在局部缓存，而是全局缓存，那么每次检索都会在全局缓存上查找，这会导致性能下降到极点。\n\n-----------\n\n#### 解决\n\n知道原因后，问题就很好解决了，定义一个\"形状\"一样的数据结构就好了\n\n```\n(() => {\n  class Person {\n    constructor({\n      firstname = '',\n      lastname = '',\n      spaceship = '',\n      job = '',\n      gender = '',\n      retired = false\n    } = {}) {\n      Object.assign(this, {\n        firstname,\n        lastname,\n        spaceship,\n        job,\n        gender,\n        retired\n      });\n    }\n  }\n  const han = new Person({\n    firstname: 'Han',\n    lastname: 'Solo',\n    spaceship: 'Falcon'\n  });\n  const luke = new Person({\n    firstname: 'Luke',\n    lastname: 'Skywalker',\n    job: 'Jedi'\n  });\n  const leia = new Person({\n    firstname: 'Leia',\n    lastname: 'Organa',\n    gender: 'female'\n  });\n  const obi = new Person({\n    firstname: 'Obi',\n    lastname: 'Wan',\n    retired: true\n  });\n  const yoda = new Person({ lastname: 'Yoda' });\n  const people = [\n    han,\n    luke,\n    leia,\n    obi,\n    yoda,\n    luke,\n    leia,\n    obi\n  ];\n  const getName = person => person.lastname;\n  console.time('engine');\n  for (var i = 0; i < 1000 * 1000 * 1000; i++) {\n    getName(people[i & 7]);\n  }\n  console.timeEnd('engine');\n})();\n```\n运行，消耗时间1.2s，任务完成！\n\n\n\n\n"
}
