{
  "content": "\n## 阅读前提：\n1. 有rxjs基础，对`Observable`, `Subject`,`pipe`和一些操作符(例如`filter`,`map`,`merge`,`mergeMap`)执行流程有基本了解，最起码遇到不清楚有去查阅的动力\n2. 比较熟悉`redux`中间件的写法，否则像`createEpicMiddleware.js`中的这一段会搞不清楚\n    ```\n    return next => {\n      return action => {\n    ```\n    关于redux也可以查阅我之前写的[redux源码注释](https://github.com/stonehank/sourcecode-analysis/tree/master/source-code.redux)\n    \n\n## 目录结构\n\n```\nsrc/\n├──utils/\n    ├──console.js\n├── ActionsObservable.js    // 自定义的类，继承Observable, 绑定了操作符的链式调用\n├── combineEpics.js         // \n├── createEpicMiddleware.js // 调用可生成redux的中间件, 通过run绑定需要执行的流\n├── index.js                // 对外接口\n├── operators.js            // 自定义的流操作方法, 目前只有ofType\n├── StateObservable.js      // 自定义的类，继承Observable, 用于保存当前state\n```\n\n\n## 源码分析\n\nindex.js：公开接口，略\n\n-----\n\n### ActionObservable.js\n\n继承了`Observable`类\n```js\nexport class ActionsObservable extends Observable\n```\n\n定义了两个静态函数，用调用的对象包装了原来的`of`和`from`\n```js\n  static of(...actions) {\n    return new this(of(...actions));\n  }\n  static from(actions, scheduler) {\n    return new this(from(actions, scheduler));\n  }\n```\n\n构造函数，定义了`source`属性为参数，这个属性用来绑定操作符的链式调用\n```js\n  constructor(actionsSubject) {\n    super();\n    this.source = actionsSubject;\n  }\n```\n这里重写了父类(Observable)的`lift`，先看一下父类的`lift`是怎样的\n```js\nvar observable = new Observable();\nobservable.source = this;\nobservable.operator = operator;\nreturn observable;\n```\n可以看到改动就在于原来的用`new Observable`，这里使用`new ActionObservable()`，其他都是一模一样，\n封装成`ActionObservable`类的意义，统一类型，方便后面的链式绑定\n\n`lift`在`pipe`的时候会用到，其实这都是rxjs源码调用的方式()\n```js\nlift(operator) {\n const observable = new ActionsObservable(this);\n observable.operator = operator;\n return observable;\n}\n```\n定义了一个操作方法`ofType`，具体见operators\n```js\n  ofType(...keys) {\n    return ofType(...keys)(this);\n  }\n```\n\n----------------\n### combineEpics.js\n\n将多个epic合并成1个epic，就是分别执行每一个epic(绑定用户定义的操作符)，然后将每一个结果的流用merge合并\n```js\n// 引入merge\nimport { merge } from 'rxjs';\n\n/**\n  Merges all epics into a single one.\n */\nexport const combineEpics = (...epics) => {\n  // 通过merge操作符合并多个epic执行后的output$流\n  // ...epics是多个epic\n  const merger = (...args) => merge(\n    ...epics.map(epic => {\n      // 执行每一个epic，确保有返回值，此处执行就是绑定了用户自定义操作符的步骤\n      const output$ = epic(...args);\n      if (!output$) {\n        throw new TypeError(`combineEpics: one of the provided Epics \"${epic.name || '<anonymous>'}\" does not return a stream. Double check you\\'re not missing a return statement!`);\n      }\n      // 返回结果，最后进行merge合并\n      return output$;\n    })\n  );\n\n  // Technically the `name` property on Function's are supposed to be read-only.\n  // While some JS runtimes allow it anyway (so this is useful in debugging)\n  // some actually throw an exception when you attempt to do so.\n  try {\n    Object.defineProperty(merger, 'name', {\n      value: `combineEpics(${epics.map(epic => epic.name || '<anonymous>').join(', ')})`,\n    });\n  } catch (e) {}\n\n  return merger;\n};\n```\n--------------\n### createEpicMiddleware.js\n\n一、提示目前参数不在接受`rootEpic`，而是使用`epicMiddleware.run(rootEpic)`，这里`epicMiddleware`就是执行`createEpicMiddleware`的返回值\n```js\nexport function createEpicMiddleware(options = {}) {\n  if (process.env.NODE_ENV !== 'production' && typeof options === 'function') {\n    throw new TypeError('Providing your root Epic to `createEpicMiddleware(rootEpic)` is no longer supported, instead use `epicMiddleware.run(rootEpic)`\\n\\nLearn more: https://redux-observable.js.org/MIGRATION.html#setting-up-the-middleware');\n  }\n  /*...*/\n}\n```\n二、这一定义了几个重要变量(流)，这里一个重要问题\n```\n1. rxjs内部的source是什么(在ActionObservable内部出现)\n2. rxjs内部的operator是什么(在ActionObservable内部出现)\nA：source定义了操作符执行的流向，operator定义了操作符是什么操作符，这两者结合使用来进行链式绑定\n```\n接着看注释\n```js\nexport function createEpicMiddleware(options = {}) {\n  /*...*/\n  // 定义一个Subject，绑定内部操作流，通过调用epic$.next()，也就是`epicMiddleware.run`来初始化action$的绑定\n  const epic$ = new Subject();\n  let store;\n  // 作为redux的中间件，其中epicMiddleware是返回值作为外部API\n  const epicMiddleware = _store => {\n    // 当在开发环境并且多次使用不同的 createEpicMiddleware返回值，会提出警告(避免重复执行多次)\n    if (process.env.NODE_ENV !== 'production' && store) {\n      // https://github.com/redux-observable/redux-observable/issues/389\n      require('./utils/console').warn('this middleware is already associated with a store. createEpicMiddleware should be called for every store.\\n\\nLearn more: https://goo.gl/2GQ7Da');\n    }\n    store = _store;\n    // 定义一个Subject，绑定了队列调度器 (后面这个用来绑定所有操作流)\n    const actionSubject$ = new Subject().pipe(\n      // todo 调度器，看了一些资料，还有有点模糊\n      observeOn(queueScheduler)\n    );\n    //  定义一个Subject，绑定了队列调度器 (后面这个用来对比当前store，防止重复渲染)\n    const stateSubject$ = new Subject().pipe(\n      observeOn(queueScheduler)\n    );\n    // 定义一个ActionsObservable，用来绑定用户定义的操作流\n    const action$ = new ActionsObservable(actionSubject$);\n    // 定义一个StateObservable，内部改写了Observable的_subscribe方法，并且让stateSubject$绑定了value对比操作，就是简单的引用对比`===`\n    const state$ = new StateObservable(stateSubject$, store.getState());\n    \n    /*...*/\n  }\n}\n```\n三、这里是核心，所有流和操作符的绑定就是在此内部进行\n```js\nexport function createEpicMiddleware(options = {}) {\n  /*...*/\n  \n  // pipe操作符\nconst result$ = epic$.pipe(\n  // 对发射源逐个处理\n  map(epic => {\n    // 如果配置有 dependencies 就放置到第三个参数中\n    const output$ = 'dependencies' in options\n      ? epic(action$, state$, options.dependencies)\n      : epic(action$, state$);\n    // 无返回值，报错，应该要返回一个不同的流\n    if (!output$) {\n      throw new TypeError(`Your root Epic \"${epic.name || '<anonymous>'}\" does not return a stream. Double check you\\'re not missing a return statement!`);\n    }\n    // output$ 是一个ActionObservable类型的流\n    return output$;\n  }),\n  // 对所有外部流，绑定队列调度并且使用mergeMap重新subscribe\n  mergeMap(output$ =>\n    from(output$).pipe(\n      subscribeOn(queueScheduler),\n      observeOn(queueScheduler)\n    )\n  )\n);\n\n    /*...*/\n}\n\n```\n四、epic执行主要流程，`dispatch(action$)`--> `actionSubject$.next(action)`-->经过一系列操作符-->最后到达底层`dispatch(state)`\n```js\nexport function createEpicMiddleware(options = {}) {\n/*...*/\n\n// 订阅 dispatch，此处将dispath作为流执行的最底层\nresult$.subscribe(store.dispatch);\n\n// 返回的格式是按照redux中间件的格式\n// 里面的内容都是运行时redux里dispatch后会执行的流程\nreturn next => {\n  return action => {\n    // 此处先截取next(action)\n    const result = next(action);\n    // 先执行 stateSubject$.next 可以保证state的更新\n    stateSubject$.next(store.getState());\n    // 操作符按步骤执行，此时的actionSubject$已经绑定了所有的操作符\n    actionSubject$.next(action);\n    return result;\n  };\n};\n// run方法，通过epic$的next方法初始化action(见第三)，从而绑定用户自定义的操作符\nepicMiddleware.run = rootEpic => {\n  if (process.env.NODE_ENV !== 'production' && !store) {\n    require('./utils/console').warn('epicMiddleware.run(rootEpic) called before the middleware has been setup by redux. Provide the epicMiddleware instance to createStore() first.');\n  }\n    // rootEpic就是用户自定义的操作符\n  epic$.next(rootEpic);\n};\nreturn epicMiddleware;\n}\n```\n------------------\n### operators.js\n\n定义了`ofType`，其实就是一个filter\n```js\n// 引入filter\nimport { filter } from 'rxjs/operators';\n// 这里type就是传给epic的action的type的值，key就是用户自定义需要过滤的值\nconst keyHasType = (type, key) => {\n  return type === key || typeof key === 'function' && type === key.toString();\n};\n// source就是调用ofType的流，也就是createEpicMiddleware里的action$\n// 结果只有返回true才会继续链式调用\nexport const ofType = (...keys) => (source) => source.pipe(\n  filter(({ type }) => {\n    const len = keys.length;\n    if (len === 1) {\n      return keyHasType(type, keys[0]);\n    } else {\n      for (let i = 0; i < len; i++) {\n        if (keyHasType(type, keys[i])) {\n          return true;\n        }\n      }\n    }\n    return false;\n  })\n);\n```\n------------------\n### StateObservable.js\n\n继承`Observable`，定义了一个保存状态的类，里面改写了父类(`Observable`)的`_subscribe`(作用不太清楚)，\n并且定义了一个保存当前数据状态的函数，通过stateSubject(也就是createEpicMiddleware里面的`stateSubject$`)的`subscribe`绑定到底层\n```js\nimport { Observable, Subject } from 'rxjs';\n\nexport class StateObservable extends Observable {\n  constructor(stateSubject, initialState) {\n    // 调用父类构造函数，改写父类的_subscribe\n    // todo 作用？\n    super(subscriber => {\n      const subscription = this.__notifier.subscribe(subscriber);\n      if (subscription && !subscription.closed) {\n        subscriber.next(this.value);\n      }\n      return subscription;\n    });\n    \n    this.value = initialState;\n     this.__notifier = new Subject();\n      // 绑定一个引用比较的状态函数\n     this.__subscription = stateSubject.subscribe(value => {\n       if (value !== this.value) {\n         this.value = value;\n         this.__notifier.next(value);\n       }\n     });\n   }\n }\n```\n\n源码就到此分析完了，看到这里可能还是一头雾水，知道是什么也只是概念上的知道，对整个流程还是没有头绪\n\n[查看更多关于流程分析](https://github.com/stonehank/sourcecode-analysis/blob/master/source-code.redux-observable/README.md)"
}
