{
  "content": "## nano-memoize 和 fast-memoize\n\n首先，这2个工具的实现源码是极其相似的，基本上，只要阅读了其中一个源码，也就了解了另外一个的实现。\n\nfast-memoize导图：\n![](./img/fast-memoize.png)\n\n大概说说它们的实现思路：\n\n1. 定义缓存结构，其中`fast`使用了`无prototype的对象`，`nano`使用了`普通对象`。\n2. 定义序列化方法：当检测到是单参数时，都是选择JSON.stringify，而多个参数，两者有不同（后面再说）。\n3. 定义策略：也就是缓存的具体方法，其实很简单，就是对当前缓存结构查找，找到就返回，找不到就重新运行，\n    两者都使用了`bind`方法注入参数，可以省去运行时再去查找参数。\n    \n接着分析两者的异同：\n\n相同处：\n\n* 都使用了`JSON.stringify`作为序列化方法，因为它是原生的。\n* 都对返回的缓存函数进行了参数注入（这是一个极大提升性能的方法）。\n* 对单参数还是多参数的判断都是使用`func.length`(形参的数量判断)，因为`func.length`比`arguments.length`这种动态判断性能会好很多。\n\n不同点：\n* `fast`使用了`无prototype的对象`，`nano`使用了`普通对象`(这一点性能上相差不多)。\n* 当遇到多个参数时，`fast`还是继续对`arguments`进行序列化，而`nano`则复杂一点，它通过用数组将每一次多个参数保存起来，\n后续通过遍历每个参数进行全等对比`===`，判断是否从缓存调取结果。\n* 同样是多个参数，`nano`增加了一个参数max，可以让用户自定义需要进行对比参数的长度。\n\n[更详细的说明和深入理解，可查看源码学习——fast,nano](https://github.com/stonehank/sourcecode-analysis/blob/master/source-code.fast-memoizeVSnano-memoize/README.md)\n\n假设：\n* 忽略===的执行时间\n* 使用的参数分为 引用相同 和 引用不同(但是深比较为true)\n\n|*耗时操作*|*多个参数(引用相同)*|   |*多个参数(引用不同)*|    |\n|------|--------|---------|----------|----------|\n|状态  |首次运行 |后续运行|首次运行  |  后续运行|\n|fast  |序列化+运行|序列化|序列化+运行|序列化|\n|nano  |运行|0|运行|运行|\n\n"
}
