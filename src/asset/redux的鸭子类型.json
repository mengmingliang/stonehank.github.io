{
	"content": "* 之前的项目架构写法\n```\nproduct/\n├── product.js\n├── constant.js\n├── productActions.js\n├── productReducers.js\n...\nwidget/\n├── widget.js\n├── constant.js\n├── widgetActions.js\n├── widgetReducers.js\n...\nlogin/\n├── login.js\n├── constant.js\n├── loginActions.js\n├── reducers.js\n    ├──index.js\n    ├──someReducer2.js\n    ├──someReducer1.js\n            ...\n...\ngallery/\n├── gallery.js\n├── constant.js\n├── action/\n    ├──someAction1.js\n    ├──someAction2.js\n            ...\n├── galleryReducers.js\n...\n```\n除了这种类似按功能划分，还有其他，例如dump/smart component等\n\n这些有一个特点，划分的很细，而且很抽象，基本上面对任何功能，都是同一套模板，但你也有可能面对一个简单的逻辑，确去查找了4-5个文件\n\n## 鸭子类型的写法\n```\nduck/\n├── product.js\n├── login.js\n├── gallery.js\n├── widget.js\n...\n```\n就是将每个功能板块的action,reducer等合并到一起，但需要遵守几个规则：\n\n1. 必须 export default 函数名为 reducer() 的 reducer\n2. 必须 作为函数 export 它的 action creators\n3. 必须 把 action types 定义成形为 npm-module-or-app/reducer/ACTION_TYPE 的字符串\n4. 如果有外部的reducer需要监听这个action type，或者作为可重用的库发布时， 可以 用 UPPER_SNAKE_CASE 形式 export 它的 action types。\n\n其中第三条是必须规定这么写type\n\n`const LOAD   = 'my-app/widgets/LOAD'`\n\n以路径的方式定义type\n\n至于原因还不太理解，可能是当应用复杂的时候也能正确区分每一个type，而且路径命名比较好找？\n\n当遵守了以上规则，其duck内部文件内容就有点类似金字塔形状了，\n\n```\n├──product.js (export default combineReducer(...))\n\n             combineReducer\n                   |    \n             reducer reducer\n            /      |       \\\n        action action action action\n        /          |           \\\n    type type type type type type type type\n    \n```\n这种结构当我们针对某个功能进行阅读或者修改，确实方便（都在一个文件内部），性能也相对会提升（不会那么多调用）\n\n但是个人认为项目大到一定程度，某个功能的文件内容多到一定程度，还是需要分割，或许可以写成：\n\n```\nduck/\n├── product\n    ├── productActions.js\n    ├── productReducers.js\n    ├── productTypes.js\n├── login.js\n├── gallery.js\n├── widget.js\n...\n```\n这种混合模式可能比较适合。"
}
