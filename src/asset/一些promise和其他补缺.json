{
  "content": "* 如果向 Promise.resolve(..) 传递一个真正的 Promise，就只会返回同一个 promise\n```js\nvar p1 = Promise.resolve( 42 );\nvar p2 = Promise.resolve( p1 );\np1===p2\n// true\n```\n\n------\n* Promise.resolve(..) 可以接受任何 thenable，将其解封为它的非 thenable 值。\n```js\nvar c={\n  then:(a,b)=>{\n    a(5);b(\"err\")}\n}\n\nPromise.resolve( c )\n.then(\n  function fulfilled(val){\n    console.log( 'success',val );\n  },\n  function rejected(err){\n    console.log('error',err)\n  }\n);\n// success 5\n```\n---------\n* Deferred模式\n\n```js\nfunction Deferred() {\n    this.promise = new Promise((resolve, reject)=>{\n        this._resolve = resolve;\n        this._reject = reject;\n    });\n}\nDeferred.prototype.resolve = function (value) {\n    this._resolve(value);\n};\nDeferred.prototype.reject = function (reason) {\n    this._reject(reason);\n};\nvar d=new Deferred()\nvar obj={}\nobj.res=d.resolve.bind(d)\nobj.rej=d.reject.bind(d)\nobj.rej(124)\nd.promise.then(v=>console.log(v),err=>console.warn(err)).catch(err=>console.error(err))\n```\n\n-------\n\n* 继承prototype\n```js\nfunction A() {}\nA.prototype.a = 5\nA.prototype.show = () => {\n  console.log(11)\n}\nA.prototype.arr = [1, 2, 3, 4]\n\nfunction B() {}\nfor (let k in A.prototype) {\n  B.prototype[k] = A.prototype[k]\n}\n\nfunction C() {}\nC.prototype = Object.create(A.prototype)\n\n// B和C的区别\n\nvar b = new B()\nvar c = new C()\n\nb instanceof A // false\nc instanceof A // true\n```"
}
