{
	"content": "最近遇到的，目的是通过粒子动画渲染图片\n\n图片大小为500*300，并且粒子动画细度为1，也就是粒子总量为15万，并且当动画完成后，图片能完整清晰的显示出来\n\n最初尝试15万个粒子同时运动，结果标签页直接崩溃了，意料之中...\n\n```js\n for (let py = 0; py < targetH; py ++) {\n    for (let px = 0; px < targetW; px ++) {\n      let rgba4 = (px + py * targetW) * 4 - 1\n      if(rgba4<0)rgba4=3\n      const rgba3=rgba4-1,rgba2=rgba3-1,rgba1=rgba2-1;\n      const opacity = imgData.data[rgba4];\n      if (opacity === 255) {\n        const opts={\n          cur:[px,py],\n          end:[px,py],\n          color:[imgData.data[rgba1],imgData.data[rgba2],imgData.data[rgba3],imgData.data[rgba4]],\n           /* 省略：一些其他参数 */\n         }\n         /* 省略：对当前时间戳的处理 */\n         /* 省略：对动画的处理 */\n         ctx.fillStyle = `rgba(${rgba1}, ${rgba2}, ${rgba3},${rgba4}`\n         ctx.fillRect(curX, curY, 1, 1);\n      }\n    }\n  }\n```\n\n----------\n\n后来考虑离屏吧，规定每个离屏承载量为1000(保证fps)，这么一来，75个`离屏canvas`，开始动画...奔溃了...\n\n```js\nexport default function createAssignParticles(allParticles){\n  // 定义每个离屏承载量\n  const eachPanelParticles=1000\n  const assignedParticles=[]\n  const panelsSize=Math.ceil(allParticles.length/eachPanelParticles)\n  for(let i=0;i<panelsSize;i++){\n    // 创建离屏canvas\n    const  canvas = document.createElement('canvas');\n    canvas.width=window.outerWidth\n    canvas.height=window.outerHeight;\n    const ctx=canvas.getContext('2d')\n    // 后渲染的在上层\n    ctx.globalCompositeOperation='destination-over'\n    // 取消抗锯齿\n    ctx.imageSmoothingEnabled = false;\n    ctx.mozImageSmoothingEnabled = false;\n    ctx.webkitImageSmoothingEnabled = false;\n    assignedParticles[i]={\n      sourceArr:[],\n      canvas,\n      ctx,\n    }\n  }\n  // 乱序将每个粒子平均插入每个离屏canvas\n  for(let i=0;i<allParticles.length;i++){\n    const putInWhichPanel=Math.floor(Math.random()*(panelsSize-0.01))\n    assignedParticles[putInWhichPanel].sourceArr.push(allParticles[i])\n  }\n  return assignedParticles\n}\n\n// 执行动画函数内部\nfor(let i=0;i<assignedParticles.length;i++){\n  let cur=assignedParticles[i].sourceArr\n  for(let j=0;j<cur.length;j++){\n     /* 省略：对当前时间戳的处理 */\n     /* 省略：对动画的处理 */\n     ctx.fillStyle = `rgba(${rgba1}, ${rgba2}, ${rgba3},${rgba4}`\n     ctx.fillRect(curX, curY, 1, 1);\n  }\n}\n```\n\n毕竟同时运动的总量还是15万个粒子...\n\n既然不能同时运动，那么就分批运动总行了吧\n\n----------\n\n每个`离屏canvas`执行完毕，递归调用下一个`离屏canvas`，但这样又出现一个新的问题，\n\n如果每个`离屏canvas`执行后，清除显示用的画布，那么动画只是会出现每一个离屏的动画，上一个离屏动画的结果并未保存。\n\n如果不清除显示的画布，那么每个`离屏canvas`会有轨迹，造成模糊(虽然也挺好看，但不是需要的效果)。\n\n![](./img/带轨迹.png)\n```js\nimport raf from 'raf'\nimport {spiral,fadeIn,explode} from './animations-control/core'\nimport stopIfNeed from './animations-control/stopIfNeed'\nimport lastRenders from './animations-control/lastRenders'\n\n\nexport default function play(assignedParticles,c_showMotion,ctx_showMotion,options,doneCallBack){\n  /* 省略：获取会用到的参数*/\n  let allParticlesIdx=0\n  recursionExec(allParticlesIdx)\n  function  recursionExec(allParticlesIdx){\n    let arrs=assignedParticles[allParticlesIdx].sourceArr\n    let ctx=assignedParticles[allParticlesIdx].ctx\n    let canvas=assignedParticles[allParticlesIdx].canvas\n    let doneNum=0\n    let rafHandle\n    let msPerFrame=1000/60\n    function startIfNeed(){\n      rafHandle= raf(function playing(timestamp){\n       /* 省略：判断当前离屏canvas是否结束 */\n       \n       // 执行当前离屏canvas\n      ctx.clearRect(0, 0, canvasW, canvasH)\n      ctx.beginPath();\n      for (let k = 0; k < arrs.length; k++) {\n        let {cur,end} = arrs[k]\n        /* 省略：判断当前粒子是否需要停止*/\n        /* 省略：对当前时间戳的处理 */\n        /* 省略：对动画的处理 */\n        \n        ctx.fillStyle = `rgba(${rgba1}, ${rgba2}, ${rgba3},${rgba4}`\n        ctx.fillRect( curX,  curY, 1, 1);\n      }\n      // 此处ctx_showMotion是显示用的canvas，\n      // 如果不使用clearRect，那么会出现轨迹\n      // 如果使用clearRect，那么每次执行的动画结果不会被保存\n      // ctx_showMotion.clearRect(0,0,canvasW,canvasH)\n      ctx_showMotion.drawImage(canvas ,0, 0,)\n        \n        raf(playing)\n      })\n      ctx_storeStatus.drawImage(c_showMotion,0,0)\n    }\n    startIfNeed()\n  }\n}\n```\n\n----------\n\n最后考虑用2张画布显示，第一个清除并且显示当前`离屏canvas`，第二个用来保存第一个的结果\n\n```\n      /* 省略：前面参数多了一个ctx_storeStatus，其他一致 */\n        ctx.fillStyle = `rgba(${rgba1}, ${rgba2}, ${rgba3},${rgba4}`\n        ctx.fillRect( curX,  curY, 1, 1);\n      }\n      // 此处ctx_showMotion是显示用的canvas，\n      // 如果不使用clearRect，那么会出现轨迹\n      // 如果使用clearRect，那么每次执行的动画结果不会被保存\n      // ctx_showMotion.clearRect(0,0,canvasW,canvasH)\n      ctx_showMotion.drawImage(canvas ,0, 0,)\n        raf(playing)\n      })\n      // 专门用于保存ctx_showMotion处理结果的canvas画布\n      ctx_storeStatus.drawImage(c_showMotion,0,0)\n    }\n    startIfNeed()\n  }\n}\n```\n\n最终效果如下：\n\n![](./img/spiral.gif)\n\n可以看到fps平均在45-50之间\n\n-------\n\n总结：\n\n充分利用canvas的画布，将对粒子进行`fill`的动画转换成对`离屏canvas`进行`drawImage`的处理\n"
}
