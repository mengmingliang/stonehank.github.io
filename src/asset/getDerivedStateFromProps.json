{
  "content": "react的`getDerivedStateFromProps`内部不可以有副作用，因为现在是无论是state改变还是props改变，\n都会执行它。\n\n例如：\n\n这种写法会导致多次循环渲染直到报错\n```jsx\nclass App extends Component {\n  constructor(props){\n    super(props)\n    this.myFetch=this.myFetch.bind(this)\n    this.state = {\n      name: \"\",\n      list: null,\n      myFetch:this.myFetch\n    };\n  }\n\n\n  static getDerivedStateFromProps(props, state) {\n    if ( props.name !== state.name ) {\n      // 这一句是有副作用的，它会改变state状态，\n      // 然后再次调用getDerivedStateFromProps，再次改变state状态...\n      state.myFetch(props.name)\n      return {\n        name: props.name\n      };\n    }\n    return null;\n  }\n  myFetch(){\n      this.setState({\n        list: \"newList\"\n      })\n  }\n  render() {\n    return (\n      <div>{this.state.list}</div>\n    );\n  }\n}\n```\n\n以上正确写法应为：\n\n```jsx\nclass App extends Component {\n  constructor(props){\n    super(props)\n    this.myFetch=this.myFetch.bind(this)\n    this.state = {\n      name: \"\",\n      list: null,\n      //myFetch:this.myFetch\n    };\n  }\n\n  // 纯函数，无副作用\n  static getDerivedStateFromProps(props, state) {\n    if ( props.name !== state.name ) {\n      return {\n        name: props.name,\n        list: null\n      };\n    }\n    return null;\n  }\n  componentDidUpdate(){\n    if(!this.state.list){\n      this.myFetch(this.props.name)\n    }\n  }\n\n  // 看是否需要初始化的时候调用\n  componentDidMount(){\n    this.myFetch(this.props.name)\n  }\n\n  myFetch(){\n    this.setState({\n      list: \"newList\"\n    })\n  }\n  render() {\n    return (\n      <div>{this.state.list}</div>\n    );\n  }\n}\n```"
}
