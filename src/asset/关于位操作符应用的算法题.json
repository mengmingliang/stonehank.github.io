{
	"content": "[原题目](https://leetcode.com/problems/maximum-product-of-word-lengths/)：\n给定一个字符串数组，找到长度的最大值`length(word[i]) * length(word[j])`，其中两个单词中的字母无相同。您可以假定每个单词只包含小写字母。如果没有这两个词，返回0。\n\n例：\n```\nInput: [\"abcw\",\"baz\",\"foo\",\"bar\",\"xtfn\",\"abcdef\"]\nOutput: 16 \nExplanation: The two words can be \"abcw\", \"xtfn\".\n```\n\n解析：\n这题肯定要进行交叉对比(2个for循环)，但最关键的就是对比过程，也就是判断2个字符串是否存在相同的字符。\n\n如果使用`indexOf`或者数组下标记录都会造成时间复杂度大幅提升，看了他人的答案发现使用的是位操作符`<<`，`|`和`&`，而且是在交叉对比之前进行预处理，交叉对比的时候只需要简单的判断`pretreate[i] & pretreate[j]===0`便可，\n\n因为使用后效率提升太多，解析并且记录一下。\n\n先解释`val |= (1 << (word.charCodeAt(i)-aCode))`：\n\n* `word.charCodeAt(i)-aCode`这个很好懂，也就是a对应0，b对应1...这里的0,1数字代表的是        \n  二进制1后面的位数。\n\n* `1<<0`，`1<<1`是什么呢？\n\n    1在二进制中(32位)就是`00000000000000000000000000000001`，`<<`是左移1位，\n    \n    那么`1<<0`还是`1`，`1<<1`就是(前面的零省略)`10`，`1<<2`就是`100`，`1<<3`就是`1000`，\n    \n    于是可知\n    \n    `a`就是`1`，\n    \n    `b`是`10`，\n    \n    `c`是`100`...\n    \n    `z`是`10000000000000000000000000`(25个0)。\n\n* `|`是按位或：二进制编码中，每一位两者其中一个为1，则为1，否则，则为0，\n\n     因此 `val |=`就是对每一个字符合并，例如\n     \n     `ab` 是 `00010|00001`=>`00011`，\n     \n     `f` 是 `100000`，\n     \n     `ffff` 也是 `100000`，\n     \n     `big`是 `101000010`，\n     \n     `axdg`是`100000000000000001001001`。\n     \n* `&`，按位与，二进制编码中，每一位两者都为1，则为1，否则，则为0，\n  \n    例1：`axdg`和`oigd`要判断是否有重复：\n    \n    ```\n    axdg是：100000000000000001001001\n    \n    oifd是：         100000100101000\n    \n    & 后：  000000000000000000001000  \n    ```\n    因为第4位都为1，所以最后不为0，也可得知重复的就是字母表第4位：`d`。\n    \n    &nbsp;\n    \n    例2：`axdg`和`lkmk`要判断是否有重复：\n    \n    结果为0，说明无重复。\n    ```\n    axdg是：100000000000000001001001\n    \n    lkmk是：           1110000000000\n    \n    & 后：  000000000000000000000000  \n    ```\n总结：这种方法使用了二进制数字的位数作为保存字符的手段，相比起数组，散列表等，速度更快，在保存量较小(<=32)优势非常明显。\n\n代码：\n```js\n/**\n * @param {string[]} words\n * @return {number}\n */\nvar maxProduct = function(words) {\n    let aCode='a'.charCodeAt(0)\n    function compute(word){\n        let val=0\n        for(let i=0;i<word.length;i++){\n            val |= (1 << (word.charCodeAt(i)-aCode))\n        }\n        return val\n    }\n    let pretreatment=[]\n    for(let i=0;i<words.length;i++){\n        pretreatment[i]=compute(words[i])\n    }\n    let maxSum=0\n    for(let i=0;i<words.length-1;i++){\n        for(let j=i+1;j<words.length;j++){\n            let len1=words[i].length,len2=words[j].length\n            if(len1*len2>maxSum && (pretreatment[i] & pretreatment[j])===0){\n                 maxSum=len1*len2\n            }\n        }\n    }\n    return maxSum\n};\n```"
}
