{
  "content": "<pre class=\"hljs\"><code>React.cloneElement(\n  element,\n  [props],\n  [...children]\n)\n</code></pre>\n<h2>第一个参数：element</h2>\n<p>必须是一个存在的React组件或者原生DOM，以下都可以</p>\n<p><code>React.cloneElement(&lt;div /&gt;)</code>\n<code>React.cloneElement(&lt;Child /&gt;)</code></p>\n<p>但我们通常发现用的最多的是搭配React.Children.map和this.props.children使用，如下：</p>\n<pre class=\"hljs\"><code>React.Children.map(<span class=\"hljs-keyword\">this</span>.props.children,child=&gt;{\n    React.cloneElement(child,{...props},children)\n})\n</code></pre>\n<p>首先不能直接和this.props.children使用，一旦子元素数量大于1，type为undefined的React对象</p>\n<pre class=\"hljs\"><code>// 子元素数量大于1,返回空\nrender(){\n    return React.cloneElement(this.props.children,...)\n}\n</code></pre>\n<p>其次，这个方法的作用是为了给子组件进行自定义属性配置，这用到了第二个和第三个参数</p>\n<h2>第二个参数：props</h2>\n<p>配置当前element的props</p>\n<pre class=\"hljs\"><code><span class=\"hljs-comment\">// 我们的意图是希望每个child组件都继承父组件props</span>\nReact.Children.map(<span class=\"hljs-keyword\">this</span>.props.children,child=&gt;{\n    React.cloneElement(child,<span class=\"hljs-keyword\">this</span>.props)\n})\n</code></pre>\n<p>但上面的写法一旦遇到嵌套组件，则会触发<code>maximum call stack size is exceeded</code>，因为\n<code>this.props</code>包含了<code>children</code>属性，因此将一直迭代执行.</p>\n<p>这么写能安全的继承父组件props</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">const</span> {children,...otherPorps}=<span class=\"hljs-keyword\">this</span>.porps\nReact.Children.map(children,child=&gt;{\n    React.cloneElement(child,otherPorps)\n})\n</code></pre>\n<p>当然，props参数还可以自行配置新的属性，最终都能分别传递给每一个子组件</p>\n<h2>第三个参数：children</h2>\n<p>配置当前element的children，用的频率比起第二个参数相对较少</p>\n<p>和第二个参数一样，这里也不能使用this.props.children，否则也将进入死循环</p>\n"
}
